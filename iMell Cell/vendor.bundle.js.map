{"version":3,"sources":["webpack:///vendor.bundle.js","webpack:///webpack/bootstrap 8ae8e044cde9db8515d9","webpack:///./~/pouchdb-find/lib/utils.js","webpack:///./~/alerty/alerty.js","webpack:///./~/pouchdb-find/lib/adapters/local/utils.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./~/pouchdb-find/~/pouchdb-collate/lib/index.js","webpack:///./~/pikaday/pikaday.js","webpack:///./~/pouchdb-find/lib/abstract-mapreduce/utils.js","webpack:///./~/pouchdb-find/lib/adapters/local/abstract-mapper.js","webpack:///./~/pouchdb-find/lib/abstract-mapreduce/upsert.js","webpack:///./~/pouchdb-find/lib/adapters/local/get-indexes/index.js","webpack:///./~/pouchdb-find/lib/index.js","webpack:///./~/pouchdb-find/lib/massageCreateIndexRequest.js","webpack:///./~/pouchdb-find/~/inherits/inherits_browser.js","webpack:///./~/pouchdb-find/~/pouchdb-extend/index.js","webpack:///./~/pouchdb-find/~/pouchdb-promise/lib/index.js","webpack:///./~/pouchdb-find/~/pouchdb-upsert/index.js","webpack:///./~/pouchdb-find/~/spark-md5/spark-md5.js","webpack:///./~/pouchdb/lib/index-browser.js","webpack:///(webpack)/buildin/module.js","webpack:///./~/lodash/lodash.min.js","webpack:///./~/mousetrap-global-bind/mousetrap-global-bind.js","webpack:///./~/mousetrap/mousetrap.js","webpack:///./~/pouchdb-find/lib/abstract-mapreduce/create-view.js","webpack:///./~/pouchdb-find/lib/abstract-mapreduce/index.js","webpack:///./~/pouchdb-find/lib/abstract-mapreduce/taskqueue.js","webpack:///./~/pouchdb-find/lib/adapters/http/index.js","webpack:///./~/pouchdb-find/lib/adapters/local/create-index/index.js","webpack:///./~/pouchdb-find/lib/adapters/local/delete-index/index.js","webpack:///./~/pouchdb-find/lib/adapters/local/find/in-memory-filter.js","webpack:///./~/pouchdb-find/lib/adapters/local/find/index.js","webpack:///./~/pouchdb-find/lib/adapters/local/find/query-planner.js","webpack:///./~/pouchdb-find/lib/adapters/local/index.js","webpack:///./~/pouchdb-find/~/argsarray/index.js","webpack:///./~/pouchdb-find/~/debug/browser.js","webpack:///./~/pouchdb-find/~/debug/debug.js","webpack:///./~/pouchdb-find/~/debug/~/ms/index.js","webpack:///./~/pouchdb-find/~/is-array/index.js","webpack:///./~/pouchdb-find/~/pouchdb-collate/lib/utils.js","webpack:///./~/pouchdb-find/~/pouchdb-promise/~/lie/lib/index.js","webpack:///./~/pouchdb-find/~/pouchdb-promise/~/lie/~/immediate/lib/browser.js","webpack:///./~/pouchdb-find/~/pouchdb-upsert/~/pouchdb-promise/lib/index.js","webpack:///./~/pouchdb-find/~/pouchdb-upsert/~/pouchdb-promise/~/lie/lib/index.js","webpack:///./~/pouchdb-find/~/pouchdb-upsert/~/pouchdb-promise/~/lie/~/immediate/lib/browser.js","webpack:///./~/pouchdb/~/argsarray/index.js","webpack:///./~/pouchdb/~/debug/browser.js","webpack:///./~/pouchdb/~/debug/debug.js","webpack:///./~/pouchdb/~/debug/~/ms/index.js","webpack:///./~/pouchdb/~/es6-promise-pool/es6-promise-pool.js","webpack:///./~/pouchdb/~/inherits/inherits_browser.js","webpack:///./~/pouchdb/~/lie/lib/browser.js","webpack:///./~/pouchdb/~/lie/~/immediate/lib/browser.js","webpack:///./~/pouchdb/~/scope-eval/scope_eval.js","webpack:///./~/pouchdb/~/spark-md5/spark-md5.js","webpack:///./~/pouchdb/~/vuvuzela/index.js","webpack:///(webpack)/~/node-libs-browser/~/events/events.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","webpackJsonp","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","shift","0","e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","appendChild","m","c","process","Promise","once","fun","called","getArguments","args","console","trace","Error","this","len","arguments","Array","toPromise","func","usedCB","self","tempCB","pop","err","resp","nextTick","promise","fulfill","reject","mesg","then","result","cancel","inherits","clone","obj","extend","callbackify","cb","promisedCallback","res","reason","crypto","Md5","MD5","string","browser","hash","createHash","update","digest","flatten","subArr","isArray","concat","mergeObjects","arr","getFieldFromDoc","doc","parsedField","value","key","setFieldInDoc","elem","parseField","fieldName","fields","current","ch","substring","pick","oneArrayIsSubArrayOfOther","left","right","Math","min","oneArrayIsStrictSubArrayOfOther","oneSetIsSubArrayOfOther","slice","field","leftIdx","indexOf","splice","compare","arrayToObject","max","maxScore","element","score","arrayEquals","arr1","arr2","uniq","Object","keys","map","log","__WEBPACK_AMD_DEFINE_RESULT__","commonUse","addClass","el","cls","elClass","className","blank","added","removeClass","replace","removed","hasClass","elClassList","split","x","addEvent","addEventListener","attachEvent","removeEvent","removeEventListener","detachEvent","removeElement","parentNode","removeChild","setUid","prefix","floor","random","getElementById","Alerty","Dialog","defaults","okLabel","cancelLabel","time","previousCallback","template","setup","content","opts","onOk","onCancel","detect","$oldModal","querySelector","_callback","$wrapper","innerHTML","firstChild","body","$modal","$overlay","$title","$message","$btnArea","$btnOk","$btnCancel","$prompt","$input","focus","inputType","setAttribute","inputPlaceholder","inputValue","place","bgColor","style","backgroundColor","fontColor","color","title","marginTop","offsetHeight","bindEvent","that","setTimeout","close","toasts","alert","confirm","prompt","getKey","getValue","massageSort","sort","sorting","isCombinationalField","combinationFields","mergeGtGte","operator","fieldMatchers","$eq","$gte","$gt","mergeLtLte","$lte","$lt","mergeNe","$ne","mergeEq","mergeAndedSelectors","selectors","forEach","selector","matcher","massageSelector","input","utils","wasAnded","$and","$not","massageIndexDef","indexDef","getKeyFromDoc","index","def","filterInclusiveStart","rows","targetValue","indexFields","row","docKey","abs","collate","reverseOptions","newOpts","startkey","endkey","inclusive_start","inclusive_end","validateIndex","ascFields","filter","validateSort","requestDef","defaultUsed","noneIdSorts","sortItem","join","validateFindRequest","getUserFields","userFields","selectorFields","sortFields","Number","MAX_VALUE","rightIdx","sortOrder","defaultSetTimout","defaultClearTimeout","runTimeout","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","run","Item","array","noop","prototype","env","argv","version","versions","on","addListener","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask","indexify","numToIndexableString","toIndexableString","objKey","parseNumber","str","num","originalIdx","zero","neg","numAsString","magAsString","MAGNITUDE_DIGITS","magnitude","parseInt","MIN_MAGNITUDE","parseFloat","stack","metaStack","lastMetaElement","lastElementIndex","arrayCollate","a","b","stringCollate","objectCollate","ak","bk","collationIndex","idx","expFormat","toExponential","magForComparison","magString","padLeft","toString","SEP","factor","factorStr","toFixed","normalizeKey","ai","bi","Infinity","isNaN","origKey","Date","toJSON","k","hasOwnProperty","val","parseIndexableString","parsedNum","parsedStr","arrayElement","objElement","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","root","factory","u","hasMoment","moment","hasEventListeners","sto","capture","fireEvent","eventName","data","ev","createEvent","initEvent","dispatchEvent","createEventObject","trim","cn","test","isDate","getTime","isWeekend","date","day","getDay","isLeapYear","year","getDaysInMonth","month","setToStartOfDay","setHours","compareDates","to","from","overwrite","prop","hasProp","nodeName","adjustCalendar","calendar","ceil","bound","position","reposition","format","defaultDate","setDefaultDate","firstDay","minDate","maxDate","yearRange","showWeekNumber","minYear","maxYear","minMonth","maxMonth","startRange","endRange","isRTL","yearSuffix","showMonthAfterYear","numberOfMonths","mainCalendar","container","i18n","previousMonth","nextMonth","months","weekdays","weekdaysShort","theme","onSelect","onOpen","onClose","onDraw","renderDayName","abbr","renderDay","isEmpty","isDisabled","isToday","isSelected","isInRange","isStartRange","isEndRange","renderWeek","d","y","onejan","weekNum","renderRow","days","reverse","renderBody","renderHead","renderTitle","instance","refYear","j","monthHtml","yearHtml","_o","isMinYear","isMaxYear","html","prev","next","renderTable","Pikaday","options","config","_onMouseDown","_v","event","target","srcElement","setDate","getAttribute","hide","blur","prevMonth","_c","preventDefault","returnValue","_onChange","gotoMonth","gotoYear","_onInputChange","firedBy","isValid","toDate","parse","show","_onInputFocus","_onInputClick","_onInputBlur","pEl","activeElement","_b","_onClick","onchange","trigger","insertBefore","nextSibling","defDate","gotoDate","disableWeekends","disableDayFn","nom","setMinDate","setMaxDate","fallback","getFullYear","_d","toDateString","getMoment","setMoment","preventOnSelect","isMoment","getDate","draw","newCalendar","calendars","firstVisibleDate","lastVisibleDate","visibleDate","setMonth","getMonth","adjustCalendars","gotoToday","setStartRange","setEndRange","force","_y","_m","render","adjustPosition","width","height","viewportWidth","viewportHeight","scrollTop","top","clientRect","offsetWidth","innerWidth","documentElement","clientWidth","innerHeight","clientHeight","pageYOffset","getBoundingClientRect","pageXOffset","bottom","offsetLeft","offsetTop","offsetParent","now","before","cells","after","r","dayConfig","unshift","isVisible","v","destroy","argsarray","fin","promise2","sequentialize","promiseFactory","add","arrs","output","createDeepMultiMapper","toEmit","iLen","jLen","createDeepSingleMapper","createShallowSingleMapper","createShallowMultiMapper","checkShallow","createMapper","isShallow","isSingle","mapper","mapFunDef","reducer","ddocValidator","ddoc","viewName","view","views","_id","localUtils","abstractMapReduce","abstractMapper","upsert","db","diffFun","getIndexes","allDocs","include_docs","allDocsRes","indexes","language","viewNames","total_rows","httpIndexes","localIndexes","plugin","createIndex","adapter","find","deleteIndex","PouchDB","create","ctor","superCtor","super_","constructor","enumerable","writable","configurable","TempCtor","String","class2type","core_toString","isWindow","isPlainObject","nodeType","core_hasOwn","isFunction","extendInner","copy","copyIsArray","optionsIsArray","deep","numericStringRegex","types","typename","toLowerCase","_interopDefault","ex","lie","PouchPromise","upsertInner","docId","get","status","docRev","_rev","newDoc","tryAndPut","updated","rev","put","putIfNotExists","existingDoc","add32","cmn","q","s","t","ff","gg","hh","ii","md5cycle","md5blk","md5blks","charCodeAt","md5blk_array","md51","tail","tmp","lo","hi","n","state","match","md51_array","subarray","Uint8Array","hex_chr","rhex","hex","md5","SparkMD5","reset","lsw","msw","append","unescape","encodeURIComponent","appendBinary","contents","_buff","_length","_state","substr","end","raw","ret","buff","_finish","hashBinary","ArrayBuffer","_concatArrayBuffer","byteLength","first","second","firstLength","set","global","isBinaryObject","object","Blob","cloneArrayBuffer","targetArray","sourceArray","cloneBinaryObject","size","webkitSlice","proto","getPrototypeOf","Ctor","funcToString","objectCtorString","newObject","toISOString","adapterFun","logApiCall","enabled","logArgs","origCallback","responseArgs","_closed","_destroyed","taskqueue","isReady","addTask","failed","identityFunction","formatResultForOpenRevsGet","ok","bulkGet","collapseResultsAndFinish","results","perDocResults","docs","info","checkDone","numDone","numDocs","gotResult","docIndex","nextBatch","allRequests","upTo","MAX_NUM_CONCURRENT_REQUESTS","batch","processBatch","offset","docIdx","docRequests","requestsById","docOpts","open_revs","request","formatResult","param","error","requests","isChromeApp","chrome","storage","local","hasLocalStorage","hasLocal","attachBrowserEvents","onChanged","db_name","dbName","newValue","Changes","events","EventEmitter","_listeners","guardedConsole","method","randomNumber","maxTimeout","ratio","range","defaultBackOff","explainError","extend$1","sources","each","source","PouchError","message","createError","CustomPouchError","generateErrorFromResponse","UNKNOWN_ERROR","tryFilter","req","msg","BAD_REQUEST","filterChange","hasFilter","query","query_params","change","filterReturn","attachments","att","_attachments","stub","invalidIdError","INVALID_ID","RESERVED_ID","MISSING_ID","listenerCount","ee","parseDesignDocFunctionName","parts","normalizeDesignDocFunctionName","normalized","parseUri","parser","exec","uri","encoded","decodeURIComponent","qName","qParser","$0","$1","$2","radix","uuid","chars","out","mangle","unmangle","_Map","store","_Set","winningRev","metadata","winningId","winningPos","winningDeleted","node","toVisit","rev_tree","tree","ids","branches","pos","deleted","traverseRevTree","revs","newCtx","ctx","sortByPos","collectLeaves","leaves","isLeaf","acc","collectConflicts","win","conflicts","leaf","compactTree","revHash","rootToLeaf","paths","history","sortByPos$1","binarySearch","item","comparator","mid","low","high","insertSorted","pathToTree","path","numStemmed","currentLeaf","compareTree","mergeTree","in_tree1","in_tree2","tree1","tree2","merged","doMerge","dontExpand","restree","branch","t1","t2","diff","candidateParents","trees","parent","parentIdx","elements","elementsLen","stem","depth","maybeStem","stemmed","stemmedNode","merge","newTree","stemmedRevs","revExists","splitRev","targetPos","targetId","getTrees","isDeleted","isLocalId","evalFilter","scopedEval","evalView","code","tryCatchInChangeListener","Changes$1","onDestroy","complete","onChange","isCancelled","bind","doChanges","processChange","changeList","changes","_conflicts","arrayFirst","yankError","cleanDocs","_deleted","atts","compareByIdThenRev","idCompare","aStart","_revisions","start","bStart","computeHeight","edges","prnt","edge","allDocsKeysQuery","api","skip","limit","descending","_allDocs","finalResults","all","subOpts","optKey","resolve","doNextCompaction","task","_compactionQueue","last_seq","_compact","attachmentNameError","charAt","AbstractPouchDB","TaskQueue","parseAdapter","adapterName","skipIdb","adapters","localStorage","preferredAdapters","usePrefix","use_prefix","prepareForDestruction","onDestroyed","onConstructorDestroyed","destructionListeners","_destructionListeners","has","__opts","auto_compaction","prefixedName","backend","_adapter","debug","valid","fail","ready","setUpEventEmitter","Pouch","eventEmitter","destructListeners","toObject","reduce","parseRevisionInfo","INVALID_REV","makeRevTreeFromRevisions","revisions","revisionIds","parseDoc","newEdits","nRevNum","newRevId","revInfo","_rev_tree","specialKey","reservedWords","DOC_VALIDATION","dataWords","createBlob","properties","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","getBlob","binaryStringToArrayBuffer","bin","buf","binStringToBluffer","binString","b64ToBluffer","b64","atob$1","arrayBufferToBinaryString","buffer","binary","bytes","fromCharCode","readAsBinaryString","blob","FileReader","FileReaderSync","readAsArrayBuffer","reader","hasBinaryString","onloadend","blobToBinaryString","blobOrBuffer","blobToBase64","base64","btoa$1","rawToBase64","sliceBlob","appendBlob","arrayBuffer","appendString","binaryMd5","setImmediateShim","loadNextChunk","done","currentChunk","chunkSize","chunks","inputIsString","MD5_CHUNK_SIZE","stringMd5","parseBase64","BAD_ARG","preprocessString","blobType","asBinary","content_type","preprocessBlob","preprocessAttachment","preprocessAttachments","docInfos","docv","overallErr","docInfo","processedAttachment","recv","updateDoc","revLimit","writeDoc","previousWinningRev","previouslyDeleted","isRoot","inConflict","REV_CONFLICT","newRev","rev_map","newRevIsDeleted","winningRev$$","winningRevIsDeleted","delta","rootIsMissing","processDocs","fetchedDocs","tx","overallCallback","insertDoc","resultsIdx","MISSING_DOC","checkAllDocsDone","docsDone","docsToDo","new_edits","idsToDocs","currentDoc","docWritten","nextDoc","slowJsonParse","JSON","vuvuzela","safeJsonParse","safeJsonStringify","json","stringify","tryCode","applyNext","taskQueue","running","action","idbError","evt","IDB_ERROR","encodeMetadata","deletedOrLocal","seq","decodeMetadata","storedObject","decodeDoc","_doc_id_rev","lastIndexOf","readBlobData","asBlob","fetchAttachmentsIfNecessary","txn","fetchAttachment","attObj","objectStore","ATTACH_STORE","onsuccess","postProcessAttachments","attNames","compactRevs","count","deleteOrphanedAttachments","possiblyOrphanedDigests","countReq","attAndSeqStore","IDBKeyRange","attStore","seqStore","BY_SEQ_STORE","ATTACH_AND_SEQ_STORE","cursor","openCursor","only","digestSeq","primaryKey","openTransactionSafely","idb","stores","mode","transaction","idbBulkDocs","dbOpts","idbChanges","startTransaction","DOC_STORE","LOCAL_STORE","txnResult","onabort","ontimeout","oncomplete","docStore","bySeqStore","attachStore","attachAndSeqStore","verifyAttachments","preconditionErrored","fetchExistingDocs","idbProcessDocs","revs_limit","numFetched","readMetadata","notify","_meta","docCount","docCountDelta","verifyAttachment","MISSING_STUB","finish","digests","filename","attErr","isUpdate","hasAttachments","writeAttachments","finishDoc","afterPutDoc","revsToDelete","metadataToStore","metaDataReq","afterPutMetadata","afterPutDocError","stopPropagation","getKeyReq","putReq","insertAttachmentMappings","onerror","collectResults","attachmentSaved","revpos","saveAttachment","attsAdded","attsToAdd","newAtt","docInfoError","blobSupport","createKeyRange","inclusiveEnd","upperBound","lowerBound","handleKeyRangeError","idbAllDocs","allDocsQuery","fetchDocAsynchronously","docIdRevIndex","allDocsInner","onGetCursor","onResultsReady","onTxnComplete","keyRange","checkBlobSupport","DETECT_BLOB_SUPPORT_STORE","matchedChrome","navigator","userAgent","matchedEdge","IdbPouch","thisCallback","init","createSchema","createObjectStore","keyPath","autoIncrement","unique","META_STORE","addDeletedOrLocalIndex","createLocalStoreSchema","migrateLocalStore","localStore","docIdRev","seqCursor","addAttachAndSeqStore","migrateAttsAndSeqs","digestMap","migrateMetadata","decodeMetadataCompat","fetchMetadataSeq","metadataSeq","onGetMetadataSeq","instanceId","_bulkDocs","reqOpts","_get","_getAttachment","attachId","attachment","blobData","_info","cachedDBs","updateSeq","doc_count","update_seq","idb_attachment_format","_changes","onGetMetadata","lastSeq","onGetWinningDoc","fetchWinningDoc","winningDoc","filtered","numResults","returnDocs","docIds","docIdsToMetadata","fetchChanges","objectStores","since","continuous","doc_ids","return_docs","_close","NOT_OPEN","_getRevisionTree","_doCompaction","_getLocal","_putLocal","oldRev","oStore","oldDoc","_removeLocal","_destroy","openReq","openReqList","indexedDB","deleteDatabase","cached","tryStorageOption","open","ADAPTER_VERSION","onupgradeneeded","migration","migrations","oldVersion","currentTarget","onversionchange","checkSetupComplete","meta","blobSupportPromise","IDBPouch","decodeUtf8","escape","hexToInt","charCode","parseHexUtf8","parseHexUtf16","parseHexString","encoding","quote","escapeBlob","unescapeBlob","stringifyDoc","unstringifyDoc","qMarks","select","table","joiner","where","orderBy","compactRevs$1","deleteOrphans","seqs","sql","ATTACH_AND_SEQ_STORE$1","executeSql","digestsToCheck","nonOrphanedDigests","ATTACH_STORE$1","BY_SEQ_STORE$1","websqlError","errorNameMatch","errorName","errorReason","WSQ_ERROR","getSize","isAndroid","websqlBulkDocs","websqlChanges","_name","_docCount","cnt","sqlArgs","deletedInt","insertId","dataWritten","fetchSql","attachmentErr","revsToCompact","DOC_STORE$1","metadataStr","params","websqlProcessDocs","userDocs","docInfoErrors","openDatabaseWithOpts","websql","description","openDBSafely","openDB$1","cachedResult","cachedDatabases","fetchAttachmentsIfNecessary$1","attOpts","_","WebSqlPouch$1","dbCreated","runMigration2","DOC_STORE_WINNINGSEQ_INDEX_SQL","BY_SEQ_STORE_DELETED_INDEX_SQL","runMigration3","LOCAL_STORE$1","doNext","runMigration4","updateRows","doc_id_rev","doc_id","BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL","runMigration5","nextPage","SELECT_DOCS","DOC_STORE_AND_BY_SEQ_JOINER","pageSize","addDigestSeq","digestSeqs","digestSeqPairs","pair","attachAndRev","ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL","ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL","runMigration6","runMigration7","checkEncoding","onGetInstanceId","idRequests","idCallback","onGetVersion","dbVersion","META_STORE$1","attach","initSeq","initSeqArgs","ADAPTER_VERSION$1","setupDone","migrated","dbid","tasks","nextMigration","fetchVersion","db_version","countDocs","websqlOpts","POUCH_VERSION","openDBResult","readTransaction","websql_encoding","totalRows","criteria","l","selectStmt","reportChange","maxSeq","escaped","putLocal","values","rowsAffected","removeLocal","canOpenTestDB","openDatabase","isValidWebSQL","hasLS","localStorageKey","openedTestDB","openDB","WebSQLPouch","_opts","WebSqlPouch","wrappedFetch","wrappedPromise","fetch","response","fetchRequest","timer","headers","Headers","fetchOptions","credentials","processData","url","fetchResponse","statusCode","text","abort","xhRequest","xhr","timedout","abortReq","cleanUp","timeoutReq","onprogress","upload","onreadystatechange","XMLHttpRequest","exception","withCredentials","Accept","responseType","setRequestHeader","readyState","getResponseHeader","responseText","send","testXhr","ajax$1","hasXhr","defaultBody","ajaxCore","onSuccess","missing","res$2","defaultOptions","cache","ajax","ua","isSafari","isIE","isEdge","shouldCacheBust","isBlobUrl","hasArgs","readAttachmentsAsBlobOrBuffer","encodeDocId","preprocessAttachments$1","hasUrlPrefix","protocol","getHost","user","password","auth","username","genDBUrl","genUrl","pathDel","host","port","paramsToStr","HttpPouch","ajax$$","userOpts","reqAjax","ajaxOpts","log$1","_ajax","ajaxPromise","adapterFun$$","skipSetup","skip_setup","setupPromise","checkExists","dbUrl","encodeAttachmentId","attachmentId","nAuth","token","Authorization","compact","ping","compact_running","interval","doBulkGet","doBulkGetShim","onResult","batchNum","numBatches","batchSize","MAX_SIMULTANEOUS_REVS","supportsBulkGet","supportsBulkGetMap","fetchAttachments","filenames","PromisePool","fetchAllAttachments","docOrDocs","revs_info","remove","docOrId","optsOrRev","getAttachment","removeAttachment","putAttachment","Content-Type","_put","start_key","end_key","paramStr","batch_size","CHANGES_BATCH_SIZE","leftToFetch","feed","heartbeat","param_name","lastFetchedSeq","aborted","xhrOpts","fetched","raw_results_length","finished","revsDiff","HttpPouch$1","pad","padWith","upToLength","padding","targetLength","TaskQueue$1","createView","cachedViews","sourceDB","mapFun","reduceFun","temporary","viewSignature","_cachedViews","promiseForView","diffFunction","fullViewName","depDbs","depDbName","registerDependentDatabase","lastSeqDoc","QueryParseError","captureStackTrace","NotFoundError","BuiltInError","createBuiltInError","sum","jNum","evalFunctionWithEval","log$2","parseViewName","isGenOne","emitError","tryCode$1","sortByKeyThenValue","keyCompare","sliceResults","rowToDocId","readAttachmentsAsBlobOrBuffer$1","postprocessAttachments","addHttpParam","paramName","asJson","coerceInteger","integerCandidate","asNumber","coerceOptions","group_level","checkPositiveInteger","number","checkQueryParseError","startkeyName","endkeyName","group","optionName","httpQuery","MAX_URL_LENGTH","keysAsString","customQuery","_query","customViewCleanup","_viewCleanup","defaultsTo","getDocsToPersist","docIdsToChangesAndEmits","getMetaDoc","defaultMetaDoc","metaDocId","getKeyValueDocs","metaDoc","processKvDocs","kvDocsRes","kvDocs","oldKeysMap","indexableKeysToKeyValues","keyValue","newKeys","kvDoc","docData","saveKeyValues","seqDocId","listOfDocsToPersist","docsToPersist","bulkDocs","getQueue","persistentQueues","updateView","updateViewInQueue","mapResults","origMap","currentSeq","processNextBatch","onError","CHANGES_BATCH_SIZE$1","lastKey","jl","complexKey","indexableKey","reduceView","shouldGroup","builtInReduce","groups","lvl","POSITIVE_INFINITY","last","groupKey","reduceTry","queryView","queryViewInQueue","fetchFromView","viewOpts","expectedKeys","parsedKeyAndDocId","onMapResultsReady","shouldReduce","docIdsToDocs","fetchPromises","keyStart","keyEnd","httpViewCleanup","localViewCleanup","docsToViews","designDocName","viewsToStatus","ddocName","viewDBNames","statusIsGood","viewDBName","dbsToDelete","destroyPromises","queryPromised","createViewOpts","tempViewQueue","cleanup","stale","isGenOne$1","fileHasChanged","localDoc","remoteDoc","getDocAttachments","getDocAttachmentsFromTargetOrSource","doCheckForLocalAttachments","createBulkGetOpts","diffs","missingRevs","missingRev","getDocs","getAllDocs","bulkGetOpts","bulkGetResponse","cancelled","bulkGetInfo","resultDocs","Boolean","hasConflicts","fetchRevisionOneDocs","getRevisionOneDocs","returnResult","updateCheckpoint","checkpoint","session","session_id","replicator","REPLICATOR","CHECKPOINT_VERSION","CHECKPOINT_HISTORY_SIZE","Checkpointer","compareReplicationLogs","srcDoc","tgtDoc","compareReplicationHistory","sourceHistory","targetHistory","S","sourceRest","T","targetRest","LOWEST_SEQ","sourceId","hasSessionId","sessionId","props","rest","isForbiddenError","backOff","retry","back_off_function","backOffSet","current_back_off","STARTING_BACK_OFF","removeBackOffSetter","sortObjectPropertiesByKey","queryParams","generateReplicationId","filterFun","filterViewName","queryData","md5sum","replicate$1","initCheckpointer","checkpointer","repId","writeDocs","changedDocs","currentBatch","bulkOpts","completeReplication","errorsById","errorsNo","doc_write_failures","docs_written","errors","finishBatch","outResult","writingCheckpoint","writeCheckpoint","getChanges","onCheckpointError","getDiffs","getBatchDocs","got","docs_read","startNextBatch","batches","processPendingBatch","abortReplication","immediate","pendingBatch","changesOpts","live","changesCompleted","replicationCompleted","fatalError","end_time","onChangesComplete","changesPending","onChangesError","abortChanges","batches_limit","_abortChanges","startChanges","getCheckpoint","start_time","_addedListeners","Replication","toPouch","PouchConstructor","replicate","replicateRet","srcPouch","targetPouch","sync","Sync","pullChange","direction","pushChange","pushDenied","pullDenied","pushPaused","pullPaused","pushActive","pullActive","removeAll","isChange","isDenied","isPaused","isActive","canceled","optsPush","optsPull","pull","success","replication","defineProperty","other","Function","setItem","getItem","eventFunction","inprogress","notifyLocalWindows","MISSING_BULK_DOCS","QUERY_PARSE_ERROR","NOT_AN_OBJECT","mangled","filterChanges","newPromise","filterName","filters","post","createAttachment","prevrevpos","was_delete","addToMissing","revId","processDoc","missingForId","missingObj","compactDocument","maxHeight","revTree","candidates","promises","onComplete","finishOpenRevs","indexOfRev","howMany","_revs_info","TypeError","incompatibleOpt","_type","attachmentError","dependentDb","dependentDbs","depDB","destroyDb","deletedMap","trueName","RegExp","execute","addToPreferredAdapters","defaultOpts","PouchAlt","atob","btoa","setImmediate","platform","finalPromiseFactory","_sum","_count","_stats","sumsqr","_sumsqr","viewCleanup","mapreduce","updateTarget","updateSource","readOnlySource","comparisons","targetDoc","sourceDoc","1","_readyCalled","webpackPolyfill","deprecate","children","o","f","h","g","P","F","w","A","E","O","I","R","z","W","B","Dt","L","U","C","M","D","Wt","Rt","lastIndex","tn","$","N","NaN","Z","V","K","G","J","Y","H","Q","X","tt","nt","rt","et","ut","it","ot","ft","ct","at","lt","st","ht","pt","_t","vt","gt","dt","yt","bt","xt","jt","wt","mt","At","kt","Et","Ot","St","It","zt","Bt","Lt","Ut","Ct","Mt","\\","'","\n","\r"," "," ","Tt","$t","Ft","Nt","Pt","Zt","qt","Vt","Kt","Gt","isArrayBuffer","Jt","Yt","isMap","Ht","isRegExp","Qt","isSet","Xt","isTypedArray","nn","À","Á","Â","Ã","Ä","Å","à","á","â","ã","ä","å","Ç","ç","Ð","ð","È","É","Ê","Ë","è","é","ê","ë","Ì","Í","Î","Ï","ì","í","î","ï","Ñ","ñ","Ò","Ó","Ô","Õ","Ö","Ø","ò","ó","ô","õ","ö","ø","Ù","Ú","Û","Ü","ù","ú","û","ü","Ý","ý","ÿ","Æ","æ","Þ","þ","ß","Ā","Ă","Ą","ā","ă","ą","Ć","Ĉ","Ċ","Č","ć","ĉ","ċ","č","Ď","Đ","ď","đ","Ē","Ĕ","Ė","Ę","Ě","ē","ĕ","ė","ę","ě","Ĝ","Ğ","Ġ","Ģ","ĝ","ğ","ġ","ģ","Ĥ","Ħ","ĥ","ħ","Ĩ","Ī","Ĭ","Į","İ","ĩ","ī","ĭ","į","ı","Ĵ","ĵ","Ķ","ķ","ĸ","Ĺ","Ļ","Ľ","Ŀ","Ł","ĺ","ļ","ľ","ŀ","ł","Ń","Ņ","Ň","Ŋ","ń","ņ","ň","ŋ","Ō","Ŏ","Ő","ō","ŏ","ő","Ŕ","Ŗ","Ř","ŕ","ŗ","ř","Ś","Ŝ","Ş","Š","ś","ŝ","ş","š","Ţ","Ť","Ŧ","ţ","ť","ŧ","Ũ","Ū","Ŭ","Ů","Ű","Ų","ũ","ū","ŭ","ů","ű","ų","Ŵ","ŵ","Ŷ","ŷ","Ÿ","Ź","Ż","Ž","ź","ż","ž","Ĳ","ĳ","Œ","œ","ŉ","ſ","rn","&","<",">","\"","en","&amp;","&lt;","&gt;","&quot;","&#39;","un","fi","vu","nf","ui","De","__wrapped__","__actions__","__chain__","__index__","__values__","__dir__","__filtered__","__iteratees__","__takeCount__","__views__","clear","__data__","tf","ef","af","Hu","me","cr","fn","Le","Cr","dn","an","fu","ti","ln","vn","sn","hn","pn","_n","Mr","Iu","xi","gn","Zu","Ou","yn","_u","be","Rr","xe","Dr","je","se","bn","xn","Ju","jn","Qu","po","wn","mn","An","bu","kn","En","we","On","ro","Sn","eo","In","su","Rn","ke","Sr","Ue","zn","Wn","Bn","Ln","Un","Wi","Cn","Mn","ze","Pe","Dn","Tn","$n","Fn","ce","ae","Nn","Pn","Zn","ri","Ce","qn","Vn","Kn","pu","Gn","Mu","Xn","Qn","Fu","Jn","Oe","Ri","Yn","Hn","cu","ge","Se","Su","tr","au","Wr","du","ku","Ru","nr","rr","_e","Br","er","ur","ir","or","yi","fr","ki","Ui","ar","lr","Re","sr","Wu","hr","pr","_r","vr","gr","dr","yr","br","xr","jr","Qi","wr","fo","mr","Ar","thisArg","kr","Er","Or","vo","Ir","pi","zr","byteOffset","Lr","zi","Ur","ao","Tr","$r","Ae","Fr","Nr","Pr","Vr","Zr","Eu","qr","Uu","Lu","Xi","Kr","pe","ue","Yr","placeholder","Gr","Jr","le","thru","he","co","Ee","plant","Hr","Qr","Xr","te","Ai","ne","re","ju","Au","ho","We","ie","Gu","wu","oe","fe","uo","Hi","Fe","Zi","iteratee","Du","ve","de","ye","_i","Ie","Me","Be","Bi","ei","Te","$e","Ne","Ze","qe","Ci","Ve","Ke","Ge","Je","Ye","He","Qe","no","Xe","tu","nu","ru","eu","uu","Po","leading","maxWait","trailing","oo","flush","iu","Cache","ou","lu","hu","gu","oi","yu","xu","vi","mu","valueOf","zu","Bu","Uf","Cu","Tu","chain","$u","Nu","Pu","qu","Vu","Ku","Yu","Xu","ni","IE_PROTO","ci","li","Buffer","si","Symbol","iterator","gi","di","propertyIsEnumerable","isConcatSpreadable","ji","wi","mi","Ei","getOwnPropertySymbols","Oi","isBuffer","Si","isFinite","Ii","Li","Mi","Di","Ti","$i","Fi","Ni","Pi","qi","Vi","Ki","Gi","Ji","Yi","templateSettings","evaluate","interpolate","variable","imports","io","so","go","yo","bo","xo","jo","wo","mo","Ao","ko","Eo","Oo","So","Io","Ro","zo","Wo","Bo","Lo","Uo","Co","Mo","Do","To","$o","Fo","No","Zo","qo","Vo","Ko","Go","Jo","Yo","Ho","Qo","Xo","rf","uf","of","cf","lf","sf","hf","pf","_f","vf","gf","df","yf","mf","bf","xf","jf","wf","Af","kf","Ef","Of","Sf","If","Rf","zf","Wf","Bf","Lf","toUpperCase","Cf","Mf","Df","Tf","$f","Ff","Nf","Pf","Zf","qf","Vf","Kf","Gf","Jf","Yf","Hf","Qf","Xf","ary","assign","assignIn","assignInWith","assignWith","bindAll","bindKey","castArray","chunk","cond","conforms","constant","countBy","curry","curryRight","debounce","defaultsDeep","defer","delay","difference","differenceBy","differenceWith","drop","dropRight","dropRightWhile","dropWhile","fill","flatMap","flatMapDeep","flatMapDepth","flattenDeep","flattenDepth","flip","flow","flowRight","fromPairs","functions","functionsIn","groupBy","initial","intersection","intersectionBy","intersectionWith","invert","invertBy","invokeMap","keyBy","keysIn","mapKeys","mapValues","matches","matchesProperty","memoize","mergeWith","methodOf","mixin","negate","nthArg","omit","omitBy","over","overArgs","overEvery","overSome","partial","partialRight","partition","pickBy","property","propertyOf","pullAll","pullAllBy","pullAllWith","pullAt","rangeRight","rearg","sampleSize","setWith","shuffle","sortBy","sortedUniq","sortedUniqBy","spread","take","takeRight","takeRightWhile","takeWhile","tap","throttle","toArray","toPairs","toPairsIn","toPath","toPlainObject","transform","unary","union","unionBy","unionWith","uniqBy","uniqWith","unset","unzip","unzipWith","updateWith","valuesIn","without","words","wrap","xor","xorBy","xorWith","zip","zipObject","zipObjectDeep","zipWith","entries","entriesIn","extendWith","attempt","camelCase","capitalize","clamp","cloneDeep","cloneDeepWith","cloneWith","conformsTo","deburr","defaultTo","divide","endsWith","eq","escapeRegExp","every","findIndex","findKey","findLast","findLastIndex","findLastKey","forEachRight","forIn","forInRight","forOwn","forOwnRight","gte","hasIn","identity","includes","inRange","invoke","isArguments","isArrayLike","isArrayLikeObject","isBoolean","isElement","isEqual","isEqualWith","isError","isInteger","isLength","isMatch","isMatchWith","isNative","isNil","isNull","isNumber","isObject","isObjectLike","isSafeInteger","isString","isSymbol","isUndefined","isWeakMap","isWeakSet","kebabCase","lowerCase","lowerFirst","lte","maxBy","mean","meanBy","minBy","stubArray","stubFalse","stubObject","stubString","stubTrue","multiply","nth","noConflict","padEnd","padStart","reduceRight","repeat","round","runInContext","sample","snakeCase","some","sortedIndex","sortedIndexBy","sortedIndexOf","sortedLastIndex","sortedLastIndexBy","sortedLastIndexOf","startCase","startsWith","subtract","sumBy","sourceURL","times","toFinite","toInteger","toLength","toLower","toNumber","toSafeInteger","toUpper","trimEnd","trimStart","truncate","separator","omission","search","uniqueId","upperCase","upperFirst","eachRight","VERSION","commit","Mousetrap","_globalCallbacks","_originalStopCallback","stopCallback","combo","sequence","paused","bindGlobal","unbindGlobal","unbind","_addEvent","_characterFromEvent","character","which","shiftKey","_MAP","_KEYCODE_MAP","_modifiersMatch","modifiers1","modifiers2","_eventModifiers","modifiers","altKey","ctrlKey","metaKey","_preventDefault","_stopPropagation","cancelBubble","_isModifier","_getReverseMap","_REVERSE_MAP","_pickBestAction","_keysFromString","combination","_getKeyInfo","_SPECIAL_ALIASES","_SHIFT_MAP","_belongsTo","ancestor","targetElement","_resetSequences","doNotReset","activeSequences","_sequenceLevels","_nextExpectedAction","_getMatches","sequenceName","level","_callbacks","deleteCombo","deleteSequence","_fireCallback","_handleKeyEvent","keyCode","_ignoreNextKeyup","handleKey","_resetSequenceTimer","_resetTimer","_bindSequence","_increaseSequence","nextAction","_callbackAndReset","isFinal","wrappedCallback","_bindSingle","_directMap","_ignoreNextKeypress","_handleKey","maxLevel","processedSequenceCallback","ignoreThisKeypress","_bindMultiple","combinations","8","9","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","45","46","91","93","224","106","107","109","110","111","186","187","188","189","190","191","192","219","220","221","222","~","!","@","#","%","^","*","(",")","+",":","?","|","option","command","return","plus","mod","tagName","isContentEditable","addKeycodes","documentMousetrap","pluginName","cachedView","createIndexer","pouchCollate","cur","massageCreateIndexRequest","pouchUpsert","updateDdoc","hasInvalidLanguage","viewExists","originalIndexDef","ddocId","signature","deltaFun","createFieldSorter","getFieldValuesAsArray","docFieldValue","aRow","bRow","aFieldValues","bFieldValues","collation","filterInMemoryFields","inMemoryFields","rowFilter","fieldSorter","matchCominationalSelector","matchSelector","userOperator","userValue","orMatchers","matchers","fieldExists","fieldIsNotUndefined","modField","divisor","arrayContainsValue","arrayContainsAllValues","arraySize","regexMatch","typeMatch","$elemMatch","$exists","$mod","neValue","$in","$nin","$size","$all","$regex","$type","indexToSignature","doAllDocs","originalOpts","getIndexesRes","queryPlan","planQuery","indexToUse","queryOpts","isDescending","warning","checkFieldInIndex","indexField","userOperatorLosesPrecision","sortFieldsByIndex","aIdx","bIdx","getBasicInMemoryFields","needToFilterInMemory","getInMemoryFieldsFromNe","getInMemoryFields","coreInMemoryFields","checkIndexFieldsMatch","sortMatches","selectorMatches","isNonLogicalMatcher","logicalMatchers","checkFieldsLogicallySound","firstField","hasLogicalOperator","matcherKey","isInvalidNe","checkIndexMatches","fieldsMatch","findMatchingIndexes","indexMatches","findBestMatchingIndex","scoreIndex","userFieldsMap","matchingIndexes","defaultIndex","getSingleFieldQueryOptsFor","getSingleFieldCoreQueryPlan","combinedOpts","userOperators","newQueryOpts","getMultiFieldCoreQueryPlan","getMultiFieldQueryOpts","inclusiveStart","COLLATE_LO","COLLATE_HI","usingGtlt","previousKeys","previousWasEq","previousWasSame","gtltLostSpecificity","getDefaultQueryPlan","getCoreQueryPlan","userFieldsRes","coreQueryPlan","￿","argsArray","useColors","firebug","formatArgs","namespace","humanize","lastC","save","namespaces","removeItem","load","localstorage","colors","formatters","enable","selectColor","prevColor","disabled","curr","ms","prevTime","coerce","formatter","logFn","skips","names","disable","short","long","plural","padRight","stringLexCompare","aLen","bLen","aChar","bChar","intToDecimalForm","int","isNeg","remainder","INTERNAL","resolver","PENDING","outcome","handled","UNHANDLED","safelyResolveThenable","QueueItem","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","handlers","getThen","thenable","tryToUnwrap","tryCatch","iterable","allResolver","resolveFromAll","outValue","resolved","race","REJECTED","FULFILLED","oldQueue","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","observer","createTextNode","observe","characterData","MessageChannel","scriptEl","channel","port1","onmessage","port2","postMessage","EventTarget","listener","listeners","isGenerator","functionToIterator","promiseToIterator","toIterator","PromisePoolEvent","concurrency","_concurrency","_options","_iterator","_done","_size","_promise","active","_proceed","_fireEvent","_settle","_onPooledPromiseFulfilled","_onPooledPromiseRejected","_trackPromise","scope","toUtf8","utf8Str2ArrayBuffer","returnUInt8Array","arrayBuffer2Utf8Str","concatenateArrayBuffers","hexToBinaryString","begin","_hash","getState","setState","arrayPrefix","objPrefix","numChar","parsedString","lastCh","numConsecutiveSlashes","_events","_maxListeners","arg","defaultMaxListeners","setMaxListeners","handler","context","newListener","warned","fired","list","evlistener","emitter"],"mappings":"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","file":"vendor.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t0:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!********************!*\\\n  !*** multi vendor ***!\n  \\********************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(/*! pouchdb */20);\n\t__webpack_require__(/*! pouchdb-find */13);\n\t__webpack_require__(/*! lodash */45);\n\t__webpack_require__(/*! mousetrap */47);\n\t__webpack_require__(/*! mousetrap-global-bind */46);\n\t__webpack_require__(/*! pikaday */8);\n\tmodule.exports = __webpack_require__(/*! alerty */4);\n\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */\n/*!*************************************!*\\\n  !*** ./~/pouchdb-find/lib/utils.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar Promise = __webpack_require__(/*! pouchdb-promise */ 17);\n\t\n\t/* istanbul ignore next */\n\texports.once = function (fun) {\n\t  var called = false;\n\t  return exports.getArguments(function (args) {\n\t    if (called) {\n\t      console.trace();\n\t      throw new Error('once called  more than once');\n\t    } else {\n\t      called = true;\n\t      fun.apply(this, args);\n\t    }\n\t  });\n\t};\n\t/* istanbul ignore next */\n\texports.getArguments = function (fun) {\n\t  return function () {\n\t    var len = arguments.length;\n\t    var args = new Array(len);\n\t    var i = -1;\n\t    while (++i < len) {\n\t      args[i] = arguments[i];\n\t    }\n\t    return fun.call(this, args);\n\t  };\n\t};\n\t/* istanbul ignore next */\n\texports.toPromise = function (func) {\n\t  //create the function we will be returning\n\t  return exports.getArguments(function (args) {\n\t    var self = this;\n\t    var tempCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n\t    // if the last argument is a function, assume its a callback\n\t    var usedCB;\n\t    if (tempCB) {\n\t      // if it was a callback, create a new callback which calls it,\n\t      // but do so async so we don't trap any errors\n\t      usedCB = function (err, resp) {\n\t        process.nextTick(function () {\n\t          tempCB(err, resp);\n\t        });\n\t      };\n\t    }\n\t    var promise = new Promise(function (fulfill, reject) {\n\t      try {\n\t        var callback = exports.once(function (err, mesg) {\n\t          if (err) {\n\t            reject(err);\n\t          } else {\n\t            fulfill(mesg);\n\t          }\n\t        });\n\t        // create a callback for this invocation\n\t        // apply the function in the orig context\n\t        args.push(callback);\n\t        func.apply(self, args);\n\t      } catch (e) {\n\t        reject(e);\n\t      }\n\t    });\n\t    // if there is a callback, call it back\n\t    if (usedCB) {\n\t      promise.then(function (result) {\n\t        usedCB(null, result);\n\t      }, usedCB);\n\t    }\n\t    promise.cancel = function () {\n\t      return this;\n\t    };\n\t    return promise;\n\t  });\n\t};\n\t\n\texports.inherits = __webpack_require__(/*! inherits */ 15);\n\texports.Promise = Promise;\n\t\n\texports.clone = function (obj) {\n\t  return exports.extend(true, {}, obj);\n\t};\n\t\n\texports.extend = __webpack_require__(/*! pouchdb-extend */ 16);\n\t\n\texports.callbackify = function (fun) {\n\t  return exports.getArguments(function (args) {\n\t    var cb = args.pop();\n\t    var promise = fun.apply(this, args);\n\t    exports.promisedCallback(promise, cb);\n\t    return promise;\n\t  });\n\t};\n\t\n\texports.promisedCallback = function (promise, callback) {\n\t  promise.then(function (res) {\n\t    process.nextTick(function () {\n\t      callback(null, res);\n\t    });\n\t  }, function (reason) {\n\t    process.nextTick(function () {\n\t      callback(reason);\n\t    });\n\t  });\n\t  return promise;\n\t};\n\t\n\tvar crypto = __webpack_require__(/*! crypto */ 83);\n\tvar Md5 = __webpack_require__(/*! spark-md5 */ 19);\n\t\n\texports.MD5 = function (string) {\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    return crypto.createHash('md5').update(string).digest('hex');\n\t  } else {\n\t    return Md5.hash(string);\n\t  }\n\t};\n\t\n\texports.flatten = exports.getArguments(function (args) {\n\t  var res = [];\n\t  for (var i = 0, len = args.length; i < len; i++) {\n\t    var subArr = args[i];\n\t    if (Array.isArray(subArr)) {\n\t      res = res.concat(exports.flatten.apply(null, subArr));\n\t    } else {\n\t      res.push(subArr);\n\t    }\n\t  }\n\t  return res;\n\t});\n\t\n\texports.mergeObjects = function (arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    res = exports.extend(true, res, arr[i]);\n\t  }\n\t  return res;\n\t};\n\t\n\t// this would just be \"return doc[field]\", but fields\n\t// can be \"deep\" due to dot notation\n\texports.getFieldFromDoc = function (doc, parsedField) {\n\t  var value = doc;\n\t  for (var i = 0, len = parsedField.length; i < len; i++) {\n\t    var key = parsedField[i];\n\t    value = value[key];\n\t    if (!value) {\n\t      break;\n\t    }\n\t  }\n\t  return value;\n\t};\n\t\n\texports.setFieldInDoc = function (doc, parsedField, value) {\n\t  for (var i = 0, len = parsedField.length; i < len-1; i++) {\n\t    var elem = parsedField[i];\n\t    doc = doc[elem] = {};\n\t  }\n\t  doc[parsedField[len-1]] = value;\n\t};\n\t\n\t// Converts a string in dot notation to an array of its components, with backslash escaping\n\texports.parseField = function (fieldName) {\n\t  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n\t  var fields = [];\n\t  var current = '';\n\t  for (var i = 0, len = fieldName.length; i < len; i++) {\n\t    var ch = fieldName[i];\n\t    if (ch === '.') {\n\t      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n\t        current = current.substring(0, current.length - 1) + '.';\n\t      } else { // not escaped, so delimiter\n\t        fields.push(current);\n\t        current = '';\n\t      }\n\t    } else { // normal character\n\t      current += ch;\n\t    }\n\t  }\n\t  fields.push(current);\n\t  return fields;\n\t};\n\t\n\t// Selects a list of fields defined in dot notation from one doc\n\t// and copies them to a new doc. Like underscore _.pick but supports nesting.\n\texports.pick = function (obj, arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    var parsedField = exports.parseField(arr[i]);\n\t    var value = exports.getFieldFromDoc(obj, parsedField);\n\t    if(typeof value !== 'undefined') {\n\t      exports.setFieldInDoc(res, parsedField, value);\n\t    }\n\t  }\n\t  return res;\n\t};\n\t\n\t// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\n\texports.oneArrayIsSubArrayOfOther = function (left, right) {\n\t\n\t  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n\t    if (left[i] !== right[i]) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t};\n\t\n\t// e.g.['a', 'b', 'c'], ['a', 'b'] is false\n\texports.oneArrayIsStrictSubArrayOfOther = function (left, right) {\n\t\n\t  if (left.length > right.length) {\n\t    return false;\n\t  }\n\t\n\t  return exports.oneArrayIsSubArrayOfOther(left, right);\n\t};\n\t\n\t// same as above, but treat the left array as an unordered set\n\t// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\n\texports.oneSetIsSubArrayOfOther = function (left, right) {\n\t  left = left.slice();\n\t  for (var i = 0, len = right.length; i < len; i++) {\n\t    var field = right[i];\n\t    if (!left.length) {\n\t      break;\n\t    }\n\t    var leftIdx = left.indexOf(field);\n\t    if (leftIdx === -1) {\n\t      return false;\n\t    } else {\n\t      left.splice(leftIdx, 1);\n\t    }\n\t  }\n\t  return true;\n\t};\n\t\n\texports.compare = function (left, right) {\n\t  return left < right ? -1 : left > right ? 1 : 0;\n\t};\n\t\n\texports.arrayToObject = function (arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    res[arr[i]] = true;\n\t  }\n\t  return res;\n\t};\n\t\n\texports.max = function (arr, fun) {\n\t  var max = null;\n\t  var maxScore = -1;\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    var element = arr[i];\n\t    var score = fun(element);\n\t    if (score > maxScore) {\n\t      maxScore = score;\n\t      max = element;\n\t    }\n\t  }\n\t  return max;\n\t};\n\t\n\texports.arrayEquals = function (arr1, arr2) {\n\t  if (arr1.length !== arr2.length) {\n\t    return false;\n\t  }\n\t  for (var i = 0, len = arr1.length; i < len; i++) {\n\t    if (arr1[i] !== arr2[i]) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t};\n\t\n\texports.uniq = function(arr) {\n\t  var obj = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    obj['$' + arr[i]] = true;\n\t  }\n\t  return Object.keys(obj).map(function (key) {\n\t    return key.substring(1);\n\t  });\n\t};\n\t\n\texports.log = __webpack_require__(/*! debug */ 59)('pouchdb:find');\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 6)))\n\n/***/ },\n/* 4 */\n/*!****************************!*\\\n  !*** ./~/alerty/alerty.js ***!\n  \\****************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module) {(function () {\r\n\t  'use strict';\r\n\t\r\n\t  // common function which is often using\r\n\t  var commonUse = {\r\n\t    /**\r\n\t     * [Add class to element]\r\n\t     *\r\n\t     * @param el {Object}   -- element.\r\n\t     * @param cls {String}  -- classes.\r\n\t     */\r\n\t    addClass: function(el, cls) {\r\n\t      var elClass = el.className;\r\n\t      var blank = (elClass !== '') ? ' ' : '';\r\n\t      var added = elClass + blank + cls;\r\n\t      el.className = added;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * [Remove class from element]\r\n\t     *\r\n\t     * @param el {Object}   -- element.\r\n\t     * @param cls {String}  -- classes.\r\n\t     */\r\n\t    removeClass: function(el, cls) {\r\n\t      var elClass = ' '+el.className+' ';\r\n\t      elClass = elClass.replace(/(\\s+)/gi, ' ');\r\n\t      var removed = elClass.replace(' '+cls+' ', ' ');\r\n\t      removed = removed.replace(/(^\\s+)|(\\s+$)/g, '');\r\n\t      el.className = removed;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * [if element has some class]\r\n\t     *\r\n\t     * @param el {Object}   -- element.\r\n\t     * @param cls {String}  -- classes.\r\n\t     *\r\n\t     * @return  {Boolean}   -- true or false.\r\n\t     */\r\n\t    hasClass: function(el, cls) {\r\n\t      var elClass = el.className;\r\n\t      var elClassList = elClass.split(/\\s+/);\r\n\t      var x = 0;\r\n\t      for(x in elClassList) {\r\n\t        if(elClassList[x] == cls) {\r\n\t          return true;\r\n\t        }\r\n\t      }\r\n\t      return false;\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * [add event to some element, dom0, dom1, supports fuck ie]\r\n\t     *\r\n\t     * @param el {Object}       -- element.\r\n\t     * @param type {String}     -- event type, such as 'click', 'mouseover'.\r\n\t     * @param func {Function}   -- function.\r\n\t     *\r\n\t     */\r\n\t    addEvent: function(el, type, func) {\r\n\t      if(el.addEventListener) {\r\n\t        el.addEventListener(type, func, false);\r\n\t      } else if(el.attachEvent){ \r\n\t        el.attachEvent('on' + type, func);\r\n\t      } else{ \r\n\t        el['on' + type] = func; \r\n\t      }  \r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * [remove event to some element, dom0, dom1, supports fuck ie]\r\n\t     *\r\n\t     * @param el {Object}       -- element.\r\n\t     * @param type {String}     -- event type, such as 'click', 'mouseover'.\r\n\t     * @param func {Function}   -- function.\r\n\t     *\r\n\t     */\r\n\t    removeEvent: function(el, type, func) {\r\n\t      if (el.removeEventListener){ \r\n\t        el.removeEventListener(type, func, false);\r\n\t      } else if (el.detachEvent){\r\n\t        el.detachEvent('on' + type, func);\r\n\t      } else {\r\n\t        delete el['on' + type];\r\n\t      }\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * [Remove element node]\r\n\t     *\r\n\t     * @param el {Object}   -- element.\r\n\t     *\r\n\t     */\r\n\t    removeElement: function(el) {\r\n\t      (el && el.parentNode) && el.parentNode.removeChild(el);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * [Set unique id]\r\n\t     *\r\n\t     * @param prefix {String}   -- id prefix name.\r\n\t     *\r\n\t     * @return  {String}\r\n\t     */\r\n\t    setUid: function(prefix) {\r\n\t      do prefix += Math.floor(Math.random() * 1000000);\r\n\t      while (document.getElementById(prefix));\r\n\t      return prefix;\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * [Alertiy public API]\r\n\t   *\r\n\t   * @return {Object}\r\n\t   */\r\n\t  var Alerty = function() {\r\n\t\r\n\t    // private object for Alerty object inherit\r\n\t    var Dialog = {\r\n\t      \r\n\t      // static defaults params\r\n\t      defaults: {\r\n\t        okLabel: '\\u786e\\u5b9a',\r\n\t        cancelLabel: '\\u53d6\\u6d88',\r\n\t        time: 2000\r\n\t      },\r\n\t\r\n\t      previousCallback: null,  // for cache previous toasts callbak, to handle if call more than 1 alerty\r\n\t\r\n\t      // html templates\r\n\t      template: '<div class=\"alerty-overlay\" tabindex=\"-1\"></div>'+\r\n\t                '<div class=\"alerty\">'+\r\n\t                  '<div class=\"alerty-title\"></div>'+\r\n\t                  '<div class=\"alerty-content\">'+\r\n\t                    '<p class=\"alerty-message\"></p>'+\r\n\t                    '<div class=\"alerty-prompt\">'+\r\n\t                      '<input type=\"text\" placeholder=\"\" value=\"\">'+\r\n\t                      '<div class=\"input-line\"></div>'+\r\n\t                    '</div>'+\r\n\t                  '</div>'+\r\n\t                  '<div class=\"alerty-action\">'+\r\n\t                    '<a class=\"btn-cancel\"></a>'+\r\n\t                    '<a class=\"btn-ok\"></a>'+\r\n\t                  '</div>'+\r\n\t                '</div>',\r\n\t\r\n\t\r\n\t\r\n\t      /** \r\n\t       * [Build the HTML contents]\r\n\t       *\r\n\t       * @param type {String}           -- get the dialog type to arrange the correspondent html content.\r\n\t       * @param content {String}        -- the text contents dialog to users.\r\n\t       * @param opts {Object}           -- options.\r\n\t       * @param onOk {Function}         -- custom callback function after click ok button.\r\n\t       * @param onCancel {Function}     -- custom callback function after click cancel button.\r\n\t       */\r\n\t      setup: function(type, content, opts, onOk, onCancel) {\r\n\t        // for if argument opts is not given.\r\n\t        var detect = typeof opts === 'function';\r\n\t        if (detect) {\r\n\t          onCancel = onOk;\r\n\t          onOk = opts;\r\n\t        }\r\n\t\r\n\t        var $oldModal = document.querySelector('.alerty');\r\n\t\r\n\t\r\n\t        // if previous modal is open, remove it and immediately callback\r\n\t        if ($oldModal) {\r\n\t          commonUse.removeElement($oldModal);\r\n\t          var _callback = this.previousCallback;\r\n\t          if (_callback) _callback();\r\n\t        }\r\n\t\r\n\t        var $wrapper = document.createElement('div');\r\n\t        $wrapper.innerHTML = this.template;\r\n\t\r\n\t        // append alerty to body\r\n\t        while ($wrapper.firstChild) {\r\n\t          document.body.appendChild($wrapper.firstChild);\r\n\t        }\r\n\t\r\n\t        // cache alerty dom for next use\r\n\t        var $modal = document.querySelector('.alerty');\r\n\t        var $overlay = document.querySelector('.alerty-overlay');\r\n\t        var $title = $modal.querySelector('.alerty-title');\r\n\t        var $message = $modal.querySelector('.alerty-message');\r\n\t        var $btnArea = $modal.querySelector('.alerty-action');\r\n\t        var $btnOk = $modal.querySelector('.btn-ok');\r\n\t        var $btnCancel = $modal.querySelector('.btn-cancel');\r\n\t        var $prompt = $modal.querySelector('.alerty-prompt');\r\n\t        var $input = $prompt.querySelector('input');\r\n\t\r\n\t        // set uid\r\n\t        $modal.id = commonUse.setUid('alerty');\r\n\t        $overlay.id = 'overlay-'+$modal.id;\r\n\t\r\n\t        // animation show alerty\r\n\t        commonUse.addClass($overlay, 'active');\r\n\t        commonUse.addClass($modal, 'alerty-show');\r\n\t        $message.innerHTML = content;  // set msg\r\n\t\r\n\t        if (opts && opts.time) this.defaults.time = opts.time; // handle time if set\r\n\t\r\n\t        if (type !== 'prompt') {\r\n\t          commonUse.removeElement($prompt); // other type do not need\r\n\t        } else {\r\n\t          $input.focus(); // auto focus input if type prompt\r\n\t\r\n\t          if(opts && opts.inputType) $input.setAttribute('type', opts.inputType); // handle input type, such as 'password'\r\n\t          if(opts && opts.inputPlaceholder) $input.setAttribute('placeholder', opts.inputPlaceholder); // handle input placeholder\r\n\t          if(opts && opts.inputValue) $input.setAttribute('value', opts.inputValue); // handle input default value \r\n\t        }\r\n\t\r\n\t        if (type === 'toasts') {\r\n\t          this.previousCallback = onOk;  // cache callback\r\n\t\r\n\t          // rearrange template\r\n\t          commonUse.removeElement($title);\r\n\t          commonUse.removeElement($btnArea);\r\n\t          commonUse.removeElement($overlay);\r\n\t          commonUse.addClass($modal, 'toasts');\r\n\t\r\n\t          if (opts && opts.place === 'top') commonUse.addClass($modal, 'place-top'); // handle toasts top place\r\n\t          if (opts && opts.bgColor) $modal.style.backgroundColor = opts.bgColor;\r\n\t          if (opts && opts.fontColor) $message.style.color =opts.fontColor;\r\n\t\r\n\t        } else {\r\n\t          commonUse.addClass(document.body, 'no-scrolling'); // body no scorll\r\n\t          (opts && opts.title) ? $title.innerHTML = opts.title : commonUse.removeElement($title); // handle title if set\r\n\t          (opts && opts.okLabel) ? $btnOk.innerHTML = opts.okLabel : $btnOk.innerHTML = this.defaults.okLabel; // handle ok text if set\r\n\t          $modal.style.marginTop =  - $modal.offsetHeight / 2 + 'px'; // set the place to center using margin-top;\r\n\t\r\n\t          if (type === 'confirm' || type === 'prompt') {\r\n\t            (opts && opts.cancelLabel) ? $btnCancel.innerHTML = opts.cancelLabel : $btnCancel.innerHTML = this.defaults.cancelLabel; // handle cancel text if set\r\n\t          } else {\r\n\t            commonUse.removeElement($btnCancel); // toasts and alery type do not need cancel btn\r\n\t          }\r\n\t        }\r\n\t\r\n\t        this.bindEvent($modal, onOk, onCancel); // see next\r\n\t      },\r\n\t\r\n\t      /** \r\n\t       * [Bind event to dialog]\r\n\t       *\r\n\t       * @param $modal {Object}       -- modal node.\r\n\t       * @param: onOk {Function}      -- ok callback.\r\n\t       * @param: onCancel {Function}  -- cancel callback.\r\n\t       */\r\n\t      bindEvent: function($modal, onOk, onCancel) {\r\n\t        var that = this;\r\n\t        var $btnOk = $modal.querySelector('.btn-ok');\r\n\t        var $btnCancel = $modal.querySelector('.btn-cancel');\r\n\t\r\n\t        // toasts delay hide\r\n\t        if (commonUse.hasClass($modal, 'toasts')) {\r\n\t          setTimeout(function() {\r\n\t            // if toasts has been removed\r\n\t            if (document.getElementById($modal.id) === null) return;\r\n\t            that.close($modal, onOk);\r\n\t          }, that.defaults.time);\r\n\t        }\r\n\t        // click ok button\r\n\t        if ($btnOk) {\r\n\t          commonUse.addEvent($btnOk, 'click', function() {\r\n\t            that.close($modal, onOk);\r\n\t          });\r\n\t        }\r\n\t        // click cancel button\r\n\t        if ($btnCancel) {\r\n\t          commonUse.addEvent($btnCancel, 'click', function() {\r\n\t            that.close($modal, onCancel);\r\n\t          });\r\n\t        }\r\n\t      },\r\n\t\r\n\t      /** \r\n\t       * [Close the actived modal and remove it]\r\n\t       *\r\n\t       * @param: $modal {Obejct}  -- modal element to remove.\r\n\t       * @param: callback {Function}  -- callback function.\r\n\t       */\r\n\t      close: function($modal, callback) {\r\n\t        var $input = $modal.querySelector('input');\r\n\t        var $overlay = document.getElementById('overlay-'+$modal.id);\r\n\t\r\n\t        // hide alerty with animation\r\n\t        commonUse.removeClass($modal, 'alerty-show');\r\n\t        commonUse.addClass($modal, 'alerty-hide');\r\n\t\r\n\t        // remove alerty and other added elements\r\n\t        setTimeout(function(){\r\n\t          $overlay && commonUse.removeClass($overlay, 'active'), commonUse.removeClass(document.body, 'no-scrolling');\r\n\t          \r\n\t          commonUse.removeElement($modal);\r\n\t          commonUse.removeElement($overlay);\r\n\t          if (callback) {\r\n\t            setTimeout(function(){\r\n\t              !$input ? callback() : callback($input.value);  // handle prompt type, callback the input value\r\n\t            }, 100);\r\n\t          }\r\n\t        },100);\r\n\t      }\r\n\t    };\r\n\t\r\n\t    return {\r\n\t      // return alerty.toasts();\r\n\t      toasts: function(content, opts, callback) {\r\n\t        Dialog.setup('toasts', content, opts, callback);\r\n\t      },\r\n\t\r\n\t      // return alerty.alert();\r\n\t      alert: function(content, opts, onOk) {\r\n\t        Dialog.setup('alert', content, opts, onOk);\r\n\t      },\r\n\t\r\n\t      // return alerty.confirm();\r\n\t      confirm: function(content, opts, onOk, onCancel) {\r\n\t        Dialog.setup('confirm', content, opts, onOk, onCancel);\r\n\t      },\r\n\t\r\n\t      // return alerty.prompt();\r\n\t      prompt: function(content, opts, callback) {\r\n\t        Dialog.setup('prompt', content, opts, callback);\r\n\t      }\r\n\t    };\r\n\t  };\r\n\t\r\n\t\r\n\t\r\n\t  // NPM, AMD, and wndow support\r\n\t  if ('undefined' !== typeof module && !! module && !! module.exports) {\r\n\t    module.exports = function() {\r\n\t      return new Alerty();\r\n\t    };\r\n\t    var obj = new Alerty();\r\n\t    for (var key in obj) {\r\n\t      module.exports[key] = obj[key];\r\n\t    }\r\n\t  } else if (true) {\r\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\r\n\t      return new Alerty();\r\n\t    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t  } else {\r\n\t    window.alerty = new Alerty();\r\n\t  }\r\n\t}());\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/module.js */ 21)(module)))\n\n/***/ },\n/* 5 */\n/*!****************************************************!*\\\n  !*** ./~/pouchdb-find/lib/adapters/local/utils.js ***!\n  \\****************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(/*! ../../utils */ 3);\n\tvar collate = __webpack_require__(/*! pouchdb-collate */ 7);\n\t\n\tfunction getKey(obj) {\n\t  return Object.keys(obj)[0];\n\t}\n\t\n\tfunction getValue(obj) {\n\t  return obj[getKey(obj)];\n\t}\n\t\n\t// normalize the \"sort\" value\n\tfunction massageSort(sort) {\n\t  if (!Array.isArray(sort)) {\n\t    throw new Error('invalid sort json - should be an array');\n\t  }\n\t  return sort.map(function (sorting) {\n\t    if (typeof sorting === 'string') {\n\t      var obj = {};\n\t      obj[sorting] = 'asc';\n\t      return obj;\n\t    } else {\n\t      return sorting;\n\t    }\n\t  });\n\t}\n\t\n\tvar combinationFields = ['$or', '$nor', '$not'];\n\tfunction isCombinationalField (field) {\n\t  return combinationFields.indexOf(field) > -1;\n\t}\n\t\n\t// collapse logically equivalent gt/gte values\n\tfunction mergeGtGte(operator, value, fieldMatchers) {\n\t  if (typeof fieldMatchers.$eq !== 'undefined') {\n\t    return; // do nothing\n\t  }\n\t  if (typeof fieldMatchers.$gte !== 'undefined') {\n\t    if (operator === '$gte') {\n\t      if (value > fieldMatchers.$gte) { // more specificity\n\t        fieldMatchers.$gte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value >= fieldMatchers.$gte) { // more specificity\n\t        delete fieldMatchers.$gte;\n\t        fieldMatchers.$gt = value;\n\t      }\n\t    }\n\t  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n\t    if (operator === '$gte') {\n\t      if (value > fieldMatchers.$gt) { // more specificity\n\t        delete fieldMatchers.$gt;\n\t        fieldMatchers.$gte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value > fieldMatchers.$gt) { // more specificity\n\t        fieldMatchers.$gt = value;\n\t      }\n\t    }\n\t  } else {\n\t    fieldMatchers[operator] = value;\n\t  }\n\t}\n\t\n\t// collapse logically equivalent lt/lte values\n\tfunction mergeLtLte(operator, value, fieldMatchers) {\n\t  if (typeof fieldMatchers.$eq !== 'undefined') {\n\t    return; // do nothing\n\t  }\n\t  if (typeof fieldMatchers.$lte !== 'undefined') {\n\t    if (operator === '$lte') {\n\t      if (value < fieldMatchers.$lte) { // more specificity\n\t        fieldMatchers.$lte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value <= fieldMatchers.$lte) { // more specificity\n\t        delete fieldMatchers.$lte;\n\t        fieldMatchers.$lt = value;\n\t      }\n\t    }\n\t  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n\t    if (operator === '$lte') {\n\t      if (value < fieldMatchers.$lt) { // more specificity\n\t        delete fieldMatchers.$lt;\n\t        fieldMatchers.$lte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value < fieldMatchers.$lt) { // more specificity\n\t        fieldMatchers.$lt = value;\n\t      }\n\t    }\n\t  } else {\n\t    fieldMatchers[operator] = value;\n\t  }\n\t}\n\t\n\t// combine $ne values into one array\n\tfunction mergeNe(value, fieldMatchers) {\n\t  if ('$ne' in fieldMatchers) {\n\t    // there are many things this could \"not\" be\n\t    fieldMatchers.$ne.push(value);\n\t  } else { // doesn't exist yet\n\t    fieldMatchers.$ne = [value];\n\t  }\n\t}\n\t\n\t// add $eq into the mix\n\tfunction mergeEq(value, fieldMatchers) {\n\t  // these all have less specificity than the $eq\n\t  // TODO: check for user errors here\n\t  delete fieldMatchers.$gt;\n\t  delete fieldMatchers.$gte;\n\t  delete fieldMatchers.$lt;\n\t  delete fieldMatchers.$lte;\n\t  delete fieldMatchers.$ne;\n\t  fieldMatchers.$eq = value;\n\t}\n\t\n\t// flatten an array of selectors joined by an $and operator\n\tfunction mergeAndedSelectors(selectors) {\n\t\n\t  // sort to ensure that e.g. if the user specified\n\t  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n\t  // just {$gt: 'b'}\n\t  var res = {};\n\t\n\t  selectors.forEach(function (selector) {\n\t    Object.keys(selector).forEach(function (field) {\n\t      var matcher = selector[field];\n\t      if (typeof matcher !== 'object') {\n\t        matcher = {$eq: matcher};\n\t      }\n\t\n\t      if (isCombinationalField(field)) {\n\t        if (matcher instanceof Array) {\n\t          res[field] = matcher.map(function (m) {\n\t            return mergeAndedSelectors([m]);\n\t          });\n\t        } else {\n\t          res[field] = mergeAndedSelectors([matcher]);\n\t        }\n\t      } else {\n\t        var fieldMatchers = res[field] = res[field] || {};\n\t        Object.keys(matcher).forEach(function (operator) {\n\t          var value = matcher[operator];\n\t\n\t          if (operator === '$gt' || operator === '$gte') {\n\t            return mergeGtGte(operator, value, fieldMatchers);\n\t          } else if (operator === '$lt' || operator === '$lte') {\n\t            return mergeLtLte(operator, value, fieldMatchers);\n\t          } else if (operator === '$ne') {\n\t            return mergeNe(value, fieldMatchers);\n\t          } else if (operator === '$eq') {\n\t            return mergeEq(value, fieldMatchers);\n\t          }\n\t          fieldMatchers[operator] = value;\n\t        });\n\t      }\n\t    });\n\t  });\n\t\n\t  return res;\n\t}\n\t\n\t//\n\t// normalize the selector\n\t//\n\tfunction massageSelector(input) {\n\t  var result = utils.clone(input);\n\t  var wasAnded = false;\n\t  if ('$and' in result) {\n\t    result = mergeAndedSelectors(result['$and']);\n\t    wasAnded = true;\n\t  }\n\t\n\t  if ('$not' in result) {\n\t    //This feels a little like forcing, but it will work for now,\n\t    //I would like to come back to this and make the merging of selectors a little more generic\n\t    result['$not'] = mergeAndedSelectors([result['$not']]);\n\t  }\n\t\n\t  var fields = Object.keys(result);\n\t\n\t  for (var i = 0; i < fields.length; i++) {\n\t    var field = fields[i];\n\t    var matcher = result[field];\n\t\n\t    if (typeof matcher !== 'object' || matcher === null) {\n\t      matcher = {$eq: matcher};\n\t    } else if ('$ne' in matcher && !wasAnded) {\n\t      // I put these in an array, since there may be more than one\n\t      // but in the \"mergeAnded\" operation, I already take care of that\n\t      matcher.$ne = [matcher.$ne];\n\t    }\n\t    result[field] = matcher;\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\t\n\tfunction massageIndexDef(indexDef) {\n\t  indexDef.fields = indexDef.fields.map(function (field) {\n\t    if (typeof field === 'string') {\n\t      var obj = {};\n\t      obj[field] = 'asc';\n\t      return obj;\n\t    }\n\t    return field;\n\t  });\n\t  return indexDef;\n\t}\n\t\n\tfunction getKeyFromDoc(doc, index) {\n\t  var res = [];\n\t  for (var i = 0; i < index.def.fields.length; i++) {\n\t    var field = getKey(index.def.fields[i]);\n\t    res.push(doc[field]);\n\t  }\n\t  return res;\n\t}\n\t\n\t// have to do this manually because REASONS. I don't know why\n\t// CouchDB didn't implement inclusive_start\n\tfunction filterInclusiveStart(rows, targetValue, index) {\n\t  var indexFields = index.def.fields;\n\t  for (var i = 0, len = rows.length; i < len; i++) {\n\t    var row = rows[i];\n\t\n\t    // shave off any docs at the beginning that are <= the\n\t    // target value\n\t\n\t    var docKey = getKeyFromDoc(row.doc, index);\n\t    if (indexFields.length === 1) {\n\t      docKey = docKey[0]; // only one field, not multi-field\n\t    } else { // more than one field in index\n\t      // in the case where e.g. the user is searching {$gt: {a: 1}}\n\t      // but the index is [a, b], then we need to shorten the doc key\n\t      while (docKey.length > targetValue.length) {\n\t        docKey.pop();\n\t      }\n\t    }\n\t    //ABS as we just looking for values that don't match\n\t    if (Math.abs(collate.collate(docKey, targetValue)) > 0) {\n\t      // no need to filter any further; we're past the key\n\t      break;\n\t    }\n\t  }\n\t  return i > 0 ? rows.slice(i) : rows;\n\t}\n\t\n\tfunction reverseOptions(opts) {\n\t  var newOpts = utils.clone(opts);\n\t  delete newOpts.startkey;\n\t  delete newOpts.endkey;\n\t  delete newOpts.inclusive_start;\n\t  delete newOpts.inclusive_end;\n\t\n\t  if ('endkey' in opts) {\n\t    newOpts.startkey = opts.endkey;\n\t  }\n\t  if ('startkey' in opts) {\n\t    newOpts.endkey = opts.startkey;\n\t  }\n\t  if ('inclusive_start' in opts) {\n\t    newOpts.inclusive_end = opts.inclusive_start;\n\t  }\n\t  if ('inclusive_end' in opts) {\n\t    newOpts.inclusive_start = opts.inclusive_end;\n\t  }\n\t  return newOpts;\n\t}\n\t\n\tfunction validateIndex(index) {\n\t  var ascFields = index.fields.filter(function (field) {\n\t    return getValue(field) === 'asc';\n\t  });\n\t  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n\t    throw new Error('unsupported mixed sorting');\n\t  }\n\t}\n\t\n\tfunction validateSort (requestDef, index) {\n\t  if (index.defaultUsed && requestDef.sort) {\n\t    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n\t      return Object.keys(sortItem)[0] !== '_id';\n\t    }).map(function (sortItem) {\n\t      return Object.keys(sortItem)[0];\n\t    });\n\t\n\t    if (noneIdSorts.length > 0) {\n\t      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') +\n\t      '\" when using the default index');\n\t    }\n\t  }\n\t\n\t  if (index.defaultUsed) {\n\t    return;\n\t  }\n\t}\n\t\n\tfunction validateFindRequest(requestDef) {\n\t  if (typeof requestDef.selector !== 'object') {\n\t    throw new Error('you must provide a selector when you find()');\n\t  }\n\t\n\t  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n\t  for (var i = 0; i < selectors.length; i++) {\n\t    var selector = selectors[i];\n\t    var keys = Object.keys(selector);\n\t    if (keys.length === 0) {\n\t      throw new Error('invalid empty selector');\n\t    }\n\t    //var selection = selector[keys[0]];\n\t    /*if (Object.keys(selection).length !== 1) {\n\t      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n\t        ' - it must have exactly one key/value');\n\t    }\n\t  }*/\n\t}\n\t\n\t// determine the maximum number of fields\n\t// we're going to need to query, e.g. if the user\n\t// has selection ['a'] and sorting ['a', 'b'], then we\n\t// need to use the longer of the two: ['a', 'b']\n\tfunction getUserFields(selector, sort) {\n\t  var selectorFields = Object.keys(selector);\n\t  var sortFields = sort? sort.map(getKey) : [];\n\t  var userFields;\n\t  if (selectorFields.length >= sortFields.length) {\n\t    userFields = selectorFields;\n\t  } else {\n\t    userFields = sortFields;\n\t  }\n\t\n\t  if (sortFields.length === 0) {\n\t    return {\n\t      fields: userFields\n\t    };\n\t  }\n\t\n\t  // sort according to the user's preferred sorting\n\t  userFields = userFields.sort(function (left, right) {\n\t    var leftIdx = sortFields.indexOf(left);\n\t    if (leftIdx === -1) {\n\t      leftIdx = Number.MAX_VALUE;\n\t    }\n\t    var rightIdx = sortFields.indexOf(right);\n\t    if (rightIdx === -1) {\n\t      rightIdx = Number.MAX_VALUE;\n\t    }\n\t    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n\t  });\n\t\n\t  return {\n\t    fields: userFields,\n\t    sortOrder: sort.map(getKey)\n\t  };\n\t}\n\t\n\tmodule.exports = {\n\t  getKey: getKey,\n\t  getValue: getValue,\n\t  massageSort: massageSort,\n\t  massageSelector: massageSelector,\n\t  validateIndex: validateIndex,\n\t  validateFindRequest: validateFindRequest,\n\t  validateSort: validateSort,\n\t  reverseOptions: reverseOptions,\n\t  filterInclusiveStart: filterInclusiveStart,\n\t  massageIndexDef: massageIndexDef,\n\t  parseField: utils.parseField,\n\t  getUserFields: getUserFields,\n\t  isCombinationalField: isCombinationalField\n\t};\n\n\n/***/ },\n/* 6 */\n/*!**********************************************************!*\\\n  !*** (webpack)/~/node-libs-browser/~/process/browser.js ***!\n  \\**********************************************************/\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 7 */\n/*!*******************************************************!*\\\n  !*** ./~/pouchdb-find/~/pouchdb-collate/lib/index.js ***!\n  \\*******************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\n\tvar MAGNITUDE_DIGITS = 3; // ditto\n\tvar SEP = ''; // set to '_' for easier debugging \n\t\n\tvar utils = __webpack_require__(/*! ./utils */ 63);\n\t\n\texports.collate = function (a, b) {\n\t\n\t  if (a === b) {\n\t    return 0;\n\t  }\n\t\n\t  a = exports.normalizeKey(a);\n\t  b = exports.normalizeKey(b);\n\t\n\t  var ai = collationIndex(a);\n\t  var bi = collationIndex(b);\n\t  if ((ai - bi) !== 0) {\n\t    return ai - bi;\n\t  }\n\t  if (a === null) {\n\t    return 0;\n\t  }\n\t  switch (typeof a) {\n\t    case 'number':\n\t      return a - b;\n\t    case 'boolean':\n\t      return a === b ? 0 : (a < b ? -1 : 1);\n\t    case 'string':\n\t      return stringCollate(a, b);\n\t  }\n\t  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n\t};\n\t\n\t// couch considers null/NaN/Infinity/-Infinity === undefined,\n\t// for the purposes of mapreduce indexes. also, dates get stringified.\n\texports.normalizeKey = function (key) {\n\t  switch (typeof key) {\n\t    case 'undefined':\n\t      return null;\n\t    case 'number':\n\t      if (key === Infinity || key === -Infinity || isNaN(key)) {\n\t        return null;\n\t      }\n\t      return key;\n\t    case 'object':\n\t      var origKey = key;\n\t      if (Array.isArray(key)) {\n\t        var len = key.length;\n\t        key = new Array(len);\n\t        for (var i = 0; i < len; i++) {\n\t          key[i] = exports.normalizeKey(origKey[i]);\n\t        }\n\t      } else if (key instanceof Date) {\n\t        return key.toJSON();\n\t      } else if (key !== null) { // generic object\n\t        key = {};\n\t        for (var k in origKey) {\n\t          if (origKey.hasOwnProperty(k)) {\n\t            var val = origKey[k];\n\t            if (typeof val !== 'undefined') {\n\t              key[k] = exports.normalizeKey(val);\n\t            }\n\t          }\n\t        }\n\t      }\n\t  }\n\t  return key;\n\t};\n\t\n\tfunction indexify(key) {\n\t  if (key !== null) {\n\t    switch (typeof key) {\n\t      case 'boolean':\n\t        return key ? 1 : 0;\n\t      case 'number':\n\t        return numToIndexableString(key);\n\t      case 'string':\n\t        // We've to be sure that key does not contain \\u0000\n\t        // Do order-preserving replacements:\n\t        // 0 -> 1, 1\n\t        // 1 -> 1, 2\n\t        // 2 -> 2, 2\n\t        return key\n\t          .replace(/\\u0002/g, '\\u0002\\u0002')\n\t          .replace(/\\u0001/g, '\\u0001\\u0002')\n\t          .replace(/\\u0000/g, '\\u0001\\u0001');\n\t      case 'object':\n\t        var isArray = Array.isArray(key);\n\t        var arr = isArray ? key : Object.keys(key);\n\t        var i = -1;\n\t        var len = arr.length;\n\t        var result = '';\n\t        if (isArray) {\n\t          while (++i < len) {\n\t            result += exports.toIndexableString(arr[i]);\n\t          }\n\t        } else {\n\t          while (++i < len) {\n\t            var objKey = arr[i];\n\t            result += exports.toIndexableString(objKey) +\n\t                exports.toIndexableString(key[objKey]);\n\t          }\n\t        }\n\t        return result;\n\t    }\n\t  }\n\t  return '';\n\t}\n\t\n\t// convert the given key to a string that would be appropriate\n\t// for lexical sorting, e.g. within a database, where the\n\t// sorting is the same given by the collate() function.\n\texports.toIndexableString = function (key) {\n\t  var zero = '\\u0000';\n\t  key = exports.normalizeKey(key);\n\t  return collationIndex(key) + SEP + indexify(key) + zero;\n\t};\n\t\n\tfunction parseNumber(str, i) {\n\t  var originalIdx = i;\n\t  var num;\n\t  var zero = str[i] === '1';\n\t  if (zero) {\n\t    num = 0;\n\t    i++;\n\t  } else {\n\t    var neg = str[i] === '0';\n\t    i++;\n\t    var numAsString = '';\n\t    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n\t    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n\t    if (neg) {\n\t      magnitude = -magnitude;\n\t    }\n\t    i += MAGNITUDE_DIGITS;\n\t    while (true) {\n\t      var ch = str[i];\n\t      if (ch === '\\u0000') {\n\t        break;\n\t      } else {\n\t        numAsString += ch;\n\t      }\n\t      i++;\n\t    }\n\t    numAsString = numAsString.split('.');\n\t    if (numAsString.length === 1) {\n\t      num = parseInt(numAsString, 10);\n\t    } else {\n\t      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n\t    }\n\t    if (neg) {\n\t      num = num - 10;\n\t    }\n\t    if (magnitude !== 0) {\n\t      // parseFloat is more reliable than pow due to rounding errors\n\t      // e.g. Number.MAX_VALUE would return Infinity if we did\n\t      // num * Math.pow(10, magnitude);\n\t      num = parseFloat(num + 'e' + magnitude);\n\t    }\n\t  }\n\t  return {num: num, length : i - originalIdx};\n\t}\n\t\n\t// move up the stack while parsing\n\t// this function moved outside of parseIndexableString for performance\n\tfunction pop(stack, metaStack) {\n\t  var obj = stack.pop();\n\t\n\t  if (metaStack.length) {\n\t    var lastMetaElement = metaStack[metaStack.length - 1];\n\t    if (obj === lastMetaElement.element) {\n\t      // popping a meta-element, e.g. an object whose value is another object\n\t      metaStack.pop();\n\t      lastMetaElement = metaStack[metaStack.length - 1];\n\t    }\n\t    var element = lastMetaElement.element;\n\t    var lastElementIndex = lastMetaElement.index;\n\t    if (Array.isArray(element)) {\n\t      element.push(obj);\n\t    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t      var key = stack.pop();\n\t      element[key] = obj;\n\t    } else {\n\t      stack.push(obj); // obj with key only\n\t    }\n\t  }\n\t}\n\t\n\texports.parseIndexableString = function (str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t\n\t  while (true) {\n\t    var collationIndex = str[i++];\n\t    if (collationIndex === '\\u0000') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case '1':\n\t        stack.push(null);\n\t        break;\n\t      case '2':\n\t        stack.push(str[i] === '1');\n\t        i++;\n\t        break;\n\t      case '3':\n\t        var parsedNum = parseNumber(str, i);\n\t        stack.push(parsedNum.num);\n\t        i += parsedNum.length;\n\t        break;\n\t      case '4':\n\t        var parsedStr = '';\n\t        while (true) {\n\t          var ch = str[i];\n\t          if (ch === '\\u0000') {\n\t            break;\n\t          }\n\t          parsedStr += ch;\n\t          i++;\n\t        }\n\t        // perform the reverse of the order-preserving replacement\n\t        // algorithm (see above)\n\t        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n\t          .replace(/\\u0001\\u0002/g, '\\u0001')\n\t          .replace(/\\u0002\\u0002/g, '\\u0002');\n\t        stack.push(parsedStr);\n\t        break;\n\t      case '5':\n\t        var arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '6':\n\t        var objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      default:\n\t        throw new Error(\n\t          'bad collationIndex or unexpectedly reached end of input: ' + collationIndex);\n\t    }\n\t  }\n\t};\n\t\n\tfunction arrayCollate(a, b) {\n\t  var len = Math.min(a.length, b.length);\n\t  for (var i = 0; i < len; i++) {\n\t    var sort = exports.collate(a[i], b[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t  }\n\t  return (a.length === b.length) ? 0 :\n\t    (a.length > b.length) ? 1 : -1;\n\t}\n\tfunction stringCollate(a, b) {\n\t  // See: https://github.com/daleharvey/pouchdb/issues/40\n\t  // This is incompatible with the CouchDB implementation, but its the\n\t  // best we can do for now\n\t  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n\t}\n\tfunction objectCollate(a, b) {\n\t  var ak = Object.keys(a), bk = Object.keys(b);\n\t  var len = Math.min(ak.length, bk.length);\n\t  for (var i = 0; i < len; i++) {\n\t    // First sort the keys\n\t    var sort = exports.collate(ak[i], bk[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t    // if the keys are equal sort the values\n\t    sort = exports.collate(a[ak[i]], b[bk[i]]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t\n\t  }\n\t  return (ak.length === bk.length) ? 0 :\n\t    (ak.length > bk.length) ? 1 : -1;\n\t}\n\t// The collation is defined by erlangs ordered terms\n\t// the atoms null, true, false come first, then numbers, strings,\n\t// arrays, then objects\n\t// null/undefined/NaN/Infinity/-Infinity are all considered null\n\tfunction collationIndex(x) {\n\t  var id = ['boolean', 'number', 'string', 'object'];\n\t  var idx = id.indexOf(typeof x);\n\t  //false if -1 otherwise true, but fast!!!!1\n\t  if (~idx) {\n\t    if (x === null) {\n\t      return 1;\n\t    }\n\t    if (Array.isArray(x)) {\n\t      return 5;\n\t    }\n\t    return idx < 3 ? (idx + 2) : (idx + 3);\n\t  }\n\t  if (Array.isArray(x)) {\n\t    return 5;\n\t  }\n\t}\n\t\n\t// conversion:\n\t// x yyy zz...zz\n\t// x = 0 for negative, 1 for 0, 2 for positive\n\t// y = exponent (for negative numbers negated) moved so that it's >= 0\n\t// z = mantisse\n\tfunction numToIndexableString(num) {\n\t\n\t  if (num === 0) {\n\t    return '1';\n\t  }\n\t\n\t  // convert number to exponential format for easier and\n\t  // more succinct string sorting\n\t  var expFormat = num.toExponential().split(/e\\+?/);\n\t  var magnitude = parseInt(expFormat[1], 10);\n\t\n\t  var neg = num < 0;\n\t\n\t  var result = neg ? '0' : '2';\n\t\n\t  // first sort by magnitude\n\t  // it's easier if all magnitudes are positive\n\t  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n\t  var magString = utils.padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\t\n\t  result += SEP + magString;\n\t\n\t  // then sort by the factor\n\t  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n\t  if (neg) { // for negative reverse ordering\n\t    factor = 10 - factor;\n\t  }\n\t\n\t  var factorStr = factor.toFixed(20);\n\t\n\t  // strip zeros from the end\n\t  factorStr = factorStr.replace(/\\.?0+$/, '');\n\t\n\t  result += SEP + factorStr;\n\t\n\t  return result;\n\t}\n\n\n/***/ },\n/* 8 */\n/*!******************************!*\\\n  !*** ./~/pikaday/pikaday.js ***!\n  \\******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n\t * Pikaday\n\t *\n\t * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday\n\t */\n\t\n\t(function (root, factory)\n\t{\n\t    'use strict';\n\t\n\t    // if (typeof exports === 'object') {\n\t    //     // CommonJS module\n\t    //     // Load moment.js as an optional dependency\n\t    //     try { moment = require('moment'); } catch (e) {}\n\t    //     module.exports = factory(moment);\n\t    // } else if (typeof define === 'function' && define.amd) {\n\t    //     // AMD. Register as an anonymous module.\n\t    //     define(function (req)\n\t    //     {\n\t    //         // Load moment.js as an optional dependency\n\t    //         var id = 'moment';\n\t    //         try { moment = req(id); } catch (e) {}\n\t    //         return factory(moment);\n\t    //     });\n\t    // } else {\n\t    //     root.Pikaday = factory(root.moment);\n\t    // }\n\t\n\t    if (true) {\n\t        // AMD. Register as an anonymous module.\n\t        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    } else if ( typeof exports === 'object' ) {\n\t        // Node/CommonJS\n\t        module.exports = factory();\n\t    } else {\n\t        // Browser globals\n\t        root.Pikaday = factory();\n\t    }\n\t\n\t}(this, function ()\n\t{\n\t    'use strict';\n\t\n\t    /**\n\t     * feature detection and helper functions\n\t     */\n\t    var hasMoment = typeof moment === 'function',\n\t\n\t    hasEventListeners = !!window.addEventListener,\n\t\n\t    document = window.document,\n\t\n\t    sto = window.setTimeout,\n\t\n\t    addEvent = function(el, e, callback, capture)\n\t    {\n\t        if (hasEventListeners) {\n\t            el.addEventListener(e, callback, !!capture);\n\t        } else {\n\t            el.attachEvent('on' + e, callback);\n\t        }\n\t    },\n\t\n\t    removeEvent = function(el, e, callback, capture)\n\t    {\n\t        if (hasEventListeners) {\n\t            el.removeEventListener(e, callback, !!capture);\n\t        } else {\n\t            el.detachEvent('on' + e, callback);\n\t        }\n\t    },\n\t\n\t    fireEvent = function(el, eventName, data)\n\t    {\n\t        var ev;\n\t\n\t        if (document.createEvent) {\n\t            ev = document.createEvent('HTMLEvents');\n\t            ev.initEvent(eventName, true, false);\n\t            ev = extend(ev, data);\n\t            el.dispatchEvent(ev);\n\t        } else if (document.createEventObject) {\n\t            ev = document.createEventObject();\n\t            ev = extend(ev, data);\n\t            el.fireEvent('on' + eventName, ev);\n\t        }\n\t    },\n\t\n\t    trim = function(str)\n\t    {\n\t        return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g,'');\n\t    },\n\t\n\t    hasClass = function(el, cn)\n\t    {\n\t        return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;\n\t    },\n\t\n\t    addClass = function(el, cn)\n\t    {\n\t        if (!hasClass(el, cn)) {\n\t            el.className = (el.className === '') ? cn : el.className + ' ' + cn;\n\t        }\n\t    },\n\t\n\t    removeClass = function(el, cn)\n\t    {\n\t        el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));\n\t    },\n\t\n\t    isArray = function(obj)\n\t    {\n\t        return (/Array/).test(Object.prototype.toString.call(obj));\n\t    },\n\t\n\t    isDate = function(obj)\n\t    {\n\t        return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());\n\t    },\n\t\n\t    isWeekend = function(date)\n\t    {\n\t        var day = date.getDay();\n\t        return day === 0 || day === 6;\n\t    },\n\t\n\t    isLeapYear = function(year)\n\t    {\n\t        // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951\n\t        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n\t    },\n\t\n\t    getDaysInMonth = function(year, month)\n\t    {\n\t        return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n\t    },\n\t\n\t    setToStartOfDay = function(date)\n\t    {\n\t        if (isDate(date)) date.setHours(0,0,0,0);\n\t    },\n\t\n\t    compareDates = function(a,b)\n\t    {\n\t        // weak date comparison (use setToStartOfDay(date) to ensure correct result)\n\t        return a.getTime() === b.getTime();\n\t    },\n\t\n\t    extend = function(to, from, overwrite)\n\t    {\n\t        var prop, hasProp;\n\t        for (prop in from) {\n\t            hasProp = to[prop] !== undefined;\n\t            if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {\n\t                if (isDate(from[prop])) {\n\t                    if (overwrite) {\n\t                        to[prop] = new Date(from[prop].getTime());\n\t                    }\n\t                }\n\t                else if (isArray(from[prop])) {\n\t                    if (overwrite) {\n\t                        to[prop] = from[prop].slice(0);\n\t                    }\n\t                } else {\n\t                    to[prop] = extend({}, from[prop], overwrite);\n\t                }\n\t            } else if (overwrite || !hasProp) {\n\t                to[prop] = from[prop];\n\t            }\n\t        }\n\t        return to;\n\t    },\n\t\n\t    adjustCalendar = function(calendar) {\n\t        if (calendar.month < 0) {\n\t            calendar.year -= Math.ceil(Math.abs(calendar.month)/12);\n\t            calendar.month += 12;\n\t        }\n\t        if (calendar.month > 11) {\n\t            calendar.year += Math.floor(Math.abs(calendar.month)/12);\n\t            calendar.month -= 12;\n\t        }\n\t        return calendar;\n\t    },\n\t\n\t    /**\n\t     * defaults and localisation\n\t     */\n\t    defaults = {\n\t\n\t        // bind the picker to a form field\n\t        field: null,\n\t\n\t        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)\n\t        bound: undefined,\n\t\n\t        // position of the datepicker, relative to the field (default to bottom & left)\n\t        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)\n\t        position: 'bottom left',\n\t\n\t        // automatically fit in the viewport even if it means repositioning from the position option\n\t        reposition: true,\n\t\n\t        // the default output format for `.toString()` and `field` value\n\t        format: 'YYYY-MM-DD',\n\t\n\t        // the initial date to view when first opened\n\t        defaultDate: null,\n\t\n\t        // make the `defaultDate` the initial selected value\n\t        setDefaultDate: false,\n\t\n\t        // first day of week (0: Sunday, 1: Monday etc)\n\t        firstDay: 0,\n\t\n\t        // the minimum/earliest date that can be selected\n\t        minDate: null,\n\t        // the maximum/latest date that can be selected\n\t        maxDate: null,\n\t\n\t        // number of years either side, or array of upper/lower range\n\t        yearRange: 10,\n\t\n\t        // show week numbers at head of row\n\t        showWeekNumber: false,\n\t\n\t        // used internally (don't config outside)\n\t        minYear: 0,\n\t        maxYear: 9999,\n\t        minMonth: undefined,\n\t        maxMonth: undefined,\n\t\n\t        startRange: null,\n\t        endRange: null,\n\t\n\t        isRTL: false,\n\t\n\t        // Additional text to append to the year in the calendar title\n\t        yearSuffix: '',\n\t\n\t        // Render the month after year in the calendar title\n\t        showMonthAfterYear: false,\n\t\n\t        // how many months are visible\n\t        numberOfMonths: 1,\n\t\n\t        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)\n\t        // only used for the first display or when a selected date is not visible\n\t        mainCalendar: 'left',\n\t\n\t        // Specify a DOM element to render the calendar in\n\t        container: undefined,\n\t\n\t        // internationalization\n\t        i18n: {\n\t            previousMonth : 'Previous Month',\n\t            nextMonth     : 'Next Month',\n\t            months        : ['January','February','March','April','May','June','July','August','September','October','November','December'],\n\t            weekdays      : ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],\n\t            weekdaysShort : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']\n\t        },\n\t\n\t        // Theme Classname\n\t        theme: null,\n\t\n\t        // callback function\n\t        onSelect: null,\n\t        onOpen: null,\n\t        onClose: null,\n\t        onDraw: null\n\t    },\n\t\n\t\n\t    /**\n\t     * templating functions to abstract HTML rendering\n\t     */\n\t    renderDayName = function(opts, day, abbr)\n\t    {\n\t        day += opts.firstDay;\n\t        while (day >= 7) {\n\t            day -= 7;\n\t        }\n\t        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];\n\t    },\n\t\n\t    renderDay = function(opts)\n\t    {\n\t        if (opts.isEmpty) {\n\t            return '<td class=\"is-empty\"></td>';\n\t        }\n\t        var arr = [];\n\t        if (opts.isDisabled) {\n\t            arr.push('is-disabled');\n\t        }\n\t        if (opts.isToday) {\n\t            arr.push('is-today');\n\t        }\n\t        if (opts.isSelected) {\n\t            arr.push('is-selected');\n\t        }\n\t        if (opts.isInRange) {\n\t            arr.push('is-inrange');\n\t        }\n\t        if (opts.isStartRange) {\n\t            arr.push('is-startrange');\n\t        }\n\t        if (opts.isEndRange) {\n\t            arr.push('is-endrange');\n\t        }\n\t        return '<td data-day=\"' + opts.day + '\" class=\"' + arr.join(' ') + '\">' +\n\t                 '<button class=\"pika-button pika-day\" type=\"button\" ' +\n\t                    'data-pika-year=\"' + opts.year + '\" data-pika-month=\"' + opts.month + '\" data-pika-day=\"' + opts.day + '\">' +\n\t                        opts.day +\n\t                 '</button>' +\n\t               '</td>';\n\t    },\n\t\n\t    renderWeek = function (d, m, y) {\n\t        // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.\n\t        var onejan = new Date(y, 0, 1),\n\t            weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay()+1)/7);\n\t        return '<td class=\"pika-week\">' + weekNum + '</td>';\n\t    },\n\t\n\t    renderRow = function(days, isRTL)\n\t    {\n\t        return '<tr>' + (isRTL ? days.reverse() : days).join('') + '</tr>';\n\t    },\n\t\n\t    renderBody = function(rows)\n\t    {\n\t        return '<tbody>' + rows.join('') + '</tbody>';\n\t    },\n\t\n\t    renderHead = function(opts)\n\t    {\n\t        var i, arr = [];\n\t        if (opts.showWeekNumber) {\n\t            arr.push('<th></th>');\n\t        }\n\t        for (i = 0; i < 7; i++) {\n\t            arr.push('<th scope=\"col\"><abbr title=\"' + renderDayName(opts, i) + '\">' + renderDayName(opts, i, true) + '</abbr></th>');\n\t        }\n\t        return '<thead>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</thead>';\n\t    },\n\t\n\t    renderTitle = function(instance, c, year, month, refYear)\n\t    {\n\t        var i, j, arr,\n\t            opts = instance._o,\n\t            isMinYear = year === opts.minYear,\n\t            isMaxYear = year === opts.maxYear,\n\t            html = '<div class=\"pika-title\">',\n\t            monthHtml,\n\t            yearHtml,\n\t            prev = true,\n\t            next = true;\n\t\n\t        for (arr = [], i = 0; i < 12; i++) {\n\t            arr.push('<option value=\"' + (year === refYear ? i - c : 12 + i - c) + '\"' +\n\t                (i === month ? ' selected': '') +\n\t                ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled' : '') + '>' +\n\t                opts.i18n.months[i] + '</option>');\n\t        }\n\t        monthHtml = '<div class=\"pika-label\">' + opts.i18n.months[month] + '<select class=\"pika-select pika-select-month\" tabindex=\"-1\">' + arr.join('') + '</select></div>';\n\t\n\t        if (isArray(opts.yearRange)) {\n\t            i = opts.yearRange[0];\n\t            j = opts.yearRange[1] + 1;\n\t        } else {\n\t            i = year - opts.yearRange;\n\t            j = 1 + year + opts.yearRange;\n\t        }\n\t\n\t        for (arr = []; i < j && i <= opts.maxYear; i++) {\n\t            if (i >= opts.minYear) {\n\t                arr.push('<option value=\"' + i + '\"' + (i === year ? ' selected': '') + '>' + (i) + '</option>');\n\t            }\n\t        }\n\t        yearHtml = '<div class=\"pika-label\">' + year + opts.yearSuffix + '<select class=\"pika-select pika-select-year\" tabindex=\"-1\">' + arr.join('') + '</select></div>';\n\t\n\t        if (opts.showMonthAfterYear) {\n\t            html += yearHtml + monthHtml;\n\t        } else {\n\t            html += monthHtml + yearHtml;\n\t        }\n\t\n\t        if (isMinYear && (month === 0 || opts.minMonth >= month)) {\n\t            prev = false;\n\t        }\n\t\n\t        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {\n\t            next = false;\n\t        }\n\t\n\t        if (c === 0) {\n\t            html += '<button class=\"pika-prev' + (prev ? '' : ' is-disabled') + '\" type=\"button\">' + opts.i18n.previousMonth + '</button>';\n\t        }\n\t        if (c === (instance._o.numberOfMonths - 1) ) {\n\t            html += '<button class=\"pika-next' + (next ? '' : ' is-disabled') + '\" type=\"button\">' + opts.i18n.nextMonth + '</button>';\n\t        }\n\t\n\t        return html += '</div>';\n\t    },\n\t\n\t    renderTable = function(opts, data)\n\t    {\n\t        return '<table cellpadding=\"0\" cellspacing=\"0\" class=\"pika-table\">' + renderHead(opts) + renderBody(data) + '</table>';\n\t    },\n\t\n\t\n\t    /**\n\t     * Pikaday constructor\n\t     */\n\t    Pikaday = function(options)\n\t    {\n\t        var self = this,\n\t            opts = self.config(options);\n\t\n\t        self._onMouseDown = function(e)\n\t        {\n\t            if (!self._v) {\n\t                return;\n\t            }\n\t            e = e || window.event;\n\t            var target = e.target || e.srcElement;\n\t            if (!target) {\n\t                return;\n\t            }\n\t\n\t            if (!hasClass(target, 'is-disabled')) {\n\t                if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty')) {\n\t                    self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));\n\t                    if (opts.bound) {\n\t                        sto(function() {\n\t                            self.hide();\n\t                            if (opts.field) {\n\t                                opts.field.blur();\n\t                            }\n\t                        }, 100);\n\t                    }\n\t                }\n\t                else if (hasClass(target, 'pika-prev')) {\n\t                    self.prevMonth();\n\t                }\n\t                else if (hasClass(target, 'pika-next')) {\n\t                    self.nextMonth();\n\t                }\n\t            }\n\t            if (!hasClass(target, 'pika-select')) {\n\t                // if this is touch event prevent mouse events emulation\n\t                if (e.preventDefault) {\n\t                    e.preventDefault();\n\t                } else {\n\t                    e.returnValue = false;\n\t                    return false;\n\t                }\n\t            } else {\n\t                self._c = true;\n\t            }\n\t        };\n\t\n\t        self._onChange = function(e)\n\t        {\n\t            e = e || window.event;\n\t            var target = e.target || e.srcElement;\n\t            if (!target) {\n\t                return;\n\t            }\n\t            if (hasClass(target, 'pika-select-month')) {\n\t                self.gotoMonth(target.value);\n\t            }\n\t            else if (hasClass(target, 'pika-select-year')) {\n\t                self.gotoYear(target.value);\n\t            }\n\t        };\n\t\n\t        self._onInputChange = function(e)\n\t        {\n\t            var date;\n\t\n\t            if (e.firedBy === self) {\n\t                return;\n\t            }\n\t            if (hasMoment) {\n\t                date = moment(opts.field.value, opts.format);\n\t                date = (date && date.isValid()) ? date.toDate() : null;\n\t            }\n\t            else {\n\t                date = new Date(Date.parse(opts.field.value));\n\t            }\n\t            if (isDate(date)) {\n\t              self.setDate(date);\n\t            }\n\t            if (!self._v) {\n\t                self.show();\n\t            }\n\t        };\n\t\n\t        self._onInputFocus = function()\n\t        {\n\t            self.show();\n\t        };\n\t\n\t        self._onInputClick = function()\n\t        {\n\t            self.show();\n\t        };\n\t\n\t        self._onInputBlur = function()\n\t        {\n\t            // IE allows pika div to gain focus; catch blur the input field\n\t            var pEl = document.activeElement;\n\t            do {\n\t                if (hasClass(pEl, 'pika-single')) {\n\t                    return;\n\t                }\n\t            }\n\t            while ((pEl = pEl.parentNode));\n\t\n\t            if (!self._c) {\n\t                self._b = sto(function() {\n\t                    self.hide();\n\t                }, 50);\n\t            }\n\t            self._c = false;\n\t        };\n\t\n\t        self._onClick = function(e)\n\t        {\n\t            e = e || window.event;\n\t            var target = e.target || e.srcElement,\n\t                pEl = target;\n\t            if (!target) {\n\t                return;\n\t            }\n\t            if (!hasEventListeners && hasClass(target, 'pika-select')) {\n\t                if (!target.onchange) {\n\t                    target.setAttribute('onchange', 'return;');\n\t                    addEvent(target, 'change', self._onChange);\n\t                }\n\t            }\n\t            do {\n\t                if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {\n\t                    return;\n\t                }\n\t            }\n\t            while ((pEl = pEl.parentNode));\n\t            if (self._v && target !== opts.trigger && pEl !== opts.trigger) {\n\t                self.hide();\n\t            }\n\t        };\n\t\n\t        self.el = document.createElement('div');\n\t        self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');\n\t\n\t        addEvent(self.el, 'mousedown', self._onMouseDown, true);\n\t        addEvent(self.el, 'touchend', self._onMouseDown, true);\n\t        addEvent(self.el, 'change', self._onChange);\n\t\n\t        if (opts.field) {\n\t            if (opts.container) {\n\t                opts.container.appendChild(self.el);\n\t            } else if (opts.bound) {\n\t                document.body.appendChild(self.el);\n\t            } else {\n\t                opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);\n\t            }\n\t            addEvent(opts.field, 'change', self._onInputChange);\n\t\n\t            if (!opts.defaultDate) {\n\t                if (hasMoment && opts.field.value) {\n\t                    opts.defaultDate = moment(opts.field.value, opts.format).toDate();\n\t                } else {\n\t                    opts.defaultDate = new Date(Date.parse(opts.field.value));\n\t                }\n\t                opts.setDefaultDate = true;\n\t            }\n\t        }\n\t\n\t        var defDate = opts.defaultDate;\n\t\n\t        if (isDate(defDate)) {\n\t            if (opts.setDefaultDate) {\n\t                self.setDate(defDate, true);\n\t            } else {\n\t                self.gotoDate(defDate);\n\t            }\n\t        } else {\n\t            self.gotoDate(new Date());\n\t        }\n\t\n\t        if (opts.bound) {\n\t            this.hide();\n\t            self.el.className += ' is-bound';\n\t            addEvent(opts.trigger, 'click', self._onInputClick);\n\t            addEvent(opts.trigger, 'focus', self._onInputFocus);\n\t            addEvent(opts.trigger, 'blur', self._onInputBlur);\n\t        } else {\n\t            this.show();\n\t        }\n\t    };\n\t\n\t\n\t    /**\n\t     * public Pikaday API\n\t     */\n\t    Pikaday.prototype = {\n\t\n\t\n\t        /**\n\t         * configure functionality\n\t         */\n\t        config: function(options)\n\t        {\n\t            if (!this._o) {\n\t                this._o = extend({}, defaults, true);\n\t            }\n\t\n\t            var opts = extend(this._o, options, true);\n\t\n\t            opts.isRTL = !!opts.isRTL;\n\t\n\t            opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;\n\t\n\t            opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;\n\t\n\t            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);\n\t\n\t            opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;\n\t\n\t            opts.disableWeekends = !!opts.disableWeekends;\n\t\n\t            opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;\n\t\n\t            var nom = parseInt(opts.numberOfMonths, 10) || 1;\n\t            opts.numberOfMonths = nom > 4 ? 4 : nom;\n\t\n\t            if (!isDate(opts.minDate)) {\n\t                opts.minDate = false;\n\t            }\n\t            if (!isDate(opts.maxDate)) {\n\t                opts.maxDate = false;\n\t            }\n\t            if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {\n\t                opts.maxDate = opts.minDate = false;\n\t            }\n\t            if (opts.minDate) {\n\t                this.setMinDate(opts.minDate);\n\t            }\n\t            if (opts.maxDate) {\n\t                this.setMaxDate(opts.maxDate);\n\t            }\n\t\n\t            if (isArray(opts.yearRange)) {\n\t                var fallback = new Date().getFullYear() - 10;\n\t                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;\n\t                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;\n\t            } else {\n\t                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;\n\t                if (opts.yearRange > 100) {\n\t                    opts.yearRange = 100;\n\t                }\n\t            }\n\t\n\t            return opts;\n\t        },\n\t\n\t        /**\n\t         * return a formatted string of the current selection (using Moment.js if available)\n\t         */\n\t        toString: function(format)\n\t        {\n\t            return !isDate(this._d) ? '' : hasMoment ? moment(this._d).format(format || this._o.format) : this._d.toDateString();\n\t        },\n\t\n\t        /**\n\t         * return a Moment.js object of the current selection (if available)\n\t         */\n\t        getMoment: function()\n\t        {\n\t            return hasMoment ? moment(this._d) : null;\n\t        },\n\t\n\t        /**\n\t         * set the current selection from a Moment.js object (if available)\n\t         */\n\t        setMoment: function(date, preventOnSelect)\n\t        {\n\t            if (hasMoment && moment.isMoment(date)) {\n\t                this.setDate(date.toDate(), preventOnSelect);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * return a Date object of the current selection\n\t         */\n\t        getDate: function()\n\t        {\n\t            return isDate(this._d) ? new Date(this._d.getTime()) : null;\n\t        },\n\t\n\t        /**\n\t         * set the current selection\n\t         */\n\t        setDate: function(date, preventOnSelect)\n\t        {\n\t            if (!date) {\n\t                this._d = null;\n\t\n\t                if (this._o.field) {\n\t                    this._o.field.value = '';\n\t                    fireEvent(this._o.field, 'change', { firedBy: this });\n\t                }\n\t\n\t                return this.draw();\n\t            }\n\t            if (typeof date === 'string') {\n\t                date = new Date(Date.parse(date));\n\t            }\n\t            if (!isDate(date)) {\n\t                return;\n\t            }\n\t\n\t            var min = this._o.minDate,\n\t                max = this._o.maxDate;\n\t\n\t            if (isDate(min) && date < min) {\n\t                date = min;\n\t            } else if (isDate(max) && date > max) {\n\t                date = max;\n\t            }\n\t\n\t            this._d = new Date(date.getTime());\n\t            setToStartOfDay(this._d);\n\t            this.gotoDate(this._d);\n\t\n\t            if (this._o.field) {\n\t                this._o.field.value = this.toString();\n\t                fireEvent(this._o.field, 'change', { firedBy: this });\n\t            }\n\t            if (!preventOnSelect && typeof this._o.onSelect === 'function') {\n\t                this._o.onSelect.call(this, this.getDate());\n\t            }\n\t        },\n\t\n\t        /**\n\t         * change view to a specific date\n\t         */\n\t        gotoDate: function(date)\n\t        {\n\t            var newCalendar = true;\n\t\n\t            if (!isDate(date)) {\n\t                return;\n\t            }\n\t\n\t            if (this.calendars) {\n\t                var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),\n\t                    lastVisibleDate = new Date(this.calendars[this.calendars.length-1].year, this.calendars[this.calendars.length-1].month, 1),\n\t                    visibleDate = date.getTime();\n\t                // get the end of the month\n\t                lastVisibleDate.setMonth(lastVisibleDate.getMonth()+1);\n\t                lastVisibleDate.setDate(lastVisibleDate.getDate()-1);\n\t                newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);\n\t            }\n\t\n\t            if (newCalendar) {\n\t                this.calendars = [{\n\t                    month: date.getMonth(),\n\t                    year: date.getFullYear()\n\t                }];\n\t                if (this._o.mainCalendar === 'right') {\n\t                    this.calendars[0].month += 1 - this._o.numberOfMonths;\n\t                }\n\t            }\n\t\n\t            this.adjustCalendars();\n\t        },\n\t\n\t        adjustCalendars: function() {\n\t            this.calendars[0] = adjustCalendar(this.calendars[0]);\n\t            for (var c = 1; c < this._o.numberOfMonths; c++) {\n\t                this.calendars[c] = adjustCalendar({\n\t                    month: this.calendars[0].month + c,\n\t                    year: this.calendars[0].year\n\t                });\n\t            }\n\t            this.draw();\n\t        },\n\t\n\t        gotoToday: function()\n\t        {\n\t            this.gotoDate(new Date());\n\t        },\n\t\n\t        /**\n\t         * change view to a specific month (zero-index, e.g. 0: January)\n\t         */\n\t        gotoMonth: function(month)\n\t        {\n\t            if (!isNaN(month)) {\n\t                this.calendars[0].month = parseInt(month, 10);\n\t                this.adjustCalendars();\n\t            }\n\t        },\n\t\n\t        nextMonth: function()\n\t        {\n\t            this.calendars[0].month++;\n\t            this.adjustCalendars();\n\t        },\n\t\n\t        prevMonth: function()\n\t        {\n\t            this.calendars[0].month--;\n\t            this.adjustCalendars();\n\t        },\n\t\n\t        /**\n\t         * change view to a specific full year (e.g. \"2012\")\n\t         */\n\t        gotoYear: function(year)\n\t        {\n\t            if (!isNaN(year)) {\n\t                this.calendars[0].year = parseInt(year, 10);\n\t                this.adjustCalendars();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * change the minDate\n\t         */\n\t        setMinDate: function(value)\n\t        {\n\t            setToStartOfDay(value);\n\t            this._o.minDate = value;\n\t            this._o.minYear  = value.getFullYear();\n\t            this._o.minMonth = value.getMonth();\n\t            this.draw();\n\t        },\n\t\n\t        /**\n\t         * change the maxDate\n\t         */\n\t        setMaxDate: function(value)\n\t        {\n\t            setToStartOfDay(value);\n\t            this._o.maxDate = value;\n\t            this._o.maxYear = value.getFullYear();\n\t            this._o.maxMonth = value.getMonth();\n\t            this.draw();\n\t        },\n\t\n\t        setStartRange: function(value)\n\t        {\n\t            this._o.startRange = value;\n\t        },\n\t\n\t        setEndRange: function(value)\n\t        {\n\t            this._o.endRange = value;\n\t        },\n\t\n\t        /**\n\t         * refresh the HTML\n\t         */\n\t        draw: function(force)\n\t        {\n\t            if (!this._v && !force) {\n\t                return;\n\t            }\n\t            var opts = this._o,\n\t                minYear = opts.minYear,\n\t                maxYear = opts.maxYear,\n\t                minMonth = opts.minMonth,\n\t                maxMonth = opts.maxMonth,\n\t                html = '';\n\t\n\t            if (this._y <= minYear) {\n\t                this._y = minYear;\n\t                if (!isNaN(minMonth) && this._m < minMonth) {\n\t                    this._m = minMonth;\n\t                }\n\t            }\n\t            if (this._y >= maxYear) {\n\t                this._y = maxYear;\n\t                if (!isNaN(maxMonth) && this._m > maxMonth) {\n\t                    this._m = maxMonth;\n\t                }\n\t            }\n\t\n\t            for (var c = 0; c < opts.numberOfMonths; c++) {\n\t                html += '<div class=\"pika-lendar\">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year) + this.render(this.calendars[c].year, this.calendars[c].month) + '</div>';\n\t            }\n\t\n\t            this.el.innerHTML = html;\n\t\n\t            if (opts.bound) {\n\t                if(opts.field.type !== 'hidden') {\n\t                    sto(function() {\n\t                        opts.trigger.focus();\n\t                    }, 1);\n\t                }\n\t            }\n\t\n\t            if (typeof this._o.onDraw === 'function') {\n\t                var self = this;\n\t                sto(function() {\n\t                    self._o.onDraw.call(self);\n\t                }, 0);\n\t            }\n\t        },\n\t\n\t        adjustPosition: function()\n\t        {\n\t            var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect;\n\t\n\t            if (this._o.container) return;\n\t\n\t            this.el.style.position = 'absolute';\n\t\n\t            field = this._o.trigger;\n\t            pEl = field;\n\t            width = this.el.offsetWidth;\n\t            height = this.el.offsetHeight;\n\t            viewportWidth = window.innerWidth || document.documentElement.clientWidth;\n\t            viewportHeight = window.innerHeight || document.documentElement.clientHeight;\n\t            scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;\n\t\n\t            if (typeof field.getBoundingClientRect === 'function') {\n\t                clientRect = field.getBoundingClientRect();\n\t                left = clientRect.left + window.pageXOffset;\n\t                top = clientRect.bottom + window.pageYOffset;\n\t            } else {\n\t                left = pEl.offsetLeft;\n\t                top  = pEl.offsetTop + pEl.offsetHeight;\n\t                while((pEl = pEl.offsetParent)) {\n\t                    left += pEl.offsetLeft;\n\t                    top  += pEl.offsetTop;\n\t                }\n\t            }\n\t\n\t            // default position is bottom & left\n\t            if ((this._o.reposition && left + width > viewportWidth) ||\n\t                (\n\t                    this._o.position.indexOf('right') > -1 &&\n\t                    left - width + field.offsetWidth > 0\n\t                )\n\t            ) {\n\t                left = left - width + field.offsetWidth;\n\t            }\n\t            if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||\n\t                (\n\t                    this._o.position.indexOf('top') > -1 &&\n\t                    top - height - field.offsetHeight > 0\n\t                )\n\t            ) {\n\t                top = top - height - field.offsetHeight;\n\t            }\n\t\n\t            this.el.style.left = left + 'px';\n\t            this.el.style.top = top + 'px';\n\t        },\n\t\n\t        /**\n\t         * render HTML for a particular month\n\t         */\n\t        render: function(year, month)\n\t        {\n\t            var opts   = this._o,\n\t                now    = new Date(),\n\t                days   = getDaysInMonth(year, month),\n\t                before = new Date(year, month, 1).getDay(),\n\t                data   = [],\n\t                row    = [];\n\t            setToStartOfDay(now);\n\t            if (opts.firstDay > 0) {\n\t                before -= opts.firstDay;\n\t                if (before < 0) {\n\t                    before += 7;\n\t                }\n\t            }\n\t            var cells = days + before,\n\t                after = cells;\n\t            while(after > 7) {\n\t                after -= 7;\n\t            }\n\t            cells += 7 - after;\n\t            for (var i = 0, r = 0; i < cells; i++)\n\t            {\n\t                var day = new Date(year, month, 1 + (i - before)),\n\t                    isSelected = isDate(this._d) ? compareDates(day, this._d) : false,\n\t                    isToday = compareDates(day, now),\n\t                    isEmpty = i < before || i >= (days + before),\n\t                    isStartRange = opts.startRange && compareDates(opts.startRange, day),\n\t                    isEndRange = opts.endRange && compareDates(opts.endRange, day),\n\t                    isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,\n\t                    isDisabled = (opts.minDate && day < opts.minDate) ||\n\t                                 (opts.maxDate && day > opts.maxDate) ||\n\t                                 (opts.disableWeekends && isWeekend(day)) ||\n\t                                 (opts.disableDayFn && opts.disableDayFn(day)),\n\t                    dayConfig = {\n\t                        day: 1 + (i - before),\n\t                        month: month,\n\t                        year: year,\n\t                        isSelected: isSelected,\n\t                        isToday: isToday,\n\t                        isDisabled: isDisabled,\n\t                        isEmpty: isEmpty,\n\t                        isStartRange: isStartRange,\n\t                        isEndRange: isEndRange,\n\t                        isInRange: isInRange\n\t                    };\n\t\n\t                row.push(renderDay(dayConfig));\n\t\n\t                if (++r === 7) {\n\t                    if (opts.showWeekNumber) {\n\t                        row.unshift(renderWeek(i - before, month, year));\n\t                    }\n\t                    data.push(renderRow(row, opts.isRTL));\n\t                    row = [];\n\t                    r = 0;\n\t                }\n\t            }\n\t            return renderTable(opts, data);\n\t        },\n\t\n\t        isVisible: function()\n\t        {\n\t            return this._v;\n\t        },\n\t\n\t        show: function()\n\t        {\n\t            if (!this._v) {\n\t                removeClass(this.el, 'is-hidden');\n\t                this._v = true;\n\t                this.draw();\n\t                if (this._o.bound) {\n\t                    addEvent(document, 'click', this._onClick);\n\t                    this.adjustPosition();\n\t                }\n\t                if (typeof this._o.onOpen === 'function') {\n\t                    this._o.onOpen.call(this);\n\t                }\n\t            }\n\t        },\n\t\n\t        hide: function()\n\t        {\n\t            var v = this._v;\n\t            if (v !== false) {\n\t                if (this._o.bound) {\n\t                    removeEvent(document, 'click', this._onClick);\n\t                }\n\t                this.el.style.position = 'static'; // reset\n\t                this.el.style.left = 'auto';\n\t                this.el.style.top = 'auto';\n\t                addClass(this.el, 'is-hidden');\n\t                this._v = false;\n\t                if (v !== undefined && typeof this._o.onClose === 'function') {\n\t                    this._o.onClose.call(this);\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * GAME OVER\n\t         */\n\t        destroy: function()\n\t        {\n\t            this.hide();\n\t            removeEvent(this.el, 'mousedown', this._onMouseDown, true);\n\t            removeEvent(this.el, 'touchend', this._onMouseDown, true);\n\t            removeEvent(this.el, 'change', this._onChange);\n\t            if (this._o.field) {\n\t                removeEvent(this._o.field, 'change', this._onInputChange);\n\t                if (this._o.bound) {\n\t                    removeEvent(this._o.trigger, 'click', this._onInputClick);\n\t                    removeEvent(this._o.trigger, 'focus', this._onInputFocus);\n\t                    removeEvent(this._o.trigger, 'blur', this._onInputBlur);\n\t                }\n\t            }\n\t            if (this.el.parentNode) {\n\t                this.el.parentNode.removeChild(this.el);\n\t            }\n\t        }\n\t\n\t    };\n\t\n\t    return Pikaday;\n\t\n\t}));\n\n\n/***/ },\n/* 9 */\n/*!********************************************************!*\\\n  !*** ./~/pouchdb-find/lib/abstract-mapreduce/utils.js ***!\n  \\********************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t/* istanbul ignore if */\n\texports.Promise = __webpack_require__(/*! pouchdb-promise */ 17);\n\t\n\texports.inherits = __webpack_require__(/*! inherits */ 15);\n\texports.extend = __webpack_require__(/*! pouchdb-extend */ 16);\n\tvar argsarray = __webpack_require__(/*! argsarray */ 58);\n\t\n\t/* istanbul ignore next */\n\texports.promisedCallback = function (promise, callback) {\n\t  if (callback) {\n\t    promise.then(function (res) {\n\t      process.nextTick(function () {\n\t        callback(null, res);\n\t      });\n\t    }, function (reason) {\n\t      process.nextTick(function () {\n\t        callback(reason);\n\t      });\n\t    });\n\t  }\n\t  return promise;\n\t};\n\t\n\t/* istanbul ignore next */\n\texports.callbackify = function (fun) {\n\t  return argsarray(function (args) {\n\t    var cb = args.pop();\n\t    var promise = fun.apply(this, args);\n\t    if (typeof cb === 'function') {\n\t      exports.promisedCallback(promise, cb);\n\t    }\n\t    return promise;\n\t  });\n\t};\n\t\n\t// Promise finally util similar to Q.finally\n\t/* istanbul ignore next */\n\texports.fin = function (promise, cb) {\n\t  return promise.then(function (res) {\n\t    var promise2 = cb();\n\t    if (typeof promise2.then === 'function') {\n\t      return promise2.then(function () {\n\t        return res;\n\t      });\n\t    }\n\t    return res;\n\t  }, function (reason) {\n\t    var promise2 = cb();\n\t    if (typeof promise2.then === 'function') {\n\t      return promise2.then(function () {\n\t        throw reason;\n\t      });\n\t    }\n\t    throw reason;\n\t  });\n\t};\n\t\n\texports.sequentialize = function (queue, promiseFactory) {\n\t  return function () {\n\t    var args = arguments;\n\t    var that = this;\n\t    return queue.add(function () {\n\t      return promiseFactory.apply(that, args);\n\t    });\n\t  };\n\t};\n\t\n\texports.flatten = function (arrs) {\n\t  var res = [];\n\t  for (var i = 0, len = arrs.length; i < len; i++) {\n\t    res = res.concat(arrs[i]);\n\t  }\n\t  return res;\n\t};\n\t\n\t// uniq an array of strings, order not guaranteed\n\t// similar to underscore/lodash _.uniq\n\texports.uniq = function (arr) {\n\t  var map = {};\n\t\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    map['$' + arr[i]] = true;\n\t  }\n\t\n\t  var keys = Object.keys(map);\n\t  var output = new Array(keys.length);\n\t\n\t  for (i = 0, len = keys.length; i < len; i++) {\n\t    output[i] = keys[i].substring(1);\n\t  }\n\t  return output;\n\t};\n\t\n\tvar crypto = __webpack_require__(/*! crypto */ 84);\n\tvar Md5 = __webpack_require__(/*! spark-md5 */ 19);\n\t\n\texports.MD5 = function (string) {\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    return crypto.createHash('md5').update(string).digest('hex');\n\t  } else {\n\t    return Md5.hash(string);\n\t  }\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 6)))\n\n/***/ },\n/* 10 */\n/*!**************************************************************!*\\\n  !*** ./~/pouchdb-find/lib/adapters/local/abstract-mapper.js ***!\n  \\**************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar localUtils = __webpack_require__(/*! ./utils */ 5);\n\tvar abstractMapReduce = __webpack_require__(/*! ../../abstract-mapreduce */ 49);\n\tvar parseField = localUtils.parseField;\n\t\n\t//\n\t// One thing about these mappers:\n\t//\n\t// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n\t// what you want to do in this case is optimize for the smallest possible\n\t// function, since that's the thing that gets run over and over again.\n\t//\n\t// This code would be a lot simpler if all the if/elses were inside\n\t// the function, but it would also be a lot less performant.\n\t//\n\t\n\t\n\tfunction createDeepMultiMapper(fields, emit) {\n\t  return function (doc) {\n\t    var toEmit = [];\n\t    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n\t      var parsedField = parseField(fields[i]);\n\t      var value = doc;\n\t      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n\t        var key = parsedField[j];\n\t        value = value[key];\n\t        if (!value) {\n\t          break;\n\t        }\n\t      }\n\t      toEmit.push(value);\n\t    }\n\t    emit(toEmit);\n\t  };\n\t}\n\t\n\tfunction createDeepSingleMapper(field, emit) {\n\t  var parsedField = parseField(field);\n\t  return function (doc) {\n\t    var value = doc;\n\t    for (var i = 0, len = parsedField.length; i < len; i++) {\n\t      var key = parsedField[i];\n\t      value = value[key];\n\t      if (!value) {\n\t        return; // do nothing\n\t      }\n\t    }\n\t    emit(value);\n\t  };\n\t}\n\t\n\tfunction createShallowSingleMapper(field, emit) {\n\t  return function (doc) {\n\t    emit(doc[field]);\n\t  };\n\t}\n\t\n\tfunction createShallowMultiMapper(fields, emit) {\n\t  return function (doc) {\n\t    var toEmit = [];\n\t    for (var i = 0, len = fields.length; i < len; i++) {\n\t      toEmit.push(doc[fields[i]]);\n\t    }\n\t    emit(toEmit);\n\t  };\n\t}\n\t\n\tfunction checkShallow(fields) {\n\t  for (var i = 0, len = fields.length; i < len; i++) {\n\t    var field = fields[i];\n\t    if (field.indexOf('.') !== -1) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\tfunction createMapper(fields, emit) {\n\t  var isShallow = checkShallow(fields);\n\t  var isSingle = fields.length === 1;\n\t\n\t  // notice we try to optimize for the most common case,\n\t  // i.e. single shallow indexes\n\t  if (isShallow) {\n\t    if (isSingle) {\n\t      return createShallowSingleMapper(fields[0], emit);\n\t    } else { // multi\n\t      return createShallowMultiMapper(fields, emit);\n\t    }\n\t  } else { // deep\n\t    if (isSingle) {\n\t      return createDeepSingleMapper(fields[0], emit);\n\t    } else { // multi\n\t      return createDeepMultiMapper(fields, emit);\n\t    }\n\t  }\n\t}\n\t\n\tfunction mapper(mapFunDef, emit) {\n\t  // mapFunDef is a list of fields\n\t\n\t  var fields = Object.keys(mapFunDef.fields);\n\t\n\t  return createMapper(fields, emit);\n\t}\n\t\n\t/* istanbul ignore next */\n\tfunction reducer(/*reduceFunDef*/) {\n\t  throw new Error('reduce not supported');\n\t}\n\t\n\tfunction ddocValidator(ddoc, viewName) {\n\t  var view = ddoc.views[viewName];\n\t  // This doesn't actually need to be here apparently, but\n\t  // I feel safer keeping it.\n\t  /* istanbul ignore if */\n\t  if (!view.map || !view.map.fields) {\n\t    throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +\n\t      ' doesn\\'t have map.fields defined. ' +\n\t      'maybe it wasn\\'t created by this plugin?');\n\t  }\n\t}\n\t\n\tvar abstractMapper = abstractMapReduce({\n\t  name: 'indexes',\n\t  mapper: mapper,\n\t  reducer: reducer,\n\t  ddocValidator: ddocValidator\n\t});\n\t\n\tmodule.exports = abstractMapper;\n\n/***/ },\n/* 11 */\n/*!*********************************************************!*\\\n  !*** ./~/pouchdb-find/lib/abstract-mapreduce/upsert.js ***!\n  \\*********************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar upsert = __webpack_require__(/*! pouchdb-upsert */ 18).upsert;\n\t\n\tmodule.exports = function (db, doc, diffFun) {\n\t  return upsert.apply(db, [doc, diffFun]);\n\t};\n\n/***/ },\n/* 12 */\n/*!****************************************************************!*\\\n  !*** ./~/pouchdb-find/lib/adapters/local/get-indexes/index.js ***!\n  \\****************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(/*! ../../../utils */ 3);\n\t\n\tvar localUtils = __webpack_require__(/*! ../utils */ 5);\n\tvar massageIndexDef = localUtils.massageIndexDef;\n\t\n\tfunction getIndexes(db) {\n\t  // just search through all the design docs and filter in-memory.\n\t  // hopefully there aren't that many ddocs.\n\t  return db.allDocs({\n\t    startkey: '_design/',\n\t    endkey: '_design/\\uffff',\n\t    include_docs: true\n\t  }).then(function (allDocsRes) {\n\t    var res = {\n\t      indexes: [{\n\t        ddoc: null,\n\t        name: '_all_docs',\n\t        type: 'special',\n\t        def: {\n\t          fields: [{_id: 'asc'}]\n\t        }\n\t      }]\n\t    };\n\t\n\t    res.indexes = utils.flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n\t      return row.doc.language === 'query';\n\t    }).map(function (row) {\n\t      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\t\n\t      return viewNames.map(function (viewName) {\n\t        var view = row.doc.views[viewName];\n\t        return {\n\t          ddoc: row.id,\n\t          name: viewName,\n\t          type: 'json',\n\t          def: massageIndexDef(view.options.def)\n\t        };\n\t      });\n\t    }));\n\t\n\t    // these are sorted by view name for some reason\n\t    res.indexes.sort(function (left, right) {\n\t      return utils.compare(left.name, right.name);\n\t    });\n\t    res.total_rows = res.indexes.length;\n\t    return res;\n\t  });\n\t}\n\t\n\tmodule.exports = getIndexes;\n\n\n/***/ },\n/* 13 */\n/*!*************************************!*\\\n  !*** ./~/pouchdb-find/lib/index.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(/*! ./utils */ 3);\n\t\n\tvar httpIndexes = __webpack_require__(/*! ./adapters/http */ 51);\n\tvar localIndexes = __webpack_require__(/*! ./adapters/local */ 57);\n\t\n\tvar plugin = {};\n\tplugin.createIndex = utils.toPromise(function (requestDef, callback) {\n\t\n\t  if (typeof requestDef !== 'object') {\n\t    return callback(new Error('you must provide an index to create'));\n\t  }\n\t\n\t  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\t\n\t  adapter.createIndex(this, requestDef, callback);\n\t});\n\t\n\tplugin.find = utils.toPromise(function (requestDef, callback) {\n\t\n\t  if (typeof callback === 'undefined') {\n\t    callback = requestDef;\n\t    requestDef = undefined;\n\t  }\n\t\n\t  if (typeof requestDef !== 'object') {\n\t    return callback(new Error('you must provide search parameters to find()'));\n\t  }\n\t\n\t  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\t\n\t  adapter.find(this, requestDef, callback);\n\t});\n\t\n\tplugin.getIndexes = utils.toPromise(function (callback) {\n\t\n\t  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\t\n\t  adapter.getIndexes(this, callback);\n\t});\n\t\n\tplugin.deleteIndex = utils.toPromise(function (indexDef, callback) {\n\t\n\t  if (typeof indexDef !== 'object') {\n\t    return callback(new Error('you must provide an index to delete'));\n\t  }\n\t\n\t  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\t\n\t  adapter.deleteIndex(this, indexDef, callback);\n\t});\n\t\n\tmodule.exports = plugin;\n\t\n\t/* istanbul ignore next */\n\tif (typeof window !== 'undefined' && window.PouchDB) {\n\t  window.PouchDB.plugin(plugin);\n\t}\n\n\n/***/ },\n/* 14 */\n/*!*********************************************************!*\\\n  !*** ./~/pouchdb-find/lib/massageCreateIndexRequest.js ***!\n  \\*********************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(/*! ./utils */ 3);\n\tvar clone = utils.clone;\n\t\n\t// we restucture the supplied JSON considerably, because the official\n\t// Mango API is very particular about a lot of this stuff, but we like\n\t// to be liberal with what we accept in order to prevent mental\n\t// breakdowns in our users\n\tmodule.exports = function (requestDef) {\n\t  requestDef = clone(requestDef);\n\t\n\t  if (!requestDef.index) {\n\t    requestDef.index = {};\n\t  }\n\t\n\t  ['type', 'name', 'ddoc'].forEach(function (key) {\n\t    if (requestDef.index[key]) {\n\t      requestDef[key] = requestDef.index[key];\n\t      delete requestDef.index[key];\n\t    }\n\t  });\n\t\n\t  if (requestDef.fields) {\n\t    requestDef.index.fields = requestDef.fields;\n\t    delete requestDef.fields;\n\t  }\n\t\n\t  if (!requestDef.type) {\n\t    requestDef.type = 'json';\n\t  }\n\t  return requestDef;\n\t};\n\n/***/ },\n/* 15 */\n/*!*******************************************************!*\\\n  !*** ./~/pouchdb-find/~/inherits/inherits_browser.js ***!\n  \\*******************************************************/\n/***/ function(module, exports) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 16 */\n/*!**************************************************!*\\\n  !*** ./~/pouchdb-find/~/pouchdb-extend/index.js ***!\n  \\**************************************************/\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// Extends method\n\t// (taken from http://code.jquery.com/jquery-1.9.0.js)\n\t// Populate the class2type map\n\tvar class2type = {};\n\t\n\tvar types = [\n\t  \"Boolean\", \"Number\", \"String\", \"Function\", \"Array\",\n\t  \"Date\", \"RegExp\", \"Object\", \"Error\"\n\t];\n\tfor (var i = 0; i < types.length; i++) {\n\t  var typename = types[i];\n\t  class2type[\"[object \" + typename + \"]\"] = typename.toLowerCase();\n\t}\n\t\n\tvar core_toString = class2type.toString;\n\tvar core_hasOwn = class2type.hasOwnProperty;\n\t\n\tfunction type(obj) {\n\t  if (obj === null) {\n\t    return String(obj);\n\t  }\n\t  return typeof obj === \"object\" || typeof obj === \"function\" ?\n\t    class2type[core_toString.call(obj)] || \"object\" :\n\t    typeof obj;\n\t}\n\t\n\tfunction isWindow(obj) {\n\t  return obj !== null && obj === obj.window;\n\t}\n\t\n\tfunction isPlainObject(obj) {\n\t  // Must be an Object.\n\t  // Because of IE, we also have to check the presence of\n\t  // the constructor property.\n\t  // Make sure that DOM nodes and window objects don't pass through, as well\n\t  if (!obj || type(obj) !== \"object\" || obj.nodeType || isWindow(obj)) {\n\t    return false;\n\t  }\n\t\n\t  try {\n\t    // Not own constructor property must be Object\n\t    if (obj.constructor &&\n\t      !core_hasOwn.call(obj, \"constructor\") &&\n\t      !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n\t      return false;\n\t    }\n\t  } catch ( e ) {\n\t    // IE8,9 Will throw exceptions on certain host objects #9897\n\t    return false;\n\t  }\n\t\n\t  // Own properties are enumerated firstly, so to speed up,\n\t  // if last one is own, then all properties are own.\n\t  var key;\n\t  for (key in obj) {}\n\t\n\t  return key === undefined || core_hasOwn.call(obj, key);\n\t}\n\t\n\t\n\tfunction isFunction(obj) {\n\t  return type(obj) === \"function\";\n\t}\n\t\n\tvar isArray = Array.isArray || function (obj) {\n\t  return type(obj) === \"array\";\n\t};\n\t\n\tfunction extend() {\n\t  // originally extend() was recursive, but this ended up giving us\n\t  // \"call stack exceeded\", so it's been unrolled to use a literal stack\n\t  // (see https://github.com/pouchdb/pouchdb/issues/2543)\n\t  var stack = [];\n\t  var i = -1;\n\t  var len = arguments.length;\n\t  var args = new Array(len);\n\t  while (++i < len) {\n\t    args[i] = arguments[i];\n\t  }\n\t  var container = {};\n\t  stack.push({args: args, result: {container: container, key: 'key'}});\n\t  var next;\n\t  while ((next = stack.pop())) {\n\t    extendInner(stack, next.args, next.result);\n\t  }\n\t  return container.key;\n\t}\n\t\n\tfunction extendInner(stack, args, result) {\n\t  var options, name, src, copy, copyIsArray, clone,\n\t    target = args[0] || {},\n\t    i = 1,\n\t    length = args.length,\n\t    deep = false,\n\t    numericStringRegex = /\\d+/,\n\t    optionsIsArray;\n\t\n\t  // Handle a deep copy situation\n\t  if (typeof target === \"boolean\") {\n\t    deep = target;\n\t    target = args[1] || {};\n\t    // skip the boolean and the target\n\t    i = 2;\n\t  }\n\t\n\t  // Handle case when target is a string or something (possible in deep copy)\n\t  if (typeof target !== \"object\" && !isFunction(target)) {\n\t    target = {};\n\t  }\n\t\n\t  // extend jQuery itself if only one argument is passed\n\t  if (length === i) {\n\t    /* jshint validthis: true */\n\t    target = this;\n\t    --i;\n\t  }\n\t\n\t  for (; i < length; i++) {\n\t    // Only deal with non-null/undefined values\n\t    if ((options = args[i]) != null) {\n\t      optionsIsArray = isArray(options);\n\t      // Extend the base object\n\t      for (name in options) {\n\t        //if (options.hasOwnProperty(name)) {\n\t        if (!(name in Object.prototype)) {\n\t          if (optionsIsArray && !numericStringRegex.test(name)) {\n\t            continue;\n\t          }\n\t\n\t          src = target[name];\n\t          copy = options[name];\n\t\n\t          // Prevent never-ending loop\n\t          if (target === copy) {\n\t            continue;\n\t          }\n\t\n\t          // Recurse if we're merging plain objects or arrays\n\t          if (deep && copy && (isPlainObject(copy) ||\n\t              (copyIsArray = isArray(copy)))) {\n\t            if (copyIsArray) {\n\t              copyIsArray = false;\n\t              clone = src && isArray(src) ? src : [];\n\t\n\t            } else {\n\t              clone = src && isPlainObject(src) ? src : {};\n\t            }\n\t\n\t            // Never move original objects, clone them\n\t            stack.push({\n\t              args: [deep, clone, copy],\n\t              result: {\n\t                container: target,\n\t                key: name\n\t              }\n\t            });\n\t\n\t          // Don't bring in undefined values\n\t          } else if (copy !== undefined) {\n\t            if (!(isArray(options) && isFunction(copy))) {\n\t              target[name] = copy;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // \"Return\" the modified object by setting the key\n\t  // on the given container\n\t  result.container[result.key] = target;\n\t}\n\t\n\t\n\tmodule.exports = extend;\n\t\n\t\n\n\n/***/ },\n/* 17 */\n/*!*******************************************************!*\\\n  !*** ./~/pouchdb-find/~/pouchdb-promise/lib/index.js ***!\n  \\*******************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar lie = _interopDefault(__webpack_require__(/*! lie */ 64));\n\t\n\t/* istanbul ignore next */\n\tvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\t\n\tmodule.exports = PouchPromise;\n\n/***/ },\n/* 18 */\n/*!**************************************************!*\\\n  !*** ./~/pouchdb-find/~/pouchdb-upsert/index.js ***!\n  \\**************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar PouchPromise = __webpack_require__(/*! pouchdb-promise */ 66);\n\t\n\t// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n\t// the diffFun tells us what delta to apply to the doc.  it either returns\n\t// the doc, or false if it doesn't need to do an update after all\n\tfunction upsertInner(db, docId, diffFun) {\n\t  if (typeof docId !== 'string') {\n\t    return PouchPromise.reject(new Error('doc id is required'));\n\t  }\n\t\n\t  return db.get(docId).catch(function (err) {\n\t    /* istanbul ignore next */\n\t    if (err.status !== 404) {\n\t      throw err;\n\t    }\n\t    return {};\n\t  }).then(function (doc) {\n\t    // the user might change the _rev, so save it for posterity\n\t    var docRev = doc._rev;\n\t    var newDoc = diffFun(doc);\n\t\n\t    if (!newDoc) {\n\t      // if the diffFun returns falsy, we short-circuit as\n\t      // an optimization\n\t      return { updated: false, rev: docRev };\n\t    }\n\t\n\t    // users aren't allowed to modify these values,\n\t    // so reset them here\n\t    newDoc._id = docId;\n\t    newDoc._rev = docRev;\n\t    return tryAndPut(db, newDoc, diffFun);\n\t  });\n\t}\n\t\n\tfunction tryAndPut(db, doc, diffFun) {\n\t  return db.put(doc).then(function (res) {\n\t    return {\n\t      updated: true,\n\t      rev: res.rev\n\t    };\n\t  }, function (err) {\n\t    /* istanbul ignore next */\n\t    if (err.status !== 409) {\n\t      throw err;\n\t    }\n\t    return upsertInner(db, doc._id, diffFun);\n\t  });\n\t}\n\t\n\texports.upsert = function upsert(docId, diffFun, cb) {\n\t  var db = this;\n\t  var promise = upsertInner(db, docId, diffFun);\n\t  if (typeof cb !== 'function') {\n\t    return promise;\n\t  }\n\t  promise.then(function (resp) {\n\t    cb(null, resp);\n\t  }, cb);\n\t};\n\t\n\texports.putIfNotExists = function putIfNotExists(docId, doc, cb) {\n\t  var db = this;\n\t\n\t  if (typeof docId !== 'string') {\n\t    cb = doc;\n\t    doc = docId;\n\t    docId = doc._id;\n\t  }\n\t\n\t  var diffFun = function (existingDoc) {\n\t    if (existingDoc._rev) {\n\t      return false; // do nothing\n\t    }\n\t    return doc;\n\t  };\n\t\n\t  var promise = upsertInner(db, docId, diffFun);\n\t  if (typeof cb !== 'function') {\n\t    return promise;\n\t  }\n\t  promise.then(function (resp) {\n\t    cb(null, resp);\n\t  }, cb);\n\t};\n\t\n\t\n\t/* istanbul ignore next */\n\tif (typeof window !== 'undefined' && window.PouchDB) {\n\t  window.PouchDB.plugin(exports);\n\t}\n\n\n/***/ },\n/* 19 */\n/*!*************************************************!*\\\n  !*** ./~/pouchdb-find/~/spark-md5/spark-md5.js ***!\n  \\*************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*jshint bitwise:false*/\n\t/*global unescape*/\n\t\n\t(function (factory) {\n\t    if (true) {\n\t        // Node/CommonJS\n\t        module.exports = factory();\n\t    } else if (typeof define === 'function' && define.amd) {\n\t        // AMD\n\t        define(factory);\n\t    } else {\n\t        // Browser globals (with support for web workers)\n\t        var glob;\n\t        try {\n\t            glob = window;\n\t        } catch (e) {\n\t            glob = self;\n\t        }\n\t\n\t        glob.SparkMD5 = factory();\n\t    }\n\t}(function (undefined) {\n\t\n\t    'use strict';\n\t\n\t    ////////////////////////////////////////////////////////////////////////////\n\t\n\t    /*\n\t     * Fastest md5 implementation around (JKM md5)\n\t     * Credits: Joseph Myers\n\t     *\n\t     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n\t     * @see http://jsperf.com/md5-shootout/7\n\t     */\n\t\n\t    /* this function is much faster,\n\t      so if possible we use it. Some IEs\n\t      are the only ones I know of that\n\t      need the idiotic second function,\n\t      generated by an if clause.  */\n\t    var add32 = function (a, b) {\n\t        return (a + b) & 0xFFFFFFFF;\n\t    },\n\t\n\t    cmn = function (q, a, b, x, s, t) {\n\t        a = add32(add32(a, q), add32(x, t));\n\t        return add32((a << s) | (a >>> (32 - s)), b);\n\t    },\n\t\n\t    ff = function (a, b, c, d, x, s, t) {\n\t        return cmn((b & c) | ((~b) & d), a, b, x, s, t);\n\t    },\n\t\n\t    gg = function (a, b, c, d, x, s, t) {\n\t        return cmn((b & d) | (c & (~d)), a, b, x, s, t);\n\t    },\n\t\n\t    hh = function (a, b, c, d, x, s, t) {\n\t        return cmn(b ^ c ^ d, a, b, x, s, t);\n\t    },\n\t\n\t    ii = function (a, b, c, d, x, s, t) {\n\t        return cmn(c ^ (b | (~d)), a, b, x, s, t);\n\t    },\n\t\n\t    md5cycle = function (x, k) {\n\t        var a = x[0],\n\t            b = x[1],\n\t            c = x[2],\n\t            d = x[3];\n\t\n\t        a = ff(a, b, c, d, k[0], 7, -680876936);\n\t        d = ff(d, a, b, c, k[1], 12, -389564586);\n\t        c = ff(c, d, a, b, k[2], 17, 606105819);\n\t        b = ff(b, c, d, a, k[3], 22, -1044525330);\n\t        a = ff(a, b, c, d, k[4], 7, -176418897);\n\t        d = ff(d, a, b, c, k[5], 12, 1200080426);\n\t        c = ff(c, d, a, b, k[6], 17, -1473231341);\n\t        b = ff(b, c, d, a, k[7], 22, -45705983);\n\t        a = ff(a, b, c, d, k[8], 7, 1770035416);\n\t        d = ff(d, a, b, c, k[9], 12, -1958414417);\n\t        c = ff(c, d, a, b, k[10], 17, -42063);\n\t        b = ff(b, c, d, a, k[11], 22, -1990404162);\n\t        a = ff(a, b, c, d, k[12], 7, 1804603682);\n\t        d = ff(d, a, b, c, k[13], 12, -40341101);\n\t        c = ff(c, d, a, b, k[14], 17, -1502002290);\n\t        b = ff(b, c, d, a, k[15], 22, 1236535329);\n\t\n\t        a = gg(a, b, c, d, k[1], 5, -165796510);\n\t        d = gg(d, a, b, c, k[6], 9, -1069501632);\n\t        c = gg(c, d, a, b, k[11], 14, 643717713);\n\t        b = gg(b, c, d, a, k[0], 20, -373897302);\n\t        a = gg(a, b, c, d, k[5], 5, -701558691);\n\t        d = gg(d, a, b, c, k[10], 9, 38016083);\n\t        c = gg(c, d, a, b, k[15], 14, -660478335);\n\t        b = gg(b, c, d, a, k[4], 20, -405537848);\n\t        a = gg(a, b, c, d, k[9], 5, 568446438);\n\t        d = gg(d, a, b, c, k[14], 9, -1019803690);\n\t        c = gg(c, d, a, b, k[3], 14, -187363961);\n\t        b = gg(b, c, d, a, k[8], 20, 1163531501);\n\t        a = gg(a, b, c, d, k[13], 5, -1444681467);\n\t        d = gg(d, a, b, c, k[2], 9, -51403784);\n\t        c = gg(c, d, a, b, k[7], 14, 1735328473);\n\t        b = gg(b, c, d, a, k[12], 20, -1926607734);\n\t\n\t        a = hh(a, b, c, d, k[5], 4, -378558);\n\t        d = hh(d, a, b, c, k[8], 11, -2022574463);\n\t        c = hh(c, d, a, b, k[11], 16, 1839030562);\n\t        b = hh(b, c, d, a, k[14], 23, -35309556);\n\t        a = hh(a, b, c, d, k[1], 4, -1530992060);\n\t        d = hh(d, a, b, c, k[4], 11, 1272893353);\n\t        c = hh(c, d, a, b, k[7], 16, -155497632);\n\t        b = hh(b, c, d, a, k[10], 23, -1094730640);\n\t        a = hh(a, b, c, d, k[13], 4, 681279174);\n\t        d = hh(d, a, b, c, k[0], 11, -358537222);\n\t        c = hh(c, d, a, b, k[3], 16, -722521979);\n\t        b = hh(b, c, d, a, k[6], 23, 76029189);\n\t        a = hh(a, b, c, d, k[9], 4, -640364487);\n\t        d = hh(d, a, b, c, k[12], 11, -421815835);\n\t        c = hh(c, d, a, b, k[15], 16, 530742520);\n\t        b = hh(b, c, d, a, k[2], 23, -995338651);\n\t\n\t        a = ii(a, b, c, d, k[0], 6, -198630844);\n\t        d = ii(d, a, b, c, k[7], 10, 1126891415);\n\t        c = ii(c, d, a, b, k[14], 15, -1416354905);\n\t        b = ii(b, c, d, a, k[5], 21, -57434055);\n\t        a = ii(a, b, c, d, k[12], 6, 1700485571);\n\t        d = ii(d, a, b, c, k[3], 10, -1894986606);\n\t        c = ii(c, d, a, b, k[10], 15, -1051523);\n\t        b = ii(b, c, d, a, k[1], 21, -2054922799);\n\t        a = ii(a, b, c, d, k[8], 6, 1873313359);\n\t        d = ii(d, a, b, c, k[15], 10, -30611744);\n\t        c = ii(c, d, a, b, k[6], 15, -1560198380);\n\t        b = ii(b, c, d, a, k[13], 21, 1309151649);\n\t        a = ii(a, b, c, d, k[4], 6, -145523070);\n\t        d = ii(d, a, b, c, k[11], 10, -1120210379);\n\t        c = ii(c, d, a, b, k[2], 15, 718787259);\n\t        b = ii(b, c, d, a, k[9], 21, -343485551);\n\t\n\t        x[0] = add32(a, x[0]);\n\t        x[1] = add32(b, x[1]);\n\t        x[2] = add32(c, x[2]);\n\t        x[3] = add32(d, x[3]);\n\t    },\n\t\n\t    /* there needs to be support for Unicode here,\n\t       * unless we pretend that we can redefine the MD-5\n\t       * algorithm for multi-byte characters (perhaps\n\t       * by adding every four 16-bit characters and\n\t       * shortening the sum to 32 bits). Otherwise\n\t       * I suggest performing MD-5 as if every character\n\t       * was two bytes--e.g., 0040 0025 = @%--but then\n\t       * how will an ordinary MD-5 sum be matched?\n\t       * There is no way to standardize text to something\n\t       * like UTF-8 before transformation; speed cost is\n\t       * utterly prohibitive. The JavaScript standard\n\t       * itself needs to look at this: it should start\n\t       * providing access to strings as preformed UTF-8\n\t       * 8-bit unsigned value arrays.\n\t       */\n\t    md5blk = function (s) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n\t        }\n\t        return md5blks;\n\t    },\n\t\n\t    md5blk_array = function (a) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n\t        }\n\t        return md5blks;\n\t    },\n\t\n\t    md51 = function (s) {\n\t        var n = s.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk(s.substring(i - 64, i)));\n\t        }\n\t        s = s.substring(i - 64);\n\t        length = s.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t        return state;\n\t    },\n\t\n\t    md51_array = function (a) {\n\t        var n = a.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n\t        }\n\t\n\t        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n\t        // containing the last element of the parent array if the sub array specified starts\n\t        // beyond the length of the parent array - weird.\n\t        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n\t        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\t\n\t        length = a.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t\n\t        return state;\n\t    },\n\t\n\t    hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'],\n\t\n\t    rhex = function (n) {\n\t        var s = '',\n\t            j;\n\t        for (j = 0; j < 4; j += 1) {\n\t            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n\t        }\n\t        return s;\n\t    },\n\t\n\t    hex = function (x) {\n\t        var i;\n\t        for (i = 0; i < x.length; i += 1) {\n\t            x[i] = rhex(x[i]);\n\t        }\n\t        return x.join('');\n\t    },\n\t\n\t    md5 = function (s) {\n\t        return hex(md51(s));\n\t    },\n\t\n\t\n\t\n\t    ////////////////////////////////////////////////////////////////////////////\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation.\n\t     *\n\t     * Use this class to perform an incremental md5, otherwise use the\n\t     * static methods instead.\n\t     */\n\t    SparkMD5 = function () {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    };\n\t\n\t\n\t    // In some cases the fast add32 function cannot be used..\n\t    if (md5('hello') !== '5d41402abc4b2a76b9719d911017c592') {\n\t        add32 = function (x, y) {\n\t            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n\t                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t            return (msw << 16) | (lsw & 0xFFFF);\n\t        };\n\t    }\n\t\n\t\n\t    /**\n\t     * Appends a string.\n\t     * A conversion will be applied if an utf8 string is detected.\n\t     *\n\t     * @param {String} str The string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.append = function (str) {\n\t        // converts the string to utf8 bytes if necessary\n\t        if (/[\\u0080-\\uFFFF]/.test(str)) {\n\t            str = unescape(encodeURIComponent(str));\n\t        }\n\t\n\t        // then append as binary\n\t        this.appendBinary(str);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Appends a binary string.\n\t     *\n\t     * @param {String} contents The binary string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.appendBinary = function (contents) {\n\t        this._buff += contents;\n\t        this._length += contents.length;\n\t\n\t        var length = this._buff.length,\n\t            i;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._state, md5blk(this._buff.substring(i - 64, i)));\n\t        }\n\t\n\t        this._buff = this._buff.substr(i - 64);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     * Use the raw parameter to obtain the raw result instead of the hex one.\n\t     *\n\t     * @param {Boolean} raw True to get the raw result, false to get the hex result\n\t     *\n\t     * @return {String|Array} The result\n\t     */\n\t    SparkMD5.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            i,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = !!raw ? this._state : hex(this._state);\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Finish the final calculation based on the tail.\n\t     *\n\t     * @param {Array}  tail   The tail (will be modified)\n\t     * @param {Number} length The length of the remaining buffer\n\t     */\n\t    SparkMD5.prototype._finish = function (tail, length) {\n\t        var i = length,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(this._state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Do the final computation based on the tail and length\n\t        // Beware that the final length may not fit in 32 bits so we take care of that\n\t        tmp = this._length * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t        md5cycle(this._state, tail);\n\t    };\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.reset = function () {\n\t        this._buff = \"\";\n\t        this._length = 0;\n\t        this._state = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Releases memory used by the incremental buffer and other aditional\n\t     * resources. If you plan to use the instance again, use reset instead.\n\t     */\n\t    SparkMD5.prototype.destroy = function () {\n\t        delete this._state;\n\t        delete this._buff;\n\t        delete this._length;\n\t    };\n\t\n\t\n\t    /**\n\t     * Performs the md5 hash on a string.\n\t     * A conversion will be applied if utf8 string is detected.\n\t     *\n\t     * @param {String}  str The string\n\t     * @param {Boolean} raw True to get the raw result, false to get the hex result\n\t     *\n\t     * @return {String|Array} The result\n\t     */\n\t    SparkMD5.hash = function (str, raw) {\n\t        // converts the string to utf8 bytes if necessary\n\t        if (/[\\u0080-\\uFFFF]/.test(str)) {\n\t            str = unescape(encodeURIComponent(str));\n\t        }\n\t\n\t        var hash = md51(str);\n\t\n\t        return !!raw ? hash : hex(hash);\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on a binary string.\n\t     *\n\t     * @param {String}  content The binary string\n\t     * @param {Boolean} raw     True to get the raw result, false to get the hex result\n\t     *\n\t     * @return {String|Array} The result\n\t     */\n\t    SparkMD5.hashBinary = function (content, raw) {\n\t        var hash = md51(content);\n\t\n\t        return !!raw ? hash : hex(hash);\n\t    };\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation for array buffers.\n\t     *\n\t     * Use this class to perform an incremental md5 ONLY for array buffers.\n\t     */\n\t    SparkMD5.ArrayBuffer = function () {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    };\n\t\n\t    ////////////////////////////////////////////////////////////////////////////\n\t\n\t    /**\n\t     * Appends an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array to be appended\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n\t        // TODO: we could avoid the concatenation here but the algorithm would be more complex\n\t        //       if you find yourself needing extra performance, please make a PR.\n\t        var buff = this._concatArrayBuffer(this._buff, arr),\n\t            length = buff.length,\n\t            i;\n\t\n\t        this._length += arr.byteLength;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._state, md5blk_array(buff.subarray(i - 64, i)));\n\t        }\n\t\n\t        // Avoids IE10 weirdness (documented above)\n\t        this._buff = (i - 64) < length ? buff.subarray(i - 64) : new Uint8Array(0);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     * Use the raw parameter to obtain the raw result instead of the hex one.\n\t     *\n\t     * @param {Boolean} raw True to get the raw result, false to get the hex result\n\t     *\n\t     * @return {String|Array} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            i,\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = !!raw ? this._state : hex(this._state);\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.reset = function () {\n\t        this._buff = new Uint8Array(0);\n\t        this._length = 0;\n\t        this._state = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Releases memory used by the incremental buffer and other aditional\n\t     * resources. If you plan to use the instance again, use reset instead.\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\t\n\t    /**\n\t     * Concats two array buffers, returning a new one.\n\t     *\n\t     * @param  {ArrayBuffer} first  The first array buffer\n\t     * @param  {ArrayBuffer} second The second array buffer\n\t     *\n\t     * @return {ArrayBuffer} The new array buffer\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype._concatArrayBuffer = function (first, second) {\n\t        var firstLength = first.length,\n\t            result = new Uint8Array(firstLength + second.byteLength);\n\t\n\t        result.set(first);\n\t        result.set(new Uint8Array(second), firstLength);\n\t\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array buffer\n\t     * @param {Boolean}     raw True to get the raw result, false to get the hex result\n\t     *\n\t     * @return {String|Array} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n\t        var hash = md51_array(new Uint8Array(arr));\n\t\n\t        return !!raw ? hash : hex(hash);\n\t    };\n\t\n\t    return SparkMD5;\n\t}));\n\n\n/***/ },\n/* 20 */\n/*!****************************************!*\\\n  !*** ./~/pouchdb/lib/index-browser.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar lie = _interopDefault(__webpack_require__(/*! lie */ 75));\n\tvar getArguments = _interopDefault(__webpack_require__(/*! argsarray */ 69));\n\tvar debug = _interopDefault(__webpack_require__(/*! debug */ 70));\n\tvar events = __webpack_require__(/*! events */ 82);\n\tvar inherits = _interopDefault(__webpack_require__(/*! inherits */ 74));\n\tvar scopedEval = _interopDefault(__webpack_require__(/*! scope-eval */ 77));\n\tvar Md5 = _interopDefault(__webpack_require__(/*! spark-md5 */ 78));\n\tvar vuvuzela = _interopDefault(__webpack_require__(/*! vuvuzela */ 79));\n\tvar PromisePool = _interopDefault(__webpack_require__(/*! es6-promise-pool */ 73));\n\t\n\t/* istanbul ignore next */\n\tvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\t\n\tfunction isBinaryObject(object) {\n\t  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n\t    (typeof Blob !== 'undefined' && object instanceof Blob);\n\t}\n\t\n\tfunction cloneArrayBuffer(buff) {\n\t  if (typeof buff.slice === 'function') {\n\t    return buff.slice(0);\n\t  }\n\t  // IE10-11 slice() polyfill\n\t  var target = new ArrayBuffer(buff.byteLength);\n\t  var targetArray = new Uint8Array(target);\n\t  var sourceArray = new Uint8Array(buff);\n\t  targetArray.set(sourceArray);\n\t  return target;\n\t}\n\t\n\tfunction cloneBinaryObject(object) {\n\t  if (object instanceof ArrayBuffer) {\n\t    return cloneArrayBuffer(object);\n\t  }\n\t  var size = object.size;\n\t  var type = object.type;\n\t  // Blob\n\t  if (typeof object.slice === 'function') {\n\t    return object.slice(0, size, type);\n\t  }\n\t  // PhantomJS slice() replacement\n\t  return object.webkitSlice(0, size, type);\n\t}\n\t\n\t// most of this is borrowed from lodash.isPlainObject:\n\t// https://github.com/fis-components/lodash.isplainobject/\n\t// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\t\n\tvar funcToString = Function.prototype.toString;\n\tvar objectCtorString = funcToString.call(Object);\n\t\n\tfunction isPlainObject(value) {\n\t  var proto = Object.getPrototypeOf(value);\n\t  /* istanbul ignore if */\n\t  if (proto === null) { // not sure when this happens, but I guess it can\n\t    return true;\n\t  }\n\t  var Ctor = proto.constructor;\n\t  return (typeof Ctor == 'function' &&\n\t    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n\t}\n\t\n\tfunction clone(object) {\n\t  var newObject;\n\t  var i;\n\t  var len;\n\t\n\t  if (!object || typeof object !== 'object') {\n\t    return object;\n\t  }\n\t\n\t  if (Array.isArray(object)) {\n\t    newObject = [];\n\t    for (i = 0, len = object.length; i < len; i++) {\n\t      newObject[i] = clone(object[i]);\n\t    }\n\t    return newObject;\n\t  }\n\t\n\t  // special case: to avoid inconsistencies between IndexedDB\n\t  // and other backends, we automatically stringify Dates\n\t  if (object instanceof Date) {\n\t    return object.toISOString();\n\t  }\n\t\n\t  if (isBinaryObject(object)) {\n\t    return cloneBinaryObject(object);\n\t  }\n\t\n\t  if (!isPlainObject(object)) {\n\t    return object; // don't clone objects like Workers\n\t  }\n\t\n\t  newObject = {};\n\t  for (i in object) {\n\t    /* istanbul ignore else */\n\t    if (Object.prototype.hasOwnProperty.call(object, i)) {\n\t      var value = clone(object[i]);\n\t      if (typeof value !== 'undefined') {\n\t        newObject[i] = value;\n\t      }\n\t    }\n\t  }\n\t  return newObject;\n\t}\n\t\n\tfunction once(fun) {\n\t  var called = false;\n\t  return getArguments(function (args) {\n\t    /* istanbul ignore if */\n\t    if (called) {\n\t      // this is a smoke test and should never actually happen\n\t      throw new Error('once called more than once');\n\t    } else {\n\t      called = true;\n\t      fun.apply(this, args);\n\t    }\n\t  });\n\t}\n\t\n\tfunction toPromise(func) {\n\t  //create the function we will be returning\n\t  return getArguments(function (args) {\n\t    // Clone arguments\n\t    args = clone(args);\n\t    var self = this;\n\t    var tempCB =\n\t      (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n\t    // if the last argument is a function, assume its a callback\n\t    var usedCB;\n\t    if (tempCB) {\n\t      // if it was a callback, create a new callback which calls it,\n\t      // but do so async so we don't trap any errors\n\t      usedCB = function (err, resp) {\n\t        process.nextTick(function () {\n\t          tempCB(err, resp);\n\t        });\n\t      };\n\t    }\n\t    var promise = new PouchPromise(function (fulfill, reject) {\n\t      var resp;\n\t      try {\n\t        var callback = once(function (err, mesg) {\n\t          if (err) {\n\t            reject(err);\n\t          } else {\n\t            fulfill(mesg);\n\t          }\n\t        });\n\t        // create a callback for this invocation\n\t        // apply the function in the orig context\n\t        args.push(callback);\n\t        resp = func.apply(self, args);\n\t        if (resp && typeof resp.then === 'function') {\n\t          fulfill(resp);\n\t        }\n\t      } catch (e) {\n\t        reject(e);\n\t      }\n\t    });\n\t    // if there is a callback, call it back\n\t    if (usedCB) {\n\t      promise.then(function (result) {\n\t        usedCB(null, result);\n\t      }, usedCB);\n\t    }\n\t    return promise;\n\t  });\n\t}\n\t\n\tvar log = debug('pouchdb:api');\n\t\n\tfunction adapterFun(name, callback) {\n\t  function logApiCall(self, name, args) {\n\t    /* istanbul ignore if */\n\t    if (log.enabled) {\n\t      var logArgs = [self.name, name];\n\t      for (var i = 0; i < args.length - 1; i++) {\n\t        logArgs.push(args[i]);\n\t      }\n\t      log.apply(null, logArgs);\n\t\n\t      // override the callback itself to log the response\n\t      var origCallback = args[args.length - 1];\n\t      args[args.length - 1] = function (err, res) {\n\t        var responseArgs = [self.name, name];\n\t        responseArgs = responseArgs.concat(\n\t          err ? ['error', err] : ['success', res]\n\t        );\n\t        log.apply(null, responseArgs);\n\t        origCallback(err, res);\n\t      };\n\t    }\n\t  }\n\t\n\t  return toPromise(getArguments(function (args) {\n\t    if (this._closed) {\n\t      return PouchPromise.reject(new Error('database is closed'));\n\t    }\n\t    if (this._destroyed) {\n\t      return PouchPromise.reject(new Error('database is destroyed'));\n\t    }\n\t    var self = this;\n\t    logApiCall(self, name, args);\n\t    if (!this.taskqueue.isReady) {\n\t      return new PouchPromise(function (fulfill, reject) {\n\t        self.taskqueue.addTask(function (failed) {\n\t          if (failed) {\n\t            reject(failed);\n\t          } else {\n\t            fulfill(self[name].apply(self, args));\n\t          }\n\t        });\n\t      });\n\t    }\n\t    return callback.apply(this, args);\n\t  }));\n\t}\n\t\n\t// like underscore/lodash _.pick()\n\tfunction pick(obj, arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    var prop = arr[i];\n\t    if (prop in obj) {\n\t      res[prop] = obj[prop];\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t// Most browsers throttle concurrent requests at 6, so it's silly\n\t// to shim _bulk_get by trying to launch potentially hundreds of requests\n\t// and then letting the majority time out. We can handle this ourselves.\n\tvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\t\n\tfunction identityFunction(x) {\n\t  return x;\n\t}\n\t\n\tfunction formatResultForOpenRevsGet(result) {\n\t  return [{\n\t    ok: result\n\t  }];\n\t}\n\t\n\t// shim for P/CouchDB adapters that don't directly implement _bulk_get\n\tfunction bulkGet(db, opts, callback) {\n\t  var requests = opts.docs;\n\t\n\t  // consolidate into one request per doc if possible\n\t  var requestsById = {};\n\t  requests.forEach(function (request) {\n\t    if (request.id in requestsById) {\n\t      requestsById[request.id].push(request);\n\t    } else {\n\t      requestsById[request.id] = [request];\n\t    }\n\t  });\n\t\n\t  var numDocs = Object.keys(requestsById).length;\n\t  var numDone = 0;\n\t  var perDocResults = new Array(numDocs);\n\t\n\t  function collapseResultsAndFinish() {\n\t    var results = [];\n\t    perDocResults.forEach(function (res) {\n\t      res.docs.forEach(function (info) {\n\t        results.push({\n\t          id: res.id,\n\t          docs: [info]\n\t        });\n\t      });\n\t    });\n\t    callback(null, {results: results});\n\t  }\n\t\n\t  function checkDone() {\n\t    if (++numDone === numDocs) {\n\t      collapseResultsAndFinish();\n\t    }\n\t  }\n\t\n\t  function gotResult(docIndex, id, docs) {\n\t    perDocResults[docIndex] = {id: id, docs: docs};\n\t    checkDone();\n\t  }\n\t\n\t  var allRequests = Object.keys(requestsById);\n\t\n\t  var i = 0;\n\t\n\t  function nextBatch() {\n\t\n\t    if (i >= allRequests.length) {\n\t      return;\n\t    }\n\t\n\t    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n\t    var batch = allRequests.slice(i, upTo);\n\t    processBatch(batch, i);\n\t    i += batch.length;\n\t  }\n\t\n\t  function processBatch(batch, offset) {\n\t    batch.forEach(function (docId, j) {\n\t      var docIdx = offset + j;\n\t      var docRequests = requestsById[docId];\n\t\n\t      // just use the first request as the \"template\"\n\t      // TODO: The _bulk_get API allows for more subtle use cases than this,\n\t      // but for now it is unlikely that there will be a mix of different\n\t      // \"atts_since\" or \"attachments\" in the same request, since it's just\n\t      // replicate.js that is using this for the moment.\n\t      // Also, atts_since is aspirational, since we don't support it yet.\n\t      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n\t      docOpts.open_revs = docRequests.map(function (request) {\n\t        // rev is optional, open_revs disallowed\n\t        return request.rev;\n\t      });\n\t\n\t      // remove falsey / undefined revisions\n\t      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\t\n\t      var formatResult = identityFunction;\n\t\n\t      if (docOpts.open_revs.length === 0) {\n\t        delete docOpts.open_revs;\n\t\n\t        // when fetching only the \"winning\" leaf,\n\t        // transform the result so it looks like an open_revs\n\t        // request\n\t        formatResult = formatResultForOpenRevsGet;\n\t      }\n\t\n\t      // globally-supplied options\n\t      ['revs', 'attachments', 'binary', 'ajax'].forEach(function (param) {\n\t        if (param in opts) {\n\t          docOpts[param] = opts[param];\n\t        }\n\t      });\n\t      db.get(docId, docOpts, function (err, res) {\n\t        var result;\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          result = [{error: err}];\n\t        } else {\n\t          result = formatResult(res);\n\t        }\n\t        gotResult(docIdx, docId, result);\n\t        nextBatch();\n\t      });\n\t    });\n\t  }\n\t\n\t  nextBatch();\n\t\n\t}\n\t\n\tfunction isChromeApp() {\n\t  return (typeof chrome !== \"undefined\" &&\n\t    typeof chrome.storage !== \"undefined\" &&\n\t    typeof chrome.storage.local !== \"undefined\");\n\t}\n\t\n\tvar hasLocal;\n\t\n\tif (isChromeApp()) {\n\t  hasLocal = false;\n\t} else {\n\t  try {\n\t    localStorage.setItem('_pouch_check_localstorage', 1);\n\t    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n\t  } catch (e) {\n\t    hasLocal = false;\n\t  }\n\t}\n\t\n\tfunction hasLocalStorage() {\n\t  return hasLocal;\n\t}\n\t\n\tinherits(Changes, events.EventEmitter);\n\t\n\t/* istanbul ignore next */\n\tfunction attachBrowserEvents(self) {\n\t  if (isChromeApp()) {\n\t    chrome.storage.onChanged.addListener(function (e) {\n\t      // make sure it's event addressed to us\n\t      if (e.db_name != null) {\n\t        //object only has oldValue, newValue members\n\t        self.emit(e.dbName.newValue);\n\t      }\n\t    });\n\t  } else if (hasLocalStorage()) {\n\t    if (typeof addEventListener !== 'undefined') {\n\t      addEventListener(\"storage\", function (e) {\n\t        self.emit(e.key);\n\t      });\n\t    } else { // old IE\n\t      window.attachEvent(\"storage\", function (e) {\n\t        self.emit(e.key);\n\t      });\n\t    }\n\t  }\n\t}\n\t\n\tfunction Changes() {\n\t  events.EventEmitter.call(this);\n\t  this._listeners = {};\n\t\n\t  attachBrowserEvents(this);\n\t}\n\tChanges.prototype.addListener = function (dbName, id, db, opts) {\n\t  /* istanbul ignore if */\n\t  if (this._listeners[id]) {\n\t    return;\n\t  }\n\t  var self = this;\n\t  var inprogress = false;\n\t  function eventFunction() {\n\t    /* istanbul ignore if */\n\t    if (!self._listeners[id]) {\n\t      return;\n\t    }\n\t    if (inprogress) {\n\t      inprogress = 'waiting';\n\t      return;\n\t    }\n\t    inprogress = true;\n\t    var changesOpts = pick(opts, [\n\t      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n\t      'doc_ids', 'view', 'since', 'query_params', 'binary'\n\t    ]);\n\t\n\t    /* istanbul ignore next */\n\t    function onError() {\n\t      inprogress = false;\n\t    }\n\t\n\t    db.changes(changesOpts).on('change', function (c) {\n\t      if (c.seq > opts.since && !opts.cancelled) {\n\t        opts.since = c.seq;\n\t        opts.onChange(c);\n\t      }\n\t    }).on('complete', function () {\n\t      if (inprogress === 'waiting') {\n\t        setTimeout(function (){\n\t          eventFunction();\n\t        },0);\n\t      }\n\t      inprogress = false;\n\t    }).on('error', onError);\n\t  }\n\t  this._listeners[id] = eventFunction;\n\t  this.on(dbName, eventFunction);\n\t};\n\t\n\tChanges.prototype.removeListener = function (dbName, id) {\n\t  /* istanbul ignore if */\n\t  if (!(id in this._listeners)) {\n\t    return;\n\t  }\n\t  events.EventEmitter.prototype.removeListener.call(this, dbName,\n\t    this._listeners[id]);\n\t  delete this._listeners[id];\n\t};\n\t\n\t\n\t/* istanbul ignore next */\n\tChanges.prototype.notifyLocalWindows = function (dbName) {\n\t  //do a useless change on a storage thing\n\t  //in order to get other windows's listeners to activate\n\t  if (isChromeApp()) {\n\t    chrome.storage.local.set({dbName: dbName});\n\t  } else if (hasLocalStorage()) {\n\t    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n\t  }\n\t};\n\t\n\tChanges.prototype.notify = function (dbName) {\n\t  this.emit(dbName);\n\t  this.notifyLocalWindows(dbName);\n\t};\n\t\n\tfunction guardedConsole(method) {\n\t  /* istanbul ignore else */\n\t  if (console !== 'undefined' && method in console) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    console[method].apply(console, args);\n\t  }\n\t}\n\t\n\tfunction randomNumber(min, max) {\n\t  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n\t  min = parseInt(min, 10) || 0;\n\t  max = parseInt(max, 10);\n\t  if (max !== max || max <= min) {\n\t    max = (min || 1) << 1; //doubling\n\t  } else {\n\t    max = max + 1;\n\t  }\n\t  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n\t  if(max > maxTimeout) {\n\t    min = maxTimeout >> 1; // divide by two\n\t    max = maxTimeout;\n\t  }\n\t  var ratio = Math.random();\n\t  var range = max - min;\n\t\n\t  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n\t}\n\t\n\tfunction defaultBackOff(min) {\n\t  var max = 0;\n\t  if (!min) {\n\t    max = 2000;\n\t  }\n\t  return randomNumber(min, max);\n\t}\n\t\n\t// designed to give info to browser users, who are disturbed\n\t// when they see http errors in the console\n\tfunction explainError(status, str) {\n\t  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n\t}\n\t\n\t// forked from\n\t// https://github.com/vmattos/js-extend/blob/7023fd69a9e9552688086b8b8006b1fcf916a306/extend.js\n\t// TODO: I don't know why we have two different extend() functions in PouchDB\n\t\n\tvar slice = Array.prototype.slice;\n\tvar each = Array.prototype.forEach;\n\t\n\tfunction extend$1(obj) {\n\t  if (typeof obj !== 'object') {\n\t    throw obj + ' is not an object' ;\n\t  }\n\t\n\t  var sources = slice.call(arguments, 1);\n\t\n\t  each.call(sources, function (source) {\n\t    if (source) {\n\t      for (var prop in source) {\n\t        if (typeof source[prop] === 'object' && obj[prop]) {\n\t          extend$1.call(obj, obj[prop], source[prop]);\n\t        } else {\n\t          obj[prop] = source[prop];\n\t        }\n\t      }\n\t    }\n\t  });\n\t\n\t  return obj;\n\t}\n\t\n\tinherits(PouchError, Error);\n\t\n\tfunction PouchError(opts) {\n\t  Error.call(this, opts.reason);\n\t  this.status = opts.status;\n\t  this.name = opts.error;\n\t  this.message = opts.reason;\n\t  this.error = true;\n\t}\n\t\n\tPouchError.prototype.toString = function () {\n\t  return JSON.stringify({\n\t    status: this.status,\n\t    name: this.name,\n\t    message: this.message,\n\t    reason: this.reason\n\t  });\n\t};\n\t\n\tvar UNAUTHORIZED = new PouchError({\n\t  status: 401,\n\t  error: 'unauthorized',\n\t  reason: \"Name or password is incorrect.\"\n\t});\n\t\n\tvar MISSING_BULK_DOCS = new PouchError({\n\t  status: 400,\n\t  error: 'bad_request',\n\t  reason: \"Missing JSON list of 'docs'\"\n\t});\n\t\n\tvar MISSING_DOC = new PouchError({\n\t  status: 404,\n\t  error: 'not_found',\n\t  reason: 'missing'\n\t});\n\t\n\tvar REV_CONFLICT = new PouchError({\n\t  status: 409,\n\t  error: 'conflict',\n\t  reason: 'Document update conflict'\n\t});\n\t\n\tvar INVALID_ID = new PouchError({\n\t  status: 400,\n\t  error: 'bad_request',\n\t  reason: '_id field must contain a string'\n\t});\n\t\n\tvar MISSING_ID = new PouchError({\n\t  status: 412,\n\t  error: 'missing_id',\n\t  reason: '_id is required for puts'\n\t});\n\t\n\tvar RESERVED_ID = new PouchError({\n\t  status: 400,\n\t  error: 'bad_request',\n\t  reason: 'Only reserved document ids may start with underscore.'\n\t});\n\t\n\tvar NOT_OPEN = new PouchError({\n\t  status: 412,\n\t  error: 'precondition_failed',\n\t  reason: 'Database not open'\n\t});\n\t\n\tvar UNKNOWN_ERROR = new PouchError({\n\t  status: 500,\n\t  error: 'unknown_error',\n\t  reason: 'Database encountered an unknown error'\n\t});\n\t\n\tvar BAD_ARG = new PouchError({\n\t  status: 500,\n\t  error: 'badarg',\n\t  reason: 'Some query argument is invalid'\n\t});\n\t\n\tvar INVALID_REQUEST = new PouchError({\n\t  status: 400,\n\t  error: 'invalid_request',\n\t  reason: 'Request was invalid'\n\t});\n\t\n\tvar QUERY_PARSE_ERROR = new PouchError({\n\t  status: 400,\n\t  error: 'query_parse_error',\n\t  reason: 'Some query parameter is invalid'\n\t});\n\t\n\tvar DOC_VALIDATION = new PouchError({\n\t  status: 500,\n\t  error: 'doc_validation',\n\t  reason: 'Bad special document member'\n\t});\n\t\n\tvar BAD_REQUEST = new PouchError({\n\t  status: 400,\n\t  error: 'bad_request',\n\t  reason: 'Something wrong with the request'\n\t});\n\t\n\tvar NOT_AN_OBJECT = new PouchError({\n\t  status: 400,\n\t  error: 'bad_request',\n\t  reason: 'Document must be a JSON object'\n\t});\n\t\n\tvar DB_MISSING = new PouchError({\n\t  status: 404,\n\t  error: 'not_found',\n\t  reason: 'Database not found'\n\t});\n\t\n\tvar IDB_ERROR = new PouchError({\n\t  status: 500,\n\t  error: 'indexed_db_went_bad',\n\t  reason: 'unknown'\n\t});\n\t\n\tvar WSQ_ERROR = new PouchError({\n\t  status: 500,\n\t  error: 'web_sql_went_bad',\n\t  reason: 'unknown'\n\t});\n\t\n\tvar LDB_ERROR = new PouchError({\n\t  status: 500,\n\t  error: 'levelDB_went_went_bad',\n\t  reason: 'unknown'\n\t});\n\t\n\tvar FORBIDDEN = new PouchError({\n\t  status: 403,\n\t  error: 'forbidden',\n\t  reason: 'Forbidden by design doc validate_doc_update function'\n\t});\n\t\n\tvar INVALID_REV = new PouchError({\n\t  status: 400,\n\t  error: 'bad_request',\n\t  reason: 'Invalid rev format'\n\t});\n\t\n\tvar FILE_EXISTS = new PouchError({\n\t  status: 412,\n\t  error: 'file_exists',\n\t  reason: 'The database could not be created, the file already exists.'\n\t});\n\t\n\tvar MISSING_STUB = new PouchError({\n\t  status: 412,\n\t  error: 'missing_stub'\n\t});\n\t\n\tvar INVALID_URL = new PouchError({\n\t  status: 413,\n\t  error: 'invalid_url',\n\t  reason: 'Provided URL is invalid'\n\t});\n\t\n\tfunction createError(error, reason) {\n\t  function CustomPouchError(reason) {\n\t    // inherit error properties from our parent error manually\n\t    // so as to allow proper JSON parsing.\n\t    /* jshint ignore:start */\n\t    for (var p in error) {\n\t      if (typeof error[p] !== 'function') {\n\t        this[p] = error[p];\n\t      }\n\t    }\n\t    /* jshint ignore:end */\n\t    if (reason !== undefined) {\n\t      this.reason = reason;\n\t    }\n\t  }\n\t  CustomPouchError.prototype = PouchError.prototype;\n\t  return new CustomPouchError(reason);\n\t}\n\t\n\tfunction generateErrorFromResponse(err) {\n\t\n\t  if (typeof err !== 'object') {\n\t    var data = err;\n\t    err = UNKNOWN_ERROR;\n\t    err.data = data;\n\t  }\n\t\n\t  if ('error' in err && err.error === 'conflict') {\n\t    err.name = 'conflict';\n\t    err.status = 409;\n\t  }\n\t\n\t  if (!('name' in err)) {\n\t    err.name = err.error || 'unknown';\n\t  }\n\t\n\t  if (!('status' in err)) {\n\t    err.status = 500;\n\t  }\n\t\n\t  if (!('message' in err)) {\n\t    err.message = err.message || err.reason;\n\t  }\n\t\n\t  return err;\n\t}\n\t\n\tfunction tryFilter(filter, doc, req) {\n\t  try {\n\t    return !filter(doc, req);\n\t  } catch (err) {\n\t    var msg = 'Filter function threw: ' + err.toString();\n\t    return createError(BAD_REQUEST, msg);\n\t  }\n\t}\n\t\n\tfunction filterChange(opts) {\n\t  var req = {};\n\t  var hasFilter = opts.filter && typeof opts.filter === 'function';\n\t  req.query = opts.query_params;\n\t\n\t  return function filter(change) {\n\t    if (!change.doc) {\n\t      // CSG sends events on the changes feed that don't have documents,\n\t      // this hack makes a whole lot of existing code robust.\n\t      change.doc = {};\n\t    }\n\t\n\t    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\t\n\t    if (typeof filterReturn === 'object') {\n\t      return filterReturn;\n\t    }\n\t\n\t    if (filterReturn) {\n\t      return false;\n\t    }\n\t\n\t    if (!opts.include_docs) {\n\t      delete change.doc;\n\t    } else if (!opts.attachments) {\n\t      for (var att in change.doc._attachments) {\n\t        /* istanbul ignore else */\n\t        if (change.doc._attachments.hasOwnProperty(att)) {\n\t          change.doc._attachments[att].stub = true;\n\t        }\n\t      }\n\t    }\n\t    return true;\n\t  };\n\t}\n\t\n\tfunction flatten(arrs) {\n\t  var res = [];\n\t  for (var i = 0, len = arrs.length; i < len; i++) {\n\t    res = res.concat(arrs[i]);\n\t  }\n\t  return res;\n\t}\n\t\n\t// Determine id an ID is valid\n\t//   - invalid IDs begin with an underescore that does not begin '_design' or\n\t//     '_local'\n\t//   - any other string value is a valid id\n\t// Returns the specific error object for each case\n\tfunction invalidIdError(id) {\n\t  var err;\n\t  if (!id) {\n\t    err = createError(MISSING_ID);\n\t  } else if (typeof id !== 'string') {\n\t    err = createError(INVALID_ID);\n\t  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n\t    err = createError(RESERVED_ID);\n\t  }\n\t  if (err) {\n\t    throw err;\n\t  }\n\t}\n\t\n\tfunction listenerCount(ee, type) {\n\t  return 'listenerCount' in ee ? ee.listenerCount(type) :\n\t                                 events.EventEmitter.listenerCount(ee, type);\n\t}\n\t\n\tfunction parseDesignDocFunctionName(s) {\n\t  if (!s) {\n\t    return null;\n\t  }\n\t  var parts = s.split('/');\n\t  if (parts.length === 2) {\n\t    return parts;\n\t  }\n\t  if (parts.length === 1) {\n\t    return [s, s];\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction normalizeDesignDocFunctionName(s) {\n\t  var normalized = parseDesignDocFunctionName(s);\n\t  return normalized ? normalized.join('/') : null;\n\t}\n\t\n\t// originally parseUri 1.2.2, now patched by us\n\t// (c) Steven Levithan <stevenlevithan.com>\n\t// MIT License\n\tvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n\t    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\n\tvar qName =\"queryKey\";\n\tvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\t\n\t// use the \"loose\" parser\n\t/* jshint maxlen: false */\n\tvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\t\n\tfunction parseUri(str) {\n\t  var m = parser.exec(str);\n\t  var uri = {};\n\t  var i = 14;\n\t\n\t  while (i--) {\n\t    var key = keys[i];\n\t    var value = m[i] || \"\";\n\t    var encoded = ['user', 'password'].indexOf(key) !== -1;\n\t    uri[key] = encoded ? decodeURIComponent(value) : value;\n\t  }\n\t\n\t  uri[qName] = {};\n\t  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n\t    if ($1) {\n\t      uri[qName][$1] = $2;\n\t    }\n\t  });\n\t\n\t  return uri;\n\t}\n\t\n\t// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n\t// the diffFun tells us what delta to apply to the doc.  it either returns\n\t// the doc, or false if it doesn't need to do an update after all\n\tfunction upsert(db, docId, diffFun) {\n\t  return new PouchPromise(function (fulfill, reject) {\n\t    db.get(docId, function (err, doc) {\n\t      if (err) {\n\t        /* istanbul ignore next */\n\t        if (err.status !== 404) {\n\t          return reject(err);\n\t        }\n\t        doc = {};\n\t      }\n\t\n\t      // the user might change the _rev, so save it for posterity\n\t      var docRev = doc._rev;\n\t      var newDoc = diffFun(doc);\n\t\n\t      if (!newDoc) {\n\t        // if the diffFun returns falsy, we short-circuit as\n\t        // an optimization\n\t        return fulfill({updated: false, rev: docRev});\n\t      }\n\t\n\t      // users aren't allowed to modify these values,\n\t      // so reset them here\n\t      newDoc._id = docId;\n\t      newDoc._rev = docRev;\n\t      fulfill(tryAndPut(db, newDoc, diffFun));\n\t    });\n\t  });\n\t}\n\t\n\tfunction tryAndPut(db, doc, diffFun) {\n\t  return db.put(doc).then(function (res) {\n\t    return {\n\t      updated: true,\n\t      rev: res.rev\n\t    };\n\t  }, function (err) {\n\t    /* istanbul ignore next */\n\t    if (err.status !== 409) {\n\t      throw err;\n\t    }\n\t    return upsert(db, doc._id, diffFun);\n\t  });\n\t}\n\t\n\t// BEGIN Math.uuid.js\n\t\n\t/*!\n\tMath.uuid.js (v1.4)\n\thttp://www.broofa.com\n\tmailto:robert@broofa.com\n\t\n\tCopyright (c) 2010 Robert Kieffer\n\tDual licensed under the MIT and GPL licenses.\n\t*/\n\t\n\t/*\n\t * Generate a random uuid.\n\t *\n\t * USAGE: Math.uuid(length, radix)\n\t *   length - the desired number of characters\n\t *   radix  - the number of allowable values for each character.\n\t *\n\t * EXAMPLES:\n\t *   // No arguments  - returns RFC4122, version 4 ID\n\t *   >>> Math.uuid()\n\t *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n\t *\n\t *   // One argument - returns ID of the specified length\n\t *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n\t *   \"VcydxgltxrVZSTV\"\n\t *\n\t *   // Two arguments - returns ID of the specified length, and radix. \n\t *   // (Radix must be <= 62)\n\t *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n\t *   \"01001010\"\n\t *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n\t *   \"47473046\"\n\t *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n\t *   \"098F4D35\"\n\t */\n\tvar chars = (\n\t  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n\t  'abcdefghijklmnopqrstuvwxyz'\n\t).split('');\n\tfunction getValue(radix) {\n\t  return 0 | Math.random() * radix;\n\t}\n\tfunction uuid(len, radix) {\n\t  radix = radix || chars.length;\n\t  var out = '';\n\t  var i = -1;\n\t\n\t  if (len) {\n\t    // Compact form\n\t    while (++i < len) {\n\t      out += chars[getValue(radix)];\n\t    }\n\t    return out;\n\t  }\n\t    // rfc4122, version 4 form\n\t    // Fill in random data.  At i==19 set the high bits of clock sequence as\n\t    // per rfc4122, sec. 4.1.5\n\t  while (++i < 36) {\n\t    switch (i) {\n\t      case 8:\n\t      case 13:\n\t      case 18:\n\t      case 23:\n\t        out += '-';\n\t        break;\n\t      case 19:\n\t        out += chars[(getValue(16) & 0x3) | 0x8];\n\t        break;\n\t      default:\n\t        out += chars[getValue(16)];\n\t    }\n\t  }\n\t\n\t  return out;\n\t}\n\t\n\t// based on https://github.com/montagejs/collections\n\tfunction mangle(key) {\n\t  return '$' + key;\n\t}\n\tfunction unmangle(key) {\n\t  return key.substring(1);\n\t}\n\tfunction _Map() {\n\t  this.store = {};\n\t}\n\t_Map.prototype.get = function (key) {\n\t  var mangled = mangle(key);\n\t  return this.store[mangled];\n\t};\n\t_Map.prototype.set = function (key, value) {\n\t  var mangled = mangle(key);\n\t  this.store[mangled] = value;\n\t  return true;\n\t};\n\t_Map.prototype.has = function (key) {\n\t  var mangled = mangle(key);\n\t  return mangled in this.store;\n\t};\n\t_Map.prototype.delete = function (key) {\n\t  var mangled = mangle(key);\n\t  var res = mangled in this.store;\n\t  delete this.store[mangled];\n\t  return res;\n\t};\n\t_Map.prototype.forEach = function (cb) {\n\t  var keys = Object.keys(this.store);\n\t  for (var i = 0, len = keys.length; i < len; i++) {\n\t    var key = keys[i];\n\t    var value = this.store[key];\n\t    key = unmangle(key);\n\t    cb(value, key);\n\t  }\n\t};\n\t\n\tfunction _Set(array) {\n\t  this.store = new _Map();\n\t\n\t  // init with an array\n\t  if (array && Array.isArray(array)) {\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      this.add(array[i]);\n\t    }\n\t  }\n\t}\n\t_Set.prototype.add = function (key) {\n\t  return this.store.set(key, true);\n\t};\n\t_Set.prototype.has = function (key) {\n\t  return this.store.has(key);\n\t};\n\t\n\t// We fetch all leafs of the revision tree, and sort them based on tree length\n\t// and whether they were deleted, undeleted documents with the longest revision\n\t// tree (most edits) win\n\t// The final sort algorithm is slightly documented in a sidebar here:\n\t// http://guide.couchdb.org/draft/conflicts.html\n\tfunction winningRev(metadata) {\n\t  var winningId;\n\t  var winningPos;\n\t  var winningDeleted;\n\t  var toVisit = metadata.rev_tree.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var tree = node.ids;\n\t    var branches = tree[2];\n\t    var pos = node.pos;\n\t    if (branches.length) { // non-leaf\n\t      for (var i = 0, len = branches.length; i < len; i++) {\n\t        toVisit.push({pos: pos + 1, ids: branches[i]});\n\t      }\n\t      continue;\n\t    }\n\t    var deleted = !!tree[1].deleted;\n\t    var id = tree[0];\n\t    // sort by deleted, then pos, then id\n\t    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n\t        winningPos !== pos ? winningPos < pos : winningId < id)) {\n\t      winningId = id;\n\t      winningPos = pos;\n\t      winningDeleted = deleted;\n\t    }\n\t  }\n\t\n\t  return winningPos + '-' + winningId;\n\t}\n\t\n\t// Pretty much all below can be combined into a higher order function to\n\t// traverse revisions\n\t// The return value from the callback will be passed as context to all\n\t// children of that node\n\tfunction traverseRevTree(revs, callback) {\n\t  var toVisit = revs.slice();\n\t\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var branches = tree[2];\n\t    var newCtx =\n\t      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n\t    }\n\t  }\n\t}\n\t\n\tfunction sortByPos(a, b) {\n\t  return a.pos - b.pos;\n\t}\n\t\n\tfunction collectLeaves(revs) {\n\t  var leaves = [];\n\t  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n\t    if (isLeaf) {\n\t      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n\t    }\n\t  });\n\t  leaves.sort(sortByPos).reverse();\n\t  for (var i = 0, len = leaves.length; i < len; i++) {\n\t    delete leaves[i].pos;\n\t  }\n\t  return leaves;\n\t}\n\t\n\t// returns revs of all conflicts that is leaves such that\n\t// 1. are not deleted and\n\t// 2. are different than winning revision\n\tfunction collectConflicts(metadata) {\n\t  var win = winningRev(metadata);\n\t  var leaves = collectLeaves(metadata.rev_tree);\n\t  var conflicts = [];\n\t  for (var i = 0, len = leaves.length; i < len; i++) {\n\t    var leaf = leaves[i];\n\t    if (leaf.rev !== win && !leaf.opts.deleted) {\n\t      conflicts.push(leaf.rev);\n\t    }\n\t  }\n\t  return conflicts;\n\t}\n\t\n\t// compact a tree by marking its non-leafs as missing,\n\t// and return a list of revs to delete\n\tfunction compactTree(metadata) {\n\t  var revs = [];\n\t  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                               revHash, ctx, opts) {\n\t    if (opts.status === 'available' && !isLeaf) {\n\t      revs.push(pos + '-' + revHash);\n\t      opts.status = 'missing';\n\t    }\n\t  });\n\t  return revs;\n\t}\n\t\n\t// build up a list of all the paths to the leafs in this revision tree\n\tfunction rootToLeaf(revs) {\n\t  var paths = [];\n\t  var toVisit = revs.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var id = tree[0];\n\t    var opts = tree[1];\n\t    var branches = tree[2];\n\t    var isLeaf = branches.length === 0;\n\t\n\t    var history = node.history ? node.history.slice() : [];\n\t    history.push({id: id, opts: opts});\n\t    if (isLeaf) {\n\t      paths.push({pos: (pos + 1 - history.length), ids: history});\n\t    }\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n\t    }\n\t  }\n\t  return paths.reverse();\n\t}\n\t\n\t// for a better overview of what this is doing, read:\n\t// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n\t//\n\t// But for a quick intro, CouchDB uses a revision tree to store a documents\n\t// history, A -> B -> C, when a document has conflicts, that is a branch in the\n\t// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n\t//\n\t// KeyTree = [Path ... ]\n\t// Path = {pos: position_from_root, ids: Tree}\n\t// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\t\n\tfunction sortByPos$1(a, b) {\n\t  return a.pos - b.pos;\n\t}\n\t\n\t// classic binary search\n\tfunction binarySearch(arr, item, comparator) {\n\t  var low = 0;\n\t  var high = arr.length;\n\t  var mid;\n\t  while (low < high) {\n\t    mid = (low + high) >>> 1;\n\t    if (comparator(arr[mid], item) < 0) {\n\t      low = mid + 1;\n\t    } else {\n\t      high = mid;\n\t    }\n\t  }\n\t  return low;\n\t}\n\t\n\t// assuming the arr is sorted, insert the item in the proper place\n\tfunction insertSorted(arr, item, comparator) {\n\t  var idx = binarySearch(arr, item, comparator);\n\t  arr.splice(idx, 0, item);\n\t}\n\t\n\t// Turn a path as a flat array into a tree with a single branch.\n\t// If any should be stemmed from the beginning of the array, that's passed\n\t// in as the second argument\n\tfunction pathToTree(path, numStemmed) {\n\t  var root;\n\t  var leaf;\n\t  for (var i = numStemmed, len = path.length; i < len; i++) {\n\t    var node = path[i];\n\t    var currentLeaf = [node.id, node.opts, []];\n\t    if (leaf) {\n\t      leaf[2].push(currentLeaf);\n\t      leaf = currentLeaf;\n\t    } else {\n\t      root = leaf = currentLeaf;\n\t    }\n\t  }\n\t  return root;\n\t}\n\t\n\t// compare the IDs of two trees\n\tfunction compareTree(a, b) {\n\t  return a[0] < b[0] ? -1 : 1;\n\t}\n\t\n\t// Merge two trees together\n\t// The roots of tree1 and tree2 must be the same revision\n\tfunction mergeTree(in_tree1, in_tree2) {\n\t  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n\t  var conflicts = false;\n\t  while (queue.length > 0) {\n\t    var item = queue.pop();\n\t    var tree1 = item.tree1;\n\t    var tree2 = item.tree2;\n\t\n\t    if (tree1[1].status || tree2[1].status) {\n\t      tree1[1].status =\n\t        (tree1[1].status ===  'available' ||\n\t        tree2[1].status === 'available') ? 'available' : 'missing';\n\t    }\n\t\n\t    for (var i = 0; i < tree2[2].length; i++) {\n\t      if (!tree1[2][0]) {\n\t        conflicts = 'new_leaf';\n\t        tree1[2][0] = tree2[2][i];\n\t        continue;\n\t      }\n\t\n\t      var merged = false;\n\t      for (var j = 0; j < tree1[2].length; j++) {\n\t        if (tree1[2][j][0] === tree2[2][i][0]) {\n\t          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n\t          merged = true;\n\t        }\n\t      }\n\t      if (!merged) {\n\t        conflicts = 'new_branch';\n\t        insertSorted(tree1[2], tree2[2][i], compareTree);\n\t      }\n\t    }\n\t  }\n\t  return {conflicts: conflicts, tree: in_tree1};\n\t}\n\t\n\tfunction doMerge(tree, path, dontExpand) {\n\t  var restree = [];\n\t  var conflicts = false;\n\t  var merged = false;\n\t  var res;\n\t\n\t  if (!tree.length) {\n\t    return {tree: [path], conflicts: 'new_leaf'};\n\t  }\n\t\n\t  for (var i = 0, len = tree.length; i < len; i++) {\n\t    var branch = tree[i];\n\t    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n\t      // Paths start at the same position and have the same root, so they need\n\t      // merged\n\t      res = mergeTree(branch.ids, path.ids);\n\t      restree.push({pos: branch.pos, ids: res.tree});\n\t      conflicts = conflicts || res.conflicts;\n\t      merged = true;\n\t    } else if (dontExpand !== true) {\n\t      // The paths start at a different position, take the earliest path and\n\t      // traverse up until it as at the same point from root as the path we\n\t      // want to merge.  If the keys match we return the longer path with the\n\t      // other merged After stemming we dont want to expand the trees\n\t\n\t      var t1 = branch.pos < path.pos ? branch : path;\n\t      var t2 = branch.pos < path.pos ? path : branch;\n\t      var diff = t2.pos - t1.pos;\n\t\n\t      var candidateParents = [];\n\t\n\t      var trees = [];\n\t      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n\t      while (trees.length > 0) {\n\t        var item = trees.pop();\n\t        if (item.diff === 0) {\n\t          if (item.ids[0] === t2.ids[0]) {\n\t            candidateParents.push(item);\n\t          }\n\t          continue;\n\t        }\n\t        var elements = item.ids[2];\n\t        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n\t          trees.push({\n\t            ids: elements[j],\n\t            diff: item.diff - 1,\n\t            parent: item.ids,\n\t            parentIdx: j\n\t          });\n\t        }\n\t      }\n\t\n\t      var el = candidateParents[0];\n\t\n\t      if (!el) {\n\t        restree.push(branch);\n\t      } else {\n\t        res = mergeTree(el.ids, t2.ids);\n\t        el.parent[2][el.parentIdx] = res.tree;\n\t        restree.push({pos: t1.pos, ids: t1.ids});\n\t        conflicts = conflicts || res.conflicts;\n\t        merged = true;\n\t      }\n\t    } else {\n\t      restree.push(branch);\n\t    }\n\t  }\n\t\n\t  // We didnt find\n\t  if (!merged) {\n\t    restree.push(path);\n\t  }\n\t\n\t  restree.sort(sortByPos$1);\n\t\n\t  return {\n\t    tree: restree,\n\t    conflicts: conflicts || 'internal_node'\n\t  };\n\t}\n\t\n\t// To ensure we dont grow the revision tree infinitely, we stem old revisions\n\tfunction stem(tree, depth) {\n\t  // First we break out the tree into a complete list of root to leaf paths\n\t  var paths = rootToLeaf(tree);\n\t  var maybeStem = {};\n\t\n\t  var result;\n\t  for (var i = 0, len = paths.length; i < len; i++) {\n\t    // Then for each path, we cut off the start of the path based on the\n\t    // `depth` to stem to, and generate a new set of flat trees\n\t    var path = paths[i];\n\t    var stemmed = path.ids;\n\t    var numStemmed = Math.max(0, stemmed.length - depth);\n\t    var stemmedNode = {\n\t      pos: path.pos + numStemmed,\n\t      ids: pathToTree(stemmed, numStemmed)\n\t    };\n\t\n\t    for (var s = 0; s < numStemmed; s++) {\n\t      var rev = (path.pos + s) + '-' + stemmed[s].id;\n\t      maybeStem[rev] = true;\n\t    }\n\t\n\t    // Then we remerge all those flat trees together, ensuring that we dont\n\t    // connect trees that would go beyond the depth limit\n\t    if (result) {\n\t      result = doMerge(result, stemmedNode, true).tree;\n\t    } else {\n\t      result = [stemmedNode];\n\t    }\n\t  }\n\t\n\t  traverseRevTree(result, function (isLeaf, pos, revHash) {\n\t    // some revisions may have been removed in a branch but not in another\n\t    delete maybeStem[pos + '-' + revHash];\n\t  });\n\t\n\t  return {\n\t    tree: result,\n\t    revs: Object.keys(maybeStem)\n\t  };\n\t}\n\t\n\tfunction merge(tree, path, depth) {\n\t  var newTree = doMerge(tree, path);\n\t  var stemmed = stem(newTree.tree, depth);\n\t  return {\n\t    tree: stemmed.tree,\n\t    stemmedRevs: stemmed.revs,\n\t    conflicts: newTree.conflicts\n\t  };\n\t}\n\t\n\t// return true if a rev exists in the rev tree, false otherwise\n\tfunction revExists(revs, rev) {\n\t  var toVisit = revs.slice();\n\t  var splitRev = rev.split('-');\n\t  var targetPos = parseInt(splitRev[0], 10);\n\t  var targetId = splitRev[1];\n\t\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    if (node.pos === targetPos && node.ids[0] === targetId) {\n\t      return true;\n\t    }\n\t    var branches = node.ids[2];\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\tfunction getTrees(node) {\n\t  return node.ids;\n\t}\n\t\n\t// check if a specific revision of a doc has been deleted\n\t//  - metadata: the metadata object from the doc store\n\t//  - rev: (optional) the revision to check. defaults to winning revision\n\tfunction isDeleted(metadata, rev) {\n\t  if (!rev) {\n\t    rev = winningRev(metadata);\n\t  }\n\t  var id = rev.substring(rev.indexOf('-') + 1);\n\t  var toVisit = metadata.rev_tree.map(getTrees);\n\t\n\t  var tree;\n\t  while ((tree = toVisit.pop())) {\n\t    if (tree[0] === id) {\n\t      return !!tree[1].deleted;\n\t    }\n\t    toVisit = toVisit.concat(tree[2]);\n\t  }\n\t}\n\t\n\tfunction isLocalId(id) {\n\t  return (/^_local/).test(id);\n\t}\n\t\n\tfunction evalFilter(input) {\n\t  return scopedEval('\"use strict\";\\nreturn ' + input + ';', {});\n\t}\n\t\n\tfunction evalView(input) {\n\t  var code = [\n\t    'return function(doc) {',\n\t    '  \"use strict\";',\n\t    '  var emitted = false;',\n\t    '  var emit = function (a, b) {',\n\t    '    emitted = true;',\n\t    '  };',\n\t    '  var view = ' + input + ';',\n\t    '  view(doc);',\n\t    '  if (emitted) {',\n\t    '    return true;',\n\t    '  }',\n\t    '};'\n\t  ].join('\\n');\n\t\n\t  return scopedEval(code, {});\n\t}\n\t\n\tinherits(Changes$1, events.EventEmitter);\n\t\n\tfunction tryCatchInChangeListener(self, change) {\n\t  // isolate try/catches to avoid V8 deoptimizations\n\t  try {\n\t    self.emit('change', change);\n\t  } catch (e) {\n\t    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n\t  }\n\t}\n\t\n\tfunction Changes$1(db, opts, callback) {\n\t  events.EventEmitter.call(this);\n\t  var self = this;\n\t  this.db = db;\n\t  opts = opts ? clone(opts) : {};\n\t  var complete = opts.complete = once(function (err, resp) {\n\t    if (err) {\n\t      if (listenerCount(self, 'error') > 0) {\n\t        self.emit('error', err);\n\t      }\n\t    } else {\n\t      self.emit('complete', resp);\n\t    }\n\t    self.removeAllListeners();\n\t    db.removeListener('destroyed', onDestroy);\n\t  });\n\t  if (callback) {\n\t    self.on('complete', function (resp) {\n\t      callback(null, resp);\n\t    });\n\t    self.on('error', callback);\n\t  }\n\t  function onDestroy() {\n\t    self.cancel();\n\t  }\n\t  db.once('destroyed', onDestroy);\n\t\n\t  opts.onChange = function (change) {\n\t    /* istanbul ignore if */\n\t    if (opts.isCancelled) {\n\t      return;\n\t    }\n\t    tryCatchInChangeListener(self, change);\n\t  };\n\t\n\t  var promise = new PouchPromise(function (fulfill, reject) {\n\t    opts.complete = function (err, res) {\n\t      if (err) {\n\t        reject(err);\n\t      } else {\n\t        fulfill(res);\n\t      }\n\t    };\n\t  });\n\t  self.once('cancel', function () {\n\t    db.removeListener('destroyed', onDestroy);\n\t    opts.complete(null, {status: 'cancelled'});\n\t  });\n\t  this.then = promise.then.bind(promise);\n\t  this['catch'] = promise['catch'].bind(promise);\n\t  this.then(function (result) {\n\t    complete(null, result);\n\t  }, complete);\n\t\n\t\n\t\n\t  if (!db.taskqueue.isReady) {\n\t    db.taskqueue.addTask(function (failed) {\n\t      if (failed) {\n\t        opts.complete(failed);\n\t      } else if (self.isCancelled) {\n\t        self.emit('cancel');\n\t      } else {\n\t        self.doChanges(opts);\n\t      }\n\t    });\n\t  } else {\n\t    self.doChanges(opts);\n\t  }\n\t}\n\tChanges$1.prototype.cancel = function () {\n\t  this.isCancelled = true;\n\t  if (this.db.taskqueue.isReady) {\n\t    this.emit('cancel');\n\t  }\n\t};\n\tfunction processChange(doc, metadata, opts) {\n\t  var changeList = [{rev: doc._rev}];\n\t  if (opts.style === 'all_docs') {\n\t    changeList = collectLeaves(metadata.rev_tree)\n\t    .map(function (x) { return {rev: x.rev}; });\n\t  }\n\t  var change = {\n\t    id: metadata.id,\n\t    changes: changeList,\n\t    doc: doc\n\t  };\n\t\n\t  if (isDeleted(metadata, doc._rev)) {\n\t    change.deleted = true;\n\t  }\n\t  if (opts.conflicts) {\n\t    change.doc._conflicts = collectConflicts(metadata);\n\t    if (!change.doc._conflicts.length) {\n\t      delete change.doc._conflicts;\n\t    }\n\t  }\n\t  return change;\n\t}\n\t\n\tChanges$1.prototype.doChanges = function (opts) {\n\t  var self = this;\n\t  var callback = opts.complete;\n\t\n\t  opts = clone(opts);\n\t  if ('live' in opts && !('continuous' in opts)) {\n\t    opts.continuous = opts.live;\n\t  }\n\t  opts.processChange = processChange;\n\t\n\t  if (opts.since === 'latest') {\n\t    opts.since = 'now';\n\t  }\n\t  if (!opts.since) {\n\t    opts.since = 0;\n\t  }\n\t  if (opts.since === 'now') {\n\t    this.db.info().then(function (info) {\n\t      /* istanbul ignore if */\n\t      if (self.isCancelled) {\n\t        callback(null, {status: 'cancelled'});\n\t        return;\n\t      }\n\t      opts.since = info.update_seq;\n\t      self.doChanges(opts);\n\t    }, callback);\n\t    return;\n\t  }\n\t\n\t\n\t  if (opts.view && !opts.filter) {\n\t    opts.filter = '_view';\n\t  }\n\t\n\t  if (opts.filter && typeof opts.filter === 'string') {\n\t    if (opts.filter === '_view') {\n\t      opts.view = normalizeDesignDocFunctionName(opts.view);\n\t    } else {\n\t      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n\t    }\n\t\n\t    if (this.db.type() !== 'http' && !opts.doc_ids) {\n\t      return this.filterChanges(opts);\n\t    }\n\t  }\n\t\n\t  if (!('descending' in opts)) {\n\t    opts.descending = false;\n\t  }\n\t\n\t  // 0 and 1 should return 1 document\n\t  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n\t  opts.complete = callback;\n\t  var newPromise = this.db._changes(opts);\n\t  /* istanbul ignore else */\n\t  if (newPromise && typeof newPromise.cancel === 'function') {\n\t    var cancel = self.cancel;\n\t    self.cancel = getArguments(function (args) {\n\t      newPromise.cancel();\n\t      cancel.apply(this, args);\n\t    });\n\t  }\n\t};\n\t\n\tChanges$1.prototype.filterChanges = function (opts) {\n\t  var self = this;\n\t  var callback = opts.complete;\n\t  if (opts.filter === '_view') {\n\t    if (!opts.view || typeof opts.view !== 'string') {\n\t      var err = createError(BAD_REQUEST,\n\t        '`view` filter parameter not found or invalid.');\n\t      return callback(err);\n\t    }\n\t    // fetch a view from a design doc, make it behave like a filter\n\t    var viewName = parseDesignDocFunctionName(opts.view);\n\t    this.db.get('_design/' + viewName[0], function (err, ddoc) {\n\t      /* istanbul ignore if */\n\t      if (self.isCancelled) {\n\t        return callback(null, {status: 'cancelled'});\n\t      }\n\t      /* istanbul ignore next */\n\t      if (err) {\n\t        return callback(generateErrorFromResponse(err));\n\t      }\n\t      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n\t        ddoc.views[viewName[1]].map;\n\t      if (!mapFun) {\n\t        return callback(createError(MISSING_DOC,\n\t          (ddoc.views ? 'missing json key: ' + viewName[1] :\n\t            'missing json key: views')));\n\t      }\n\t      opts.filter = evalView(mapFun);\n\t      self.doChanges(opts);\n\t    });\n\t  } else {\n\t    // fetch a filter from a design doc\n\t    var filterName = parseDesignDocFunctionName(opts.filter);\n\t    if (!filterName) {\n\t      return self.doChanges(opts);\n\t    }\n\t    this.db.get('_design/' + filterName[0], function (err, ddoc) {\n\t      /* istanbul ignore if */\n\t      if (self.isCancelled) {\n\t        return callback(null, {status: 'cancelled'});\n\t      }\n\t      /* istanbul ignore next */\n\t      if (err) {\n\t        return callback(generateErrorFromResponse(err));\n\t      }\n\t      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n\t      if (!filterFun) {\n\t        return callback(createError(MISSING_DOC,\n\t          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n\t            : 'missing json key: filters')));\n\t      }\n\t      opts.filter = evalFilter(filterFun);\n\t      self.doChanges(opts);\n\t    });\n\t  }\n\t};\n\t\n\t/*\n\t * A generic pouch adapter\n\t */\n\t\n\tfunction compare(left, right) {\n\t  return left < right ? -1 : left > right ? 1 : 0;\n\t}\n\t\n\t// returns first element of arr satisfying callback predicate\n\tfunction arrayFirst(arr, callback) {\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (callback(arr[i], i) === true) {\n\t      return arr[i];\n\t    }\n\t  }\n\t}\n\t\n\t// Wrapper for functions that call the bulkdocs api with a single doc,\n\t// if the first result is an error, return an error\n\tfunction yankError(callback) {\n\t  return function (err, results) {\n\t    if (err || (results[0] && results[0].error)) {\n\t      callback(err || results[0]);\n\t    } else {\n\t      callback(null, results.length ? results[0]  : results);\n\t    }\n\t  };\n\t}\n\t\n\t// clean docs given to us by the user\n\tfunction cleanDocs(docs) {\n\t  for (var i = 0; i < docs.length; i++) {\n\t    var doc = docs[i];\n\t    if (doc._deleted) {\n\t      delete doc._attachments; // ignore atts for deleted docs\n\t    } else if (doc._attachments) {\n\t      // filter out extraneous keys from _attachments\n\t      var atts = Object.keys(doc._attachments);\n\t      for (var j = 0; j < atts.length; j++) {\n\t        var att = atts[j];\n\t        doc._attachments[att] = pick(doc._attachments[att],\n\t          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// compare two docs, first by _id then by _rev\n\tfunction compareByIdThenRev(a, b) {\n\t  var idCompare = compare(a._id, b._id);\n\t  if (idCompare !== 0) {\n\t    return idCompare;\n\t  }\n\t  var aStart = a._revisions ? a._revisions.start : 0;\n\t  var bStart = b._revisions ? b._revisions.start : 0;\n\t  return compare(aStart, bStart);\n\t}\n\t\n\t// for every node in a revision tree computes its distance from the closest\n\t// leaf\n\tfunction computeHeight(revs) {\n\t  var height = {};\n\t  var edges = [];\n\t  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n\t    var rev = pos + \"-\" + id;\n\t    if (isLeaf) {\n\t      height[rev] = 0;\n\t    }\n\t    if (prnt !== undefined) {\n\t      edges.push({from: prnt, to: rev});\n\t    }\n\t    return rev;\n\t  });\n\t\n\t  edges.reverse();\n\t  edges.forEach(function (edge) {\n\t    if (height[edge.from] === undefined) {\n\t      height[edge.from] = 1 + height[edge.to];\n\t    } else {\n\t      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n\t    }\n\t  });\n\t  return height;\n\t}\n\t\n\tfunction allDocsKeysQuery(api, opts, callback) {\n\t  var keys =  ('limit' in opts) ?\n\t      opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n\t      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n\t  if (opts.descending) {\n\t    keys.reverse();\n\t  }\n\t  if (!keys.length) {\n\t    return api._allDocs({limit: 0}, callback);\n\t  }\n\t  var finalResults = {\n\t    offset: opts.skip\n\t  };\n\t  return PouchPromise.all(keys.map(function (key) {\n\t    var subOpts = extend$1({key: key, deleted: 'ok'}, opts);\n\t    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n\t      delete subOpts[optKey];\n\t    });\n\t    return new PouchPromise(function (resolve, reject) {\n\t      api._allDocs(subOpts, function (err, res) {\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        finalResults.total_rows = res.total_rows;\n\t        resolve(res.rows[0] || {key: key, error: 'not_found'});\n\t      });\n\t    });\n\t  })).then(function (results) {\n\t    finalResults.rows = results;\n\t    return finalResults;\n\t  });\n\t}\n\t\n\t// all compaction is done in a queue, to avoid attaching\n\t// too many listeners at once\n\tfunction doNextCompaction(self) {\n\t  var task = self._compactionQueue[0];\n\t  var opts = task.opts;\n\t  var callback = task.callback;\n\t  self.get('_local/compaction').catch(function () {\n\t    return false;\n\t  }).then(function (doc) {\n\t    if (doc && doc.last_seq) {\n\t      opts.last_seq = doc.last_seq;\n\t    }\n\t    self._compact(opts, function (err, res) {\n\t      /* istanbul ignore if */\n\t      if (err) {\n\t        callback(err);\n\t      } else {\n\t        callback(null, res);\n\t      }\n\t      process.nextTick(function () {\n\t        self._compactionQueue.shift();\n\t        if (self._compactionQueue.length) {\n\t          doNextCompaction(self);\n\t        }\n\t      });\n\t    });\n\t  });\n\t}\n\t\n\tfunction attachmentNameError(name) {\n\t  if (name.charAt(0) === '_') {\n\t    return name + 'is not a valid attachment name, attachment ' +\n\t      'names cannot start with \\'_\\'';\n\t  }\n\t  return false;\n\t}\n\t\n\tinherits(AbstractPouchDB, events.EventEmitter);\n\t\n\tfunction AbstractPouchDB() {\n\t  events.EventEmitter.call(this);\n\t}\n\t\n\tAbstractPouchDB.prototype.post =\n\t  adapterFun('post', function (doc, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof doc !== 'object' || Array.isArray(doc)) {\n\t    return callback(createError(NOT_AN_OBJECT));\n\t  }\n\t  this.bulkDocs({docs: [doc]}, opts, yankError(callback));\n\t});\n\t\n\tAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n\t  if (typeof opts === 'function') {\n\t    cb = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof doc !== 'object' || Array.isArray(doc)) {\n\t    return cb(createError(NOT_AN_OBJECT));\n\t  }\n\t  invalidIdError(doc._id);\n\t  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n\t    if (doc._deleted) {\n\t      return this._removeLocal(doc, cb);\n\t    } else {\n\t      return this._putLocal(doc, cb);\n\t    }\n\t  }\n\t  if (typeof this._put === 'function' && opts.new_edits !== false) {\n\t    this._put(doc, opts, cb);\n\t  } else {\n\t    this.bulkDocs({docs: [doc]}, opts, yankError(cb));\n\t  }\n\t});\n\t\n\tAbstractPouchDB.prototype.putAttachment =\n\t  adapterFun('putAttachment', function (docId, attachmentId, rev,\n\t                                              blob, type) {\n\t  var api = this;\n\t  if (typeof type === 'function') {\n\t    type = blob;\n\t    blob = rev;\n\t    rev = null;\n\t  }\n\t  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n\t  /* istanbul ignore if */\n\t  if (typeof type === 'undefined') {\n\t    type = blob;\n\t    blob = rev;\n\t    rev = null;\n\t  }\n\t\n\t  function createAttachment(doc) {\n\t    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n\t    doc._attachments = doc._attachments || {};\n\t    doc._attachments[attachmentId] = {\n\t      content_type: type,\n\t      data: blob,\n\t      revpos: ++prevrevpos\n\t    };\n\t    return api.put(doc);\n\t  }\n\t\n\t  return api.get(docId).then(function (doc) {\n\t    if (doc._rev !== rev) {\n\t      throw createError(REV_CONFLICT);\n\t    }\n\t\n\t    return createAttachment(doc);\n\t  }, function (err) {\n\t     // create new doc\n\t    /* istanbul ignore else */\n\t    if (err.reason === MISSING_DOC.message) {\n\t      return createAttachment({_id: docId});\n\t    } else {\n\t      throw err;\n\t    }\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.removeAttachment =\n\t  adapterFun('removeAttachment', function (docId, attachmentId, rev,\n\t                                                 callback) {\n\t  var self = this;\n\t  self.get(docId, function (err, obj) {\n\t    /* istanbul ignore if */\n\t    if (err) {\n\t      callback(err);\n\t      return;\n\t    }\n\t    if (obj._rev !== rev) {\n\t      callback(createError(REV_CONFLICT));\n\t      return;\n\t    }\n\t    /* istanbul ignore if */\n\t    if (!obj._attachments) {\n\t      return callback();\n\t    }\n\t    delete obj._attachments[attachmentId];\n\t    if (Object.keys(obj._attachments).length === 0) {\n\t      delete obj._attachments;\n\t    }\n\t    self.put(obj, callback);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.remove =\n\t  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n\t  var doc;\n\t  if (typeof optsOrRev === 'string') {\n\t    // id, rev, opts, callback style\n\t    doc = {\n\t      _id: docOrId,\n\t      _rev: optsOrRev\n\t    };\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t  } else {\n\t    // doc, opts, callback style\n\t    doc = docOrId;\n\t    if (typeof optsOrRev === 'function') {\n\t      callback = optsOrRev;\n\t      opts = {};\n\t    } else {\n\t      callback = opts;\n\t      opts = optsOrRev;\n\t    }\n\t  }\n\t  opts = opts || {};\n\t  opts.was_delete = true;\n\t  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n\t  newDoc._deleted = true;\n\t  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n\t    return this._removeLocal(doc, callback);\n\t  }\n\t  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n\t});\n\t\n\tAbstractPouchDB.prototype.revsDiff =\n\t  adapterFun('revsDiff', function (req, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  var ids = Object.keys(req);\n\t\n\t  if (!ids.length) {\n\t    return callback(null, {});\n\t  }\n\t\n\t  var count = 0;\n\t  var missing = new _Map();\n\t\n\t  function addToMissing(id, revId) {\n\t    if (!missing.has(id)) {\n\t      missing.set(id, {missing: []});\n\t    }\n\t    missing.get(id).missing.push(revId);\n\t  }\n\t\n\t  function processDoc(id, rev_tree) {\n\t    // Is this fast enough? Maybe we should switch to a set simulated by a map\n\t    var missingForId = req[id].slice(0);\n\t    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n\t      opts) {\n\t        var rev = pos + '-' + revHash;\n\t        var idx = missingForId.indexOf(rev);\n\t        if (idx === -1) {\n\t          return;\n\t        }\n\t\n\t        missingForId.splice(idx, 1);\n\t        /* istanbul ignore if */\n\t        if (opts.status !== 'available') {\n\t          addToMissing(id, rev);\n\t        }\n\t      });\n\t\n\t    // Traversing the tree is synchronous, so now `missingForId` contains\n\t    // revisions that were not found in the tree\n\t    missingForId.forEach(function (rev) {\n\t      addToMissing(id, rev);\n\t    });\n\t  }\n\t\n\t  ids.map(function (id) {\n\t    this._getRevisionTree(id, function (err, rev_tree) {\n\t      if (err && err.status === 404 && err.message === 'missing') {\n\t        missing.set(id, {missing: req[id]});\n\t      } else if (err) {\n\t        /* istanbul ignore next */\n\t        return callback(err);\n\t      } else {\n\t        processDoc(id, rev_tree);\n\t      }\n\t\n\t      if (++count === ids.length) {\n\t        // convert LazyMap to object\n\t        var missingObj = {};\n\t        missing.forEach(function (value, key) {\n\t          missingObj[key] = value;\n\t        });\n\t        return callback(null, missingObj);\n\t      }\n\t    });\n\t  }, this);\n\t});\n\t\n\t// _bulk_get API for faster replication, as described in\n\t// https://github.com/apache/couchdb-chttpd/pull/33\n\t// At the \"abstract\" level, it will just run multiple get()s in\n\t// parallel, because this isn't much of a performance cost\n\t// for local databases (except the cost of multiple transactions, which is\n\t// small). The http adapter overrides this in order\n\t// to do a more efficient single HTTP request.\n\tAbstractPouchDB.prototype.bulkGet =\n\t  adapterFun('bulkGet', function (opts, callback) {\n\t  bulkGet(this, opts, callback);\n\t});\n\t\n\t// compact one document and fire callback\n\t// by compacting we mean removing all revisions which\n\t// are further from the leaf in revision tree than max_height\n\tAbstractPouchDB.prototype.compactDocument =\n\t  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n\t  var self = this;\n\t  this._getRevisionTree(docId, function (err, revTree) {\n\t    /* istanbul ignore if */\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    var height = computeHeight(revTree);\n\t    var candidates = [];\n\t    var revs = [];\n\t    Object.keys(height).forEach(function (rev) {\n\t      if (height[rev] > maxHeight) {\n\t        candidates.push(rev);\n\t      }\n\t    });\n\t\n\t    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n\t      var rev = pos + '-' + revHash;\n\t      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n\t        revs.push(rev);\n\t      }\n\t    });\n\t    self._doCompaction(docId, revs, callback);\n\t  });\n\t});\n\t\n\t// compact the whole database using single document\n\t// compaction\n\tAbstractPouchDB.prototype.compact =\n\t  adapterFun('compact', function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  var self = this;\n\t  opts = opts || {};\n\t\n\t  self._compactionQueue = self._compactionQueue || [];\n\t  self._compactionQueue.push({opts: opts, callback: callback});\n\t  if (self._compactionQueue.length === 1) {\n\t    doNextCompaction(self);\n\t  }\n\t});\n\tAbstractPouchDB.prototype._compact = function (opts, callback) {\n\t  var self = this;\n\t  var changesOpts = {\n\t    return_docs: false,\n\t    last_seq: opts.last_seq || 0\n\t  };\n\t  var promises = [];\n\t\n\t  function onChange(row) {\n\t    promises.push(self.compactDocument(row.id, 0));\n\t  }\n\t  function onComplete(resp) {\n\t    var lastSeq = resp.last_seq;\n\t    PouchPromise.all(promises).then(function () {\n\t      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n\t        if (!doc.last_seq || doc.last_seq < lastSeq) {\n\t          doc.last_seq = lastSeq;\n\t          return doc;\n\t        }\n\t        return false; // somebody else got here first, don't update\n\t      });\n\t    }).then(function () {\n\t      callback(null, {ok: true});\n\t    }).catch(callback);\n\t  }\n\t  self.changes(changesOpts)\n\t    .on('change', onChange)\n\t    .on('complete', onComplete)\n\t    .on('error', callback);\n\t};\n\t\n\t/* Begin api wrappers. Specific functionality to storage belongs in the\n\t   _[method] */\n\tAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n\t  if (typeof opts === 'function') {\n\t    cb = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof id !== 'string') {\n\t    return cb(createError(INVALID_ID));\n\t  }\n\t  if (isLocalId(id) && typeof this._getLocal === 'function') {\n\t    return this._getLocal(id, cb);\n\t  }\n\t  var leaves = [], self = this;\n\t\n\t  function finishOpenRevs() {\n\t    var result = [];\n\t    var count = leaves.length;\n\t    /* istanbul ignore if */\n\t    if (!count) {\n\t      return cb(null, result);\n\t    }\n\t    // order with open_revs is unspecified\n\t    leaves.forEach(function (leaf) {\n\t      self.get(id, {\n\t        rev: leaf,\n\t        revs: opts.revs,\n\t        attachments: opts.attachments\n\t      }, function (err, doc) {\n\t        if (!err) {\n\t          result.push({ok: doc});\n\t        } else {\n\t          result.push({missing: leaf});\n\t        }\n\t        count--;\n\t        if (!count) {\n\t          cb(null, result);\n\t        }\n\t      });\n\t    });\n\t  }\n\t\n\t  if (opts.open_revs) {\n\t    if (opts.open_revs === \"all\") {\n\t      this._getRevisionTree(id, function (err, rev_tree) {\n\t        if (err) {\n\t          return cb(err);\n\t        }\n\t        leaves = collectLeaves(rev_tree).map(function (leaf) {\n\t          return leaf.rev;\n\t        });\n\t        finishOpenRevs();\n\t      });\n\t    } else {\n\t      if (Array.isArray(opts.open_revs)) {\n\t        leaves = opts.open_revs;\n\t        for (var i = 0; i < leaves.length; i++) {\n\t          var l = leaves[i];\n\t          // looks like it's the only thing couchdb checks\n\t          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n\t            return cb(createError(INVALID_REV));\n\t          }\n\t        }\n\t        finishOpenRevs();\n\t      } else {\n\t        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n\t      }\n\t    }\n\t    return; // open_revs does not like other options\n\t  }\n\t\n\t  return this._get(id, opts, function (err, result) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    var doc = result.doc;\n\t    var metadata = result.metadata;\n\t    var ctx = result.ctx;\n\t\n\t    if (opts.conflicts) {\n\t      var conflicts = collectConflicts(metadata);\n\t      if (conflicts.length) {\n\t        doc._conflicts = conflicts;\n\t      }\n\t    }\n\t\n\t    if (isDeleted(metadata, doc._rev)) {\n\t      doc._deleted = true;\n\t    }\n\t\n\t    if (opts.revs || opts.revs_info) {\n\t      var paths = rootToLeaf(metadata.rev_tree);\n\t      var path = arrayFirst(paths, function (arr) {\n\t        return arr.ids.map(function (x) { return x.id; })\n\t          .indexOf(doc._rev.split('-')[1]) !== -1;\n\t      });\n\t\n\t      var indexOfRev = path.ids.map(function (x) {return x.id; })\n\t        .indexOf(doc._rev.split('-')[1]) + 1;\n\t      var howMany = path.ids.length - indexOfRev;\n\t      path.ids.splice(indexOfRev, howMany);\n\t      path.ids.reverse();\n\t\n\t      if (opts.revs) {\n\t        doc._revisions = {\n\t          start: (path.pos + path.ids.length) - 1,\n\t          ids: path.ids.map(function (rev) {\n\t            return rev.id;\n\t          })\n\t        };\n\t      }\n\t      if (opts.revs_info) {\n\t        var pos =  path.pos + path.ids.length;\n\t        doc._revs_info = path.ids.map(function (rev) {\n\t          pos--;\n\t          return {\n\t            rev: pos + '-' + rev.id,\n\t            status: rev.opts.status\n\t          };\n\t        });\n\t      }\n\t    }\n\t\n\t    if (opts.attachments && doc._attachments) {\n\t      var attachments = doc._attachments;\n\t      var count = Object.keys(attachments).length;\n\t      if (count === 0) {\n\t        return cb(null, doc);\n\t      }\n\t      Object.keys(attachments).forEach(function (key) {\n\t        this._getAttachment(doc._id, key, attachments[key], {\n\t          // Previously the revision handling was done in adapter.js\n\t          // getAttachment, however since idb-next doesnt we need to\n\t          // pass the rev through\n\t          rev: doc._rev,\n\t          binary: opts.binary,\n\t          ctx: ctx\n\t        }, function (err, data) {\n\t          var att = doc._attachments[key];\n\t          att.data = data;\n\t          delete att.stub;\n\t          delete att.length;\n\t          if (!--count) {\n\t            cb(null, doc);\n\t          }\n\t        });\n\t      }, self);\n\t    } else {\n\t      if (doc._attachments) {\n\t        for (var key in doc._attachments) {\n\t          /* istanbul ignore else */\n\t          if (doc._attachments.hasOwnProperty(key)) {\n\t            doc._attachments[key].stub = true;\n\t          }\n\t        }\n\t      }\n\t      cb(null, doc);\n\t    }\n\t  });\n\t});\n\t\n\t// TODO: I dont like this, it forces an extra read for every\n\t// attachment read and enforces a confusing api between\n\t// adapter.js and the adapter implementation\n\tAbstractPouchDB.prototype.getAttachment =\n\t  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n\t  var self = this;\n\t  if (opts instanceof Function) {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  this._get(docId, opts, function (err, res) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n\t      opts.ctx = res.ctx;\n\t      opts.binary = true;\n\t      self._getAttachment(docId, attachmentId,\n\t                          res.doc._attachments[attachmentId], opts, callback);\n\t    } else {\n\t      return callback(createError(MISSING_DOC));\n\t    }\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.allDocs =\n\t  adapterFun('allDocs', function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n\t  if (opts.start_key) {\n\t    opts.startkey = opts.start_key;\n\t  }\n\t  if (opts.end_key) {\n\t    opts.endkey = opts.end_key;\n\t  }\n\t  if ('keys' in opts) {\n\t    if (!Array.isArray(opts.keys)) {\n\t      return callback(new TypeError('options.keys must be an array'));\n\t    }\n\t    var incompatibleOpt =\n\t      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n\t      return incompatibleOpt in opts;\n\t    })[0];\n\t    if (incompatibleOpt) {\n\t      callback(createError(QUERY_PARSE_ERROR,\n\t        'Query parameter `' + incompatibleOpt +\n\t        '` is not compatible with multi-get'\n\t      ));\n\t      return;\n\t    }\n\t    if (this.type() !== 'http') {\n\t      return allDocsKeysQuery(this, opts, callback);\n\t    }\n\t  }\n\t\n\t  return this._allDocs(opts, callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.changes = function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  return new Changes$1(this, opts, callback);\n\t};\n\t\n\tAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n\t  this._closed = true;\n\t  return this._close(callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n\t  var self = this;\n\t  this._info(function (err, info) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    // assume we know better than the adapter, unless it informs us\n\t    info.db_name = info.db_name || self.name;\n\t    info.auto_compaction = !!(self.auto_compaction && self.type() !== 'http');\n\t    info.adapter = self.type();\n\t    callback(null, info);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n\t  return this._id(callback);\n\t});\n\t\n\t/* istanbul ignore next */\n\tAbstractPouchDB.prototype.type = function () {\n\t  return (typeof this._type === 'function') ? this._type() : this.adapter;\n\t};\n\t\n\tAbstractPouchDB.prototype.bulkDocs =\n\t  adapterFun('bulkDocs', function (req, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  opts = opts || {};\n\t\n\t  if (Array.isArray(req)) {\n\t    req = {\n\t      docs: req\n\t    };\n\t  }\n\t\n\t  if (!req || !req.docs || !Array.isArray(req.docs)) {\n\t    return callback(createError(MISSING_BULK_DOCS));\n\t  }\n\t\n\t  for (var i = 0; i < req.docs.length; ++i) {\n\t    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n\t      return callback(createError(NOT_AN_OBJECT));\n\t    }\n\t  }\n\t\n\t  var attachmentError;\n\t  req.docs.forEach(function (doc) {\n\t    if (doc._attachments) {\n\t      Object.keys(doc._attachments).forEach(function (name) {\n\t        attachmentError = attachmentError || attachmentNameError(name);\n\t      });\n\t    }\n\t  });\n\t\n\t  if (attachmentError) {\n\t    return callback(createError(BAD_REQUEST, attachmentError));\n\t  }\n\t\n\t  if (!('new_edits' in opts)) {\n\t    if ('new_edits' in req) {\n\t      opts.new_edits = req.new_edits;\n\t    } else {\n\t      opts.new_edits = true;\n\t    }\n\t  }\n\t\n\t  if (!opts.new_edits && this.type() !== 'http') {\n\t    // ensure revisions of the same doc are sorted, so that\n\t    // the local adapter processes them correctly (#2935)\n\t    req.docs.sort(compareByIdThenRev);\n\t  }\n\t\n\t  cleanDocs(req.docs);\n\t\n\t  return this._bulkDocs(req, opts, function (err, res) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    if (!opts.new_edits) {\n\t      // this is what couch does when new_edits is false\n\t      res = res.filter(function (x) {\n\t        return x.error;\n\t      });\n\t    }\n\t    callback(null, res);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.registerDependentDatabase =\n\t  adapterFun('registerDependentDatabase', function (dependentDb,\n\t                                                          callback) {\n\t  var depDB = new this.constructor(dependentDb, this.__opts);\n\t\n\t  function diffFun(doc) {\n\t    doc.dependentDbs = doc.dependentDbs || {};\n\t    if (doc.dependentDbs[dependentDb]) {\n\t      return false; // no update required\n\t    }\n\t    doc.dependentDbs[dependentDb] = true;\n\t    return doc;\n\t  }\n\t  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n\t    .then(function () {\n\t      callback(null, {db: depDB});\n\t    }).catch(callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.destroy =\n\t  adapterFun('destroy', function (opts, callback) {\n\t\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  var self = this;\n\t  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\t\n\t  function destroyDb() {\n\t    // call destroy method of the particular adaptor\n\t    self._destroy(opts, function (err, resp) {\n\t      if (err) {\n\t        return callback(err);\n\t      }\n\t      self._destroyed = true;\n\t      self.emit('destroyed');\n\t      callback(null, resp || { 'ok': true });\n\t    });\n\t  }\n\t\n\t  if (self.type() === 'http') {\n\t    // no need to check for dependent DBs if it's a remote DB\n\t    return destroyDb();\n\t  }\n\t\n\t  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n\t    if (err) {\n\t      /* istanbul ignore if */\n\t      if (err.status !== 404) {\n\t        return callback(err);\n\t      } else { // no dependencies\n\t        return destroyDb();\n\t      }\n\t    }\n\t    var dependentDbs = localDoc.dependentDbs;\n\t    var PouchDB = self.constructor;\n\t    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n\t      // use_prefix is only false in the browser\n\t      /* istanbul ignore next */\n\t      var trueName = usePrefix ?\n\t        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n\t      return new PouchDB(trueName, self.__opts).destroy();\n\t    });\n\t    PouchPromise.all(deletedMap).then(destroyDb, callback);\n\t  });\n\t});\n\t\n\tfunction TaskQueue() {\n\t  this.isReady = false;\n\t  this.failed = false;\n\t  this.queue = [];\n\t}\n\t\n\tTaskQueue.prototype.execute = function () {\n\t  var fun;\n\t  if (this.failed) {\n\t    while ((fun = this.queue.shift())) {\n\t      fun(this.failed);\n\t    }\n\t  } else {\n\t    while ((fun = this.queue.shift())) {\n\t      fun();\n\t    }\n\t  }\n\t};\n\t\n\tTaskQueue.prototype.fail = function (err) {\n\t  this.failed = err;\n\t  this.execute();\n\t};\n\t\n\tTaskQueue.prototype.ready = function (db) {\n\t  this.isReady = true;\n\t  this.db = db;\n\t  this.execute();\n\t};\n\t\n\tTaskQueue.prototype.addTask = function (fun) {\n\t  this.queue.push(fun);\n\t  if (this.failed) {\n\t    this.execute();\n\t  }\n\t};\n\t\n\tfunction parseAdapter(name, opts) {\n\t  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\n\t  if (match) {\n\t    // the http adapter expects the fully qualified name\n\t    name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];\n\t    return {name: name, adapter: match[1]};\n\t  }\n\t\n\t  // check for browsers that have been upgraded from websql-only to websql+idb\n\t  var skipIdb = 'idb' in PouchDB.adapters && 'websql' in PouchDB.adapters &&\n\t    hasLocalStorage() &&\n\t    localStorage['_pouch__websqldb_' + PouchDB.prefix + name];\n\t\n\t  var adapterName;\n\t\n\t  if (opts.adapter) {\n\t    adapterName = opts.adapter;\n\t  } else if (typeof opts !== 'undefined' && opts.db) {\n\t    adapterName = 'leveldb';\n\t  } else { // automatically determine adapter\n\t    for (var i = 0; i < PouchDB.preferredAdapters.length; ++i) {\n\t      adapterName = PouchDB.preferredAdapters[i];\n\t      /* istanbul ignore if */\n\t      if (skipIdb && adapterName === 'idb') {\n\t        // log it, because this can be confusing during development\n\t        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n\t          ' avoid data loss, because it was already opened with WebSQL.');\n\t        continue; // keep using websql to avoid user data loss\n\t      }\n\t      break;\n\t    }\n\t  }\n\t\n\t  var adapter = PouchDB.adapters[adapterName];\n\t\n\t  // if adapter is invalid, then an error will be thrown later\n\t  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n\t    adapter.use_prefix : true;\n\t\n\t  return {\n\t    name: usePrefix ? (PouchDB.prefix + name) : name,\n\t    adapter: adapterName\n\t  };\n\t}\n\t\n\t// OK, so here's the deal. Consider this code:\n\t//     var db1 = new PouchDB('foo');\n\t//     var db2 = new PouchDB('foo');\n\t//     db1.destroy();\n\t// ^ these two both need to emit 'destroyed' events,\n\t// as well as the PouchDB constructor itself.\n\t// So we have one db object (whichever one got destroy() called on it)\n\t// responsible for emitting the initial event, which then gets emitted\n\t// by the constructor, which then broadcasts it to any other dbs\n\t// that may have been created with the same name.\n\tfunction prepareForDestruction(self) {\n\t\n\t  var destructionListeners = self.constructor._destructionListeners;\n\t\n\t  function onDestroyed() {\n\t    self.constructor.emit('destroyed', self.name);\n\t  }\n\t\n\t  function onConstructorDestroyed() {\n\t    self.removeListener('destroyed', onDestroyed);\n\t    self.emit('destroyed', self);\n\t  }\n\t\n\t  self.once('destroyed', onDestroyed);\n\t\n\t  // in setup.js, the constructor is primed to listen for destroy events\n\t  if (!destructionListeners.has(self.name)) {\n\t    destructionListeners.set(self.name, []);\n\t  }\n\t  destructionListeners.get(self.name).push(onConstructorDestroyed);\n\t}\n\t\n\tinherits(PouchDB, AbstractPouchDB);\n\tfunction PouchDB(name, opts) {\n\t  // In Node our test suite only tests this for PouchAlt unfortunately\n\t  /* istanbul ignore if */\n\t  if (!(this instanceof PouchDB)) {\n\t    return new PouchDB(name, opts);\n\t  }\n\t\n\t  var self = this;\n\t  opts = opts || {};\n\t\n\t  if (name && typeof name === 'object') {\n\t    opts = name;\n\t    name = opts.name;\n\t    delete opts.name;\n\t  }\n\t\n\t  this.__opts = opts = clone(opts);\n\t\n\t  self.auto_compaction = opts.auto_compaction;\n\t  self.prefix = PouchDB.prefix;\n\t\n\t  if (typeof name !== 'string') {\n\t    throw new Error('Missing/invalid DB name');\n\t  }\n\t\n\t  var prefixedName = (opts.prefix || '') + name;\n\t  var backend = parseAdapter(prefixedName, opts);\n\t\n\t  opts.name = backend.name;\n\t  opts.adapter = opts.adapter || backend.adapter;\n\t\n\t  self.name = name;\n\t  self._adapter = opts.adapter;\n\t  debug('pouchdb:adapter')('Picked adapter: ' + opts.adapter);\n\t\n\t  if (!PouchDB.adapters[opts.adapter] ||\n\t      !PouchDB.adapters[opts.adapter].valid()) {\n\t    throw new Error('Invalid Adapter: ' + opts.adapter);\n\t  }\n\t\n\t  AbstractPouchDB.call(self);\n\t  self.taskqueue = new TaskQueue();\n\t\n\t  self.adapter = opts.adapter;\n\t\n\t  PouchDB.adapters[opts.adapter].call(self, opts, function (err) {\n\t    if (err) {\n\t      return self.taskqueue.fail(err);\n\t    }\n\t    prepareForDestruction(self);\n\t\n\t    self.emit('created', self);\n\t    PouchDB.emit('created', self.name);\n\t    self.taskqueue.ready(self);\n\t  });\n\t\n\t}\n\t\n\tPouchDB.debug = debug;\n\t\n\tPouchDB.adapters = {};\n\tPouchDB.preferredAdapters = [];\n\t\n\tPouchDB.prefix = '_pouch_';\n\t\n\tvar eventEmitter = new events.EventEmitter();\n\t\n\tfunction setUpEventEmitter(Pouch) {\n\t  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n\t    if (typeof events.EventEmitter.prototype[key] === 'function') {\n\t      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n\t    }\n\t  });\n\t\n\t  // these are created in constructor.js, and allow us to notify each DB with\n\t  // the same name that it was destroyed, via the constructor object\n\t  var destructListeners = Pouch._destructionListeners = new _Map();\n\t  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n\t    destructListeners.get(name).forEach(function (callback) {\n\t      callback();\n\t    });\n\t    destructListeners.delete(name);\n\t  });\n\t}\n\t\n\tsetUpEventEmitter(PouchDB);\n\t\n\tPouchDB.adapter = function (id, obj, addToPreferredAdapters) {\n\t  /* istanbul ignore else */\n\t  if (obj.valid()) {\n\t    PouchDB.adapters[id] = obj;\n\t    if (addToPreferredAdapters) {\n\t      PouchDB.preferredAdapters.push(id);\n\t    }\n\t  }\n\t};\n\t\n\tPouchDB.plugin = function (obj) {\n\t  if (typeof obj === 'function') { // function style for plugins\n\t    obj(PouchDB);\n\t  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0){\n\t    throw new Error('Invalid plugin: object passed in is empty or not an object');\n\t  } else {\n\t    Object.keys(obj).forEach(function (id) { // object style for plugins\n\t      PouchDB.prototype[id] = obj[id];\n\t    });\n\t  }\n\t  return PouchDB;\n\t};\n\t\n\tPouchDB.defaults = function (defaultOpts) {\n\t  function PouchAlt(name, opts) {\n\t    if (!(this instanceof PouchAlt)) {\n\t      return new PouchAlt(name, opts);\n\t    }\n\t\n\t    opts = opts || {};\n\t\n\t    if (name && typeof name === 'object') {\n\t      opts = name;\n\t      name = opts.name;\n\t      delete opts.name;\n\t    }\n\t\n\t    opts = extend$1({}, defaultOpts, opts);\n\t    PouchDB.call(this, name, opts);\n\t  }\n\t\n\t  inherits(PouchAlt, PouchDB);\n\t\n\t  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();\n\t  Object.keys(PouchDB).forEach(function (key) {\n\t    if (!(key in PouchAlt)) {\n\t      PouchAlt[key] = PouchDB[key];\n\t    }\n\t  });\n\t\n\t  return PouchAlt;\n\t};\n\t\n\t// managed automatically by set-version.js\n\tvar version = \"6.0.7\";\n\t\n\tPouchDB.version = version;\n\t\n\tfunction toObject(array) {\n\t  return array.reduce(function (obj, item) {\n\t    obj[item] = true;\n\t    return obj;\n\t  }, {});\n\t}\n\t// List of top level reserved words for doc\n\tvar reservedWords = toObject([\n\t  '_id',\n\t  '_rev',\n\t  '_attachments',\n\t  '_deleted',\n\t  '_revisions',\n\t  '_revs_info',\n\t  '_conflicts',\n\t  '_deleted_conflicts',\n\t  '_local_seq',\n\t  '_rev_tree',\n\t  //replication documents\n\t  '_replication_id',\n\t  '_replication_state',\n\t  '_replication_state_time',\n\t  '_replication_state_reason',\n\t  '_replication_stats',\n\t  // Specific to Couchbase Sync Gateway\n\t  '_removed'\n\t]);\n\t\n\t// List of reserved words that should end up the document\n\tvar dataWords = toObject([\n\t  '_attachments',\n\t  //replication documents\n\t  '_replication_id',\n\t  '_replication_state',\n\t  '_replication_state_time',\n\t  '_replication_state_reason',\n\t  '_replication_stats'\n\t]);\n\t\n\tfunction parseRevisionInfo(rev) {\n\t  if (!/^\\d+\\-./.test(rev)) {\n\t    return createError(INVALID_REV);\n\t  }\n\t  var idx = rev.indexOf('-');\n\t  var left = rev.substring(0, idx);\n\t  var right = rev.substring(idx + 1);\n\t  return {\n\t    prefix: parseInt(left, 10),\n\t    id: right\n\t  };\n\t}\n\t\n\tfunction makeRevTreeFromRevisions(revisions, opts) {\n\t  var pos = revisions.start - revisions.ids.length + 1;\n\t\n\t  var revisionIds = revisions.ids;\n\t  var ids = [revisionIds[0], opts, []];\n\t\n\t  for (var i = 1, len = revisionIds.length; i < len; i++) {\n\t    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n\t  }\n\t\n\t  return [{\n\t    pos: pos,\n\t    ids: ids\n\t  }];\n\t}\n\t\n\t// Preprocess documents, parse their revisions, assign an id and a\n\t// revision for new writes that are missing them, etc\n\tfunction parseDoc(doc, newEdits) {\n\t\n\t  var nRevNum;\n\t  var newRevId;\n\t  var revInfo;\n\t  var opts = {status: 'available'};\n\t  if (doc._deleted) {\n\t    opts.deleted = true;\n\t  }\n\t\n\t  if (newEdits) {\n\t    if (!doc._id) {\n\t      doc._id = uuid();\n\t    }\n\t    newRevId = uuid(32, 16).toLowerCase();\n\t    if (doc._rev) {\n\t      revInfo = parseRevisionInfo(doc._rev);\n\t      if (revInfo.error) {\n\t        return revInfo;\n\t      }\n\t      doc._rev_tree = [{\n\t        pos: revInfo.prefix,\n\t        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n\t      }];\n\t      nRevNum = revInfo.prefix + 1;\n\t    } else {\n\t      doc._rev_tree = [{\n\t        pos: 1,\n\t        ids : [newRevId, opts, []]\n\t      }];\n\t      nRevNum = 1;\n\t    }\n\t  } else {\n\t    if (doc._revisions) {\n\t      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n\t      nRevNum = doc._revisions.start;\n\t      newRevId = doc._revisions.ids[0];\n\t    }\n\t    if (!doc._rev_tree) {\n\t      revInfo = parseRevisionInfo(doc._rev);\n\t      if (revInfo.error) {\n\t        return revInfo;\n\t      }\n\t      nRevNum = revInfo.prefix;\n\t      newRevId = revInfo.id;\n\t      doc._rev_tree = [{\n\t        pos: nRevNum,\n\t        ids: [newRevId, opts, []]\n\t      }];\n\t    }\n\t  }\n\t\n\t  invalidIdError(doc._id);\n\t\n\t  doc._rev = nRevNum + '-' + newRevId;\n\t\n\t  var result = {metadata : {}, data : {}};\n\t  for (var key in doc) {\n\t    /* istanbul ignore else */\n\t    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n\t      var specialKey = key[0] === '_';\n\t      if (specialKey && !reservedWords[key]) {\n\t        var error = createError(DOC_VALIDATION, key);\n\t        error.message = DOC_VALIDATION.message + ': ' + key;\n\t        throw error;\n\t      } else if (specialKey && !dataWords[key]) {\n\t        result.metadata[key.slice(1)] = doc[key];\n\t      } else {\n\t        result.data[key] = doc[key];\n\t      }\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tvar atob$1 = function (str) {\n\t  return atob(str);\n\t};\n\t\n\tvar btoa$1 = function (str) {\n\t  return btoa(str);\n\t};\n\t\n\t// Abstracts constructing a Blob object, so it also works in older\n\t// browsers that don't support the native Blob constructor (e.g.\n\t// old QtWebKit versions, Android < 4.4).\n\tfunction createBlob(parts, properties) {\n\t  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n\t  parts = parts || [];\n\t  properties = properties || {};\n\t  try {\n\t    return new Blob(parts, properties);\n\t  } catch (e) {\n\t    if (e.name !== \"TypeError\") {\n\t      throw e;\n\t    }\n\t    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n\t                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n\t                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n\t                  WebKitBlobBuilder;\n\t    var builder = new Builder();\n\t    for (var i = 0; i < parts.length; i += 1) {\n\t      builder.append(parts[i]);\n\t    }\n\t    return builder.getBlob(properties.type);\n\t  }\n\t}\n\t\n\t// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n\t// encode-decode-image-with-base64-breaks-image (2013-04-21)\n\tfunction binaryStringToArrayBuffer(bin) {\n\t  var length = bin.length;\n\t  var buf = new ArrayBuffer(length);\n\t  var arr = new Uint8Array(buf);\n\t  for (var i = 0; i < length; i++) {\n\t    arr[i] = bin.charCodeAt(i);\n\t  }\n\t  return buf;\n\t}\n\t\n\tfunction binStringToBluffer(binString, type) {\n\t  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n\t}\n\t\n\tfunction b64ToBluffer(b64, type) {\n\t  return binStringToBluffer(atob$1(b64), type);\n\t}\n\t\n\t//Can't find original post, but this is close\n\t//http://stackoverflow.com/questions/6965107/ (continues on next line)\n\t//converting-between-strings-and-arraybuffers\n\tfunction arrayBufferToBinaryString(buffer) {\n\t  var binary = '';\n\t  var bytes = new Uint8Array(buffer);\n\t  var length = bytes.byteLength;\n\t  for (var i = 0; i < length; i++) {\n\t    binary += String.fromCharCode(bytes[i]);\n\t  }\n\t  return binary;\n\t}\n\t\n\t// shim for browsers that don't support it\n\tfunction readAsBinaryString(blob, callback) {\n\t  if (typeof FileReader === 'undefined') {\n\t    // fix for Firefox in a web worker\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n\t    return callback(arrayBufferToBinaryString(\n\t      new FileReaderSync().readAsArrayBuffer(blob)));\n\t  }\n\t\n\t  var reader = new FileReader();\n\t  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n\t  reader.onloadend = function (e) {\n\t    var result = e.target.result || '';\n\t    if (hasBinaryString) {\n\t      return callback(result);\n\t    }\n\t    callback(arrayBufferToBinaryString(result));\n\t  };\n\t  if (hasBinaryString) {\n\t    reader.readAsBinaryString(blob);\n\t  } else {\n\t    reader.readAsArrayBuffer(blob);\n\t  }\n\t}\n\t\n\tfunction blobToBinaryString(blobOrBuffer, callback) {\n\t  readAsBinaryString(blobOrBuffer, function (bin) {\n\t    callback(bin);\n\t  });\n\t}\n\t\n\tfunction blobToBase64(blobOrBuffer, callback) {\n\t  blobToBinaryString(blobOrBuffer, function (base64) {\n\t    callback(btoa$1(base64));\n\t  });\n\t}\n\t\n\t// simplified API. universal browser support is assumed\n\tfunction readAsArrayBuffer(blob, callback) {\n\t  if (typeof FileReader === 'undefined') {\n\t    // fix for Firefox in a web worker:\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n\t    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n\t  }\n\t\n\t  var reader = new FileReader();\n\t  reader.onloadend = function (e) {\n\t    var result = e.target.result || new ArrayBuffer(0);\n\t    callback(result);\n\t  };\n\t  reader.readAsArrayBuffer(blob);\n\t}\n\t\n\tvar setImmediateShim = global.setImmediate || global.setTimeout;\n\tvar MD5_CHUNK_SIZE = 32768;\n\t\n\tfunction rawToBase64(raw) {\n\t  return btoa$1(raw);\n\t}\n\t\n\tfunction sliceBlob(blob, start, end) {\n\t  if (blob.webkitSlice) {\n\t    return blob.webkitSlice(start, end);\n\t  }\n\t  return blob.slice(start, end);\n\t}\n\t\n\tfunction appendBlob(buffer, blob, start, end, callback) {\n\t  if (start > 0 || end < blob.size) {\n\t    // only slice blob if we really need to\n\t    blob = sliceBlob(blob, start, end);\n\t  }\n\t  readAsArrayBuffer(blob, function (arrayBuffer) {\n\t    buffer.append(arrayBuffer);\n\t    callback();\n\t  });\n\t}\n\t\n\tfunction appendString(buffer, string, start, end, callback) {\n\t  if (start > 0 || end < string.length) {\n\t    // only create a substring if we really need to\n\t    string = string.substring(start, end);\n\t  }\n\t  buffer.appendBinary(string);\n\t  callback();\n\t}\n\t\n\tfunction binaryMd5(data, callback) {\n\t  var inputIsString = typeof data === 'string';\n\t  var len = inputIsString ? data.length : data.size;\n\t  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n\t  var chunks = Math.ceil(len / chunkSize);\n\t  var currentChunk = 0;\n\t  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\t\n\t  var append = inputIsString ? appendString : appendBlob;\n\t\n\t  function next() {\n\t    setImmediateShim(loadNextChunk);\n\t  }\n\t\n\t  function done() {\n\t    var raw = buffer.end(true);\n\t    var base64 = rawToBase64(raw);\n\t    callback(base64);\n\t    buffer.destroy();\n\t  }\n\t\n\t  function loadNextChunk() {\n\t    var start = currentChunk * chunkSize;\n\t    var end = start + chunkSize;\n\t    currentChunk++;\n\t    if (currentChunk < chunks) {\n\t      append(buffer, data, start, end, next);\n\t    } else {\n\t      append(buffer, data, start, end, done);\n\t    }\n\t  }\n\t  loadNextChunk();\n\t}\n\t\n\tfunction stringMd5(string) {\n\t  return Md5.hash(string);\n\t}\n\t\n\tfunction parseBase64(data) {\n\t  try {\n\t    return atob$1(data);\n\t  } catch (e) {\n\t    var err = createError(BAD_ARG,\n\t      'Attachment is not a valid base64 string');\n\t    return {error: err};\n\t  }\n\t}\n\t\n\tfunction preprocessString(att, blobType, callback) {\n\t  var asBinary = parseBase64(att.data);\n\t  if (asBinary.error) {\n\t    return callback(asBinary.error);\n\t  }\n\t\n\t  att.length = asBinary.length;\n\t  if (blobType === 'blob') {\n\t    att.data = binStringToBluffer(asBinary, att.content_type);\n\t  } else if (blobType === 'base64') {\n\t    att.data = btoa$1(asBinary);\n\t  } else { // binary\n\t    att.data = asBinary;\n\t  }\n\t  binaryMd5(asBinary, function (result) {\n\t    att.digest = 'md5-' + result;\n\t    callback();\n\t  });\n\t}\n\t\n\tfunction preprocessBlob(att, blobType, callback) {\n\t  binaryMd5(att.data, function (md5) {\n\t    att.digest = 'md5-' + md5;\n\t    // size is for blobs (browser), length is for buffers (node)\n\t    att.length = att.data.size || att.data.length || 0;\n\t    if (blobType === 'binary') {\n\t      blobToBinaryString(att.data, function (binString) {\n\t        att.data = binString;\n\t        callback();\n\t      });\n\t    } else if (blobType === 'base64') {\n\t      blobToBase64(att.data, function (b64) {\n\t        att.data = b64;\n\t        callback();\n\t      });\n\t    } else {\n\t      callback();\n\t    }\n\t  });\n\t}\n\t\n\tfunction preprocessAttachment(att, blobType, callback) {\n\t  if (att.stub) {\n\t    return callback();\n\t  }\n\t  if (typeof att.data === 'string') { // input is a base64 string\n\t    preprocessString(att, blobType, callback);\n\t  } else { // input is a blob\n\t    preprocessBlob(att, blobType, callback);\n\t  }\n\t}\n\t\n\tfunction preprocessAttachments(docInfos, blobType, callback) {\n\t\n\t  if (!docInfos.length) {\n\t    return callback();\n\t  }\n\t\n\t  var docv = 0;\n\t  var overallErr;\n\t\n\t  docInfos.forEach(function (docInfo) {\n\t    var attachments = docInfo.data && docInfo.data._attachments ?\n\t      Object.keys(docInfo.data._attachments) : [];\n\t    var recv = 0;\n\t\n\t    if (!attachments.length) {\n\t      return done();\n\t    }\n\t\n\t    function processedAttachment(err) {\n\t      overallErr = err;\n\t      recv++;\n\t      if (recv === attachments.length) {\n\t        done();\n\t      }\n\t    }\n\t\n\t    for (var key in docInfo.data._attachments) {\n\t      if (docInfo.data._attachments.hasOwnProperty(key)) {\n\t        preprocessAttachment(docInfo.data._attachments[key],\n\t          blobType, processedAttachment);\n\t      }\n\t    }\n\t  });\n\t\n\t  function done() {\n\t    docv++;\n\t    if (docInfos.length === docv) {\n\t      if (overallErr) {\n\t        callback(overallErr);\n\t      } else {\n\t        callback();\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction updateDoc(revLimit, prev, docInfo, results,\n\t                   i, cb, writeDoc, newEdits) {\n\t\n\t  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n\t    results[i] = docInfo;\n\t    return cb();\n\t  }\n\t\n\t  // sometimes this is pre-calculated. historically not always\n\t  var previousWinningRev = prev.winningRev || winningRev(prev);\n\t  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n\t    isDeleted(prev, previousWinningRev);\n\t  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n\t    isDeleted(docInfo.metadata);\n\t  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\t\n\t  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n\t    var newDoc = docInfo.data;\n\t    newDoc._rev = previousWinningRev;\n\t    newDoc._id = docInfo.metadata.id;\n\t    docInfo = parseDoc(newDoc, newEdits);\n\t  }\n\t\n\t  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\t\n\t  var inConflict = newEdits && (((previouslyDeleted && deleted) ||\n\t    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n\t    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\t\n\t  if (inConflict) {\n\t    var err = createError(REV_CONFLICT);\n\t    results[i] = err;\n\t    return cb();\n\t  }\n\t\n\t  var newRev = docInfo.metadata.rev;\n\t  docInfo.metadata.rev_tree = merged.tree;\n\t  docInfo.stemmedRevs = merged.stemmedRevs || [];\n\t  /* istanbul ignore else */\n\t  if (prev.rev_map) {\n\t    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n\t  }\n\t\n\t  // recalculate\n\t  var winningRev$$ = winningRev(docInfo.metadata);\n\t  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$);\n\t\n\t  // calculate the total number of documents that were added/removed,\n\t  // from the perspective of total_rows/doc_count\n\t  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n\t    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\t\n\t  var newRevIsDeleted;\n\t  if (newRev === winningRev$$) {\n\t    // if the new rev is the same as the winning rev, we can reuse that value\n\t    newRevIsDeleted = winningRevIsDeleted;\n\t  } else {\n\t    // if they're not the same, then we need to recalculate\n\t    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n\t  }\n\t\n\t  writeDoc(docInfo, winningRev$$, winningRevIsDeleted, newRevIsDeleted,\n\t    true, delta, i, cb);\n\t}\n\t\n\tfunction rootIsMissing(docInfo) {\n\t  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n\t}\n\t\n\tfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n\t                     writeDoc, opts, overallCallback) {\n\t\n\t  // Default to 1000 locally\n\t  revLimit = revLimit || 1000;\n\t\n\t  function insertDoc(docInfo, resultsIdx, callback) {\n\t    // Cant insert new deleted documents\n\t    var winningRev$$ = winningRev(docInfo.metadata);\n\t    var deleted = isDeleted(docInfo.metadata, winningRev$$);\n\t    if ('was_delete' in opts && deleted) {\n\t      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n\t      return callback();\n\t    }\n\t\n\t    // 4712 - detect whether a new document was inserted with a _rev\n\t    var inConflict = newEdits && rootIsMissing(docInfo);\n\t\n\t    if (inConflict) {\n\t      var err = createError(REV_CONFLICT);\n\t      results[resultsIdx] = err;\n\t      return callback();\n\t    }\n\t\n\t    var delta = deleted ? 0 : 1;\n\t\n\t    writeDoc(docInfo, winningRev$$, deleted, deleted, false,\n\t      delta, resultsIdx, callback);\n\t  }\n\t\n\t  var newEdits = opts.new_edits;\n\t  var idsToDocs = new _Map();\n\t\n\t  var docsDone = 0;\n\t  var docsToDo = docInfos.length;\n\t\n\t  function checkAllDocsDone() {\n\t    if (++docsDone === docsToDo && overallCallback) {\n\t      overallCallback();\n\t    }\n\t  }\n\t\n\t  docInfos.forEach(function (currentDoc, resultsIdx) {\n\t\n\t    if (currentDoc._id && isLocalId(currentDoc._id)) {\n\t      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n\t      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n\t        results[resultsIdx] = err || res;\n\t        checkAllDocsDone();\n\t      });\n\t      return;\n\t    }\n\t\n\t    var id = currentDoc.metadata.id;\n\t    if (idsToDocs.has(id)) {\n\t      docsToDo--; // duplicate\n\t      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n\t    } else {\n\t      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n\t    }\n\t  });\n\t\n\t  // in the case of new_edits, the user can provide multiple docs\n\t  // with the same id. these need to be processed sequentially\n\t  idsToDocs.forEach(function (docs, id) {\n\t    var numDone = 0;\n\t\n\t    function docWritten() {\n\t      if (++numDone < docs.length) {\n\t        nextDoc();\n\t      } else {\n\t        checkAllDocsDone();\n\t      }\n\t    }\n\t    function nextDoc() {\n\t      var value = docs[numDone];\n\t      var currentDoc = value[0];\n\t      var resultsIdx = value[1];\n\t\n\t      if (fetchedDocs.has(id)) {\n\t        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n\t          resultsIdx, docWritten, writeDoc, newEdits);\n\t      } else {\n\t        // Ensure stemming applies to new writes as well\n\t        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n\t        currentDoc.metadata.rev_tree = merged.tree;\n\t        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n\t        insertDoc(currentDoc, resultsIdx, docWritten);\n\t      }\n\t    }\n\t    nextDoc();\n\t  });\n\t}\n\t\n\t// IndexedDB requires a versioned database structure, so we use the\n\t// version here to manage migrations.\n\tvar ADAPTER_VERSION = 5;\n\t\n\t// The object stores created for each database\n\t// DOC_STORE stores the document meta data, its revision history and state\n\t// Keyed by document id\n\tvar DOC_STORE = 'document-store';\n\t// BY_SEQ_STORE stores a particular version of a document, keyed by its\n\t// sequence id\n\tvar BY_SEQ_STORE = 'by-sequence';\n\t// Where we store attachments\n\tvar ATTACH_STORE = 'attach-store';\n\t// Where we store many-to-many relations\n\t// between attachment digests and seqs\n\tvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\t\n\t// Where we store database-wide meta data in a single record\n\t// keyed by id: META_STORE\n\tvar META_STORE = 'meta-store';\n\t// Where we store local documents\n\tvar LOCAL_STORE = 'local-store';\n\t// Where we detect blob support\n\tvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\t\n\tfunction slowJsonParse(str) {\n\t  try {\n\t    return JSON.parse(str);\n\t  } catch (e) {\n\t    /* istanbul ignore next */\n\t    return vuvuzela.parse(str);\n\t  }\n\t}\n\t\n\tfunction safeJsonParse(str) {\n\t  // try/catch is deoptimized in V8, leading to slower\n\t  // times than we'd like to have. Most documents are _not_\n\t  // huge, and do not require a slower code path just to parse them.\n\t  // We can be pretty sure that a document under 50000 characters\n\t  // will not be so deeply nested as to throw a stack overflow error\n\t  // (depends on the engine and available memory, though, so this is\n\t  // just a hunch). 50000 was chosen based on the average length\n\t  // of this string in our test suite, to try to find a number that covers\n\t  // most of our test cases (26 over this size, 26378 under it).\n\t  if (str.length < 50000) {\n\t    return JSON.parse(str);\n\t  }\n\t  return slowJsonParse(str);\n\t}\n\t\n\tfunction safeJsonStringify(json) {\n\t  try {\n\t    return JSON.stringify(json);\n\t  } catch (e) {\n\t    /* istanbul ignore next */\n\t    return vuvuzela.stringify(json);\n\t  }\n\t}\n\t\n\tfunction tryCode(fun, that, args, PouchDB) {\n\t  try {\n\t    fun.apply(that, args);\n\t  } catch (err) {\n\t    // Shouldn't happen, but in some odd cases\n\t    // IndexedDB implementations might throw a sync\n\t    // error, in which case this will at least log it.\n\t    PouchDB.emit('error', err);\n\t  }\n\t}\n\t\n\tvar taskQueue = {\n\t  running: false,\n\t  queue: []\n\t};\n\t\n\tfunction applyNext(PouchDB) {\n\t  if (taskQueue.running || !taskQueue.queue.length) {\n\t    return;\n\t  }\n\t  taskQueue.running = true;\n\t  var item = taskQueue.queue.shift();\n\t  item.action(function (err, res) {\n\t    tryCode(item.callback, this, [err, res], PouchDB);\n\t    taskQueue.running = false;\n\t    process.nextTick(function () {\n\t      applyNext(PouchDB);\n\t    });\n\t  });\n\t}\n\t\n\tfunction idbError(callback) {\n\t  return function (evt) {\n\t    var message = 'unknown_error';\n\t    if (evt.target && evt.target.error) {\n\t      message = evt.target.error.name || evt.target.error.message;\n\t    }\n\t    callback(createError(IDB_ERROR, message, evt.type));\n\t  };\n\t}\n\t\n\t// Unfortunately, the metadata has to be stringified\n\t// when it is put into the database, because otherwise\n\t// IndexedDB can throw errors for deeply-nested objects.\n\t// Originally we just used JSON.parse/JSON.stringify; now\n\t// we use this custom vuvuzela library that avoids recursion.\n\t// If we could do it all over again, we'd probably use a\n\t// format for the revision trees other than JSON.\n\tfunction encodeMetadata(metadata, winningRev, deleted) {\n\t  return {\n\t    data: safeJsonStringify(metadata),\n\t    winningRev: winningRev,\n\t    deletedOrLocal: deleted ? '1' : '0',\n\t    seq: metadata.seq, // highest seq for this doc\n\t    id: metadata.id\n\t  };\n\t}\n\t\n\tfunction decodeMetadata(storedObject) {\n\t  if (!storedObject) {\n\t    return null;\n\t  }\n\t  var metadata = safeJsonParse(storedObject.data);\n\t  metadata.winningRev = storedObject.winningRev;\n\t  metadata.deleted = storedObject.deletedOrLocal === '1';\n\t  metadata.seq = storedObject.seq;\n\t  return metadata;\n\t}\n\t\n\t// read the doc back out from the database. we don't store the\n\t// _id or _rev because we already have _doc_id_rev.\n\tfunction decodeDoc(doc) {\n\t  if (!doc) {\n\t    return doc;\n\t  }\n\t  var idx = doc._doc_id_rev.lastIndexOf(':');\n\t  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n\t  doc._rev = doc._doc_id_rev.substring(idx + 1);\n\t  delete doc._doc_id_rev;\n\t  return doc;\n\t}\n\t\n\t// Read a blob from the database, encoding as necessary\n\t// and translating from base64 if the IDB doesn't support\n\t// native Blobs\n\tfunction readBlobData(body, type, asBlob, callback) {\n\t  if (asBlob) {\n\t    if (!body) {\n\t      callback(createBlob([''], {type: type}));\n\t    } else if (typeof body !== 'string') { // we have blob support\n\t      callback(body);\n\t    } else { // no blob support\n\t      callback(b64ToBluffer(body, type));\n\t    }\n\t  } else { // as base64 string\n\t    if (!body) {\n\t      callback('');\n\t    } else if (typeof body !== 'string') { // we have blob support\n\t      readAsBinaryString(body, function (binary) {\n\t        callback(btoa$1(binary));\n\t      });\n\t    } else { // no blob support\n\t      callback(body);\n\t    }\n\t  }\n\t}\n\t\n\tfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n\t  var attachments = Object.keys(doc._attachments || {});\n\t  if (!attachments.length) {\n\t    return cb && cb();\n\t  }\n\t  var numDone = 0;\n\t\n\t  function checkDone() {\n\t    if (++numDone === attachments.length && cb) {\n\t      cb();\n\t    }\n\t  }\n\t\n\t  function fetchAttachment(doc, att) {\n\t    var attObj = doc._attachments[att];\n\t    var digest = attObj.digest;\n\t    var req = txn.objectStore(ATTACH_STORE).get(digest);\n\t    req.onsuccess = function (e) {\n\t      attObj.body = e.target.result.body;\n\t      checkDone();\n\t    };\n\t  }\n\t\n\t  attachments.forEach(function (att) {\n\t    if (opts.attachments && opts.include_docs) {\n\t      fetchAttachment(doc, att);\n\t    } else {\n\t      doc._attachments[att].stub = true;\n\t      checkDone();\n\t    }\n\t  });\n\t}\n\t\n\t// IDB-specific postprocessing necessary because\n\t// we don't know whether we stored a true Blob or\n\t// a base64-encoded string, and if it's a Blob it\n\t// needs to be read outside of the transaction context\n\tfunction postProcessAttachments(results, asBlob) {\n\t  return PouchPromise.all(results.map(function (row) {\n\t    if (row.doc && row.doc._attachments) {\n\t      var attNames = Object.keys(row.doc._attachments);\n\t      return PouchPromise.all(attNames.map(function (att) {\n\t        var attObj = row.doc._attachments[att];\n\t        if (!('body' in attObj)) { // already processed\n\t          return;\n\t        }\n\t        var body = attObj.body;\n\t        var type = attObj.content_type;\n\t        return new PouchPromise(function (resolve) {\n\t          readBlobData(body, type, asBlob, function (data) {\n\t            row.doc._attachments[att] = extend$1(\n\t              pick(attObj, ['digest', 'content_type']),\n\t              {data: data}\n\t            );\n\t            resolve();\n\t          });\n\t        });\n\t      }));\n\t    }\n\t  }));\n\t}\n\t\n\tfunction compactRevs(revs, docId, txn) {\n\t\n\t  var possiblyOrphanedDigests = [];\n\t  var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t  var attStore = txn.objectStore(ATTACH_STORE);\n\t  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t  var count = revs.length;\n\t\n\t  function checkDone() {\n\t    count--;\n\t    if (!count) { // done processing all revs\n\t      deleteOrphanedAttachments();\n\t    }\n\t  }\n\t\n\t  function deleteOrphanedAttachments() {\n\t    if (!possiblyOrphanedDigests.length) {\n\t      return;\n\t    }\n\t    possiblyOrphanedDigests.forEach(function (digest) {\n\t      var countReq = attAndSeqStore.index('digestSeq').count(\n\t        IDBKeyRange.bound(\n\t          digest + '::', digest + '::\\uffff', false, false));\n\t      countReq.onsuccess = function (e) {\n\t        var count = e.target.result;\n\t        if (!count) {\n\t          // orphaned\n\t          attStore.delete(digest);\n\t        }\n\t      };\n\t    });\n\t  }\n\t\n\t  revs.forEach(function (rev) {\n\t    var index = seqStore.index('_doc_id_rev');\n\t    var key = docId + \"::\" + rev;\n\t    index.getKey(key).onsuccess = function (e) {\n\t      var seq = e.target.result;\n\t      if (typeof seq !== 'number') {\n\t        return checkDone();\n\t      }\n\t      seqStore.delete(seq);\n\t\n\t      var cursor = attAndSeqStore.index('seq')\n\t        .openCursor(IDBKeyRange.only(seq));\n\t\n\t      cursor.onsuccess = function (event) {\n\t        var cursor = event.target.result;\n\t        if (cursor) {\n\t          var digest = cursor.value.digestSeq.split('::')[0];\n\t          possiblyOrphanedDigests.push(digest);\n\t          attAndSeqStore.delete(cursor.primaryKey);\n\t          cursor.continue();\n\t        } else { // done\n\t          checkDone();\n\t        }\n\t      };\n\t    };\n\t  });\n\t}\n\t\n\tfunction openTransactionSafely(idb, stores, mode) {\n\t  try {\n\t    return {\n\t      txn: idb.transaction(stores, mode)\n\t    };\n\t  } catch (err) {\n\t    return {\n\t      error: err\n\t    };\n\t  }\n\t}\n\t\n\tfunction idbBulkDocs(dbOpts, req, opts, api, idb, idbChanges, callback) {\n\t  var docInfos = req.docs;\n\t  var txn;\n\t  var docStore;\n\t  var bySeqStore;\n\t  var attachStore;\n\t  var attachAndSeqStore;\n\t  var docInfoError;\n\t  var docCountDelta = 0;\n\t\n\t  for (var i = 0, len = docInfos.length; i < len; i++) {\n\t    var doc = docInfos[i];\n\t    if (doc._id && isLocalId(doc._id)) {\n\t      continue;\n\t    }\n\t    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n\t    if (doc.error && !docInfoError) {\n\t      docInfoError = doc;\n\t    }\n\t  }\n\t\n\t  if (docInfoError) {\n\t    return callback(docInfoError);\n\t  }\n\t\n\t  var results = new Array(docInfos.length);\n\t  var fetchedDocs = new _Map();\n\t  var preconditionErrored = false;\n\t  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\t\n\t  preprocessAttachments(docInfos, blobType, function (err) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    startTransaction();\n\t  });\n\t\n\t  function startTransaction() {\n\t\n\t    var stores = [\n\t      DOC_STORE, BY_SEQ_STORE,\n\t      ATTACH_STORE,\n\t      LOCAL_STORE, ATTACH_AND_SEQ_STORE\n\t    ];\n\t    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    txn = txnResult.txn;\n\t    txn.onabort = idbError(callback);\n\t    txn.ontimeout = idbError(callback);\n\t    txn.oncomplete = complete;\n\t    docStore = txn.objectStore(DOC_STORE);\n\t    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t    attachStore = txn.objectStore(ATTACH_STORE);\n\t    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t\n\t    verifyAttachments(function (err) {\n\t      if (err) {\n\t        preconditionErrored = true;\n\t        return callback(err);\n\t      }\n\t      fetchExistingDocs();\n\t    });\n\t  }\n\t\n\t  function idbProcessDocs() {\n\t    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n\t                txn, results, writeDoc, opts);\n\t  }\n\t\n\t  function fetchExistingDocs() {\n\t\n\t    if (!docInfos.length) {\n\t      return;\n\t    }\n\t\n\t    var numFetched = 0;\n\t\n\t    function checkDone() {\n\t      if (++numFetched === docInfos.length) {\n\t        idbProcessDocs();\n\t      }\n\t    }\n\t\n\t    function readMetadata(event) {\n\t      var metadata = decodeMetadata(event.target.result);\n\t\n\t      if (metadata) {\n\t        fetchedDocs.set(metadata.id, metadata);\n\t      }\n\t      checkDone();\n\t    }\n\t\n\t    for (var i = 0, len = docInfos.length; i < len; i++) {\n\t      var docInfo = docInfos[i];\n\t      if (docInfo._id && isLocalId(docInfo._id)) {\n\t        checkDone(); // skip local docs\n\t        continue;\n\t      }\n\t      var req = docStore.get(docInfo.metadata.id);\n\t      req.onsuccess = readMetadata;\n\t    }\n\t  }\n\t\n\t  function complete() {\n\t    if (preconditionErrored) {\n\t      return;\n\t    }\n\t\n\t    idbChanges.notify(api._meta.name);\n\t    api._meta.docCount += docCountDelta;\n\t    callback(null, results);\n\t  }\n\t\n\t  function verifyAttachment(digest, callback) {\n\t\n\t    var req = attachStore.get(digest);\n\t    req.onsuccess = function (e) {\n\t      if (!e.target.result) {\n\t        var err = createError(MISSING_STUB,\n\t          'unknown stub attachment with digest ' +\n\t          digest);\n\t        err.status = 412;\n\t        callback(err);\n\t      } else {\n\t        callback();\n\t      }\n\t    };\n\t  }\n\t\n\t  function verifyAttachments(finish) {\n\t\n\t\n\t    var digests = [];\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo.data && docInfo.data._attachments) {\n\t        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n\t          var att = docInfo.data._attachments[filename];\n\t          if (att.stub) {\n\t            digests.push(att.digest);\n\t          }\n\t        });\n\t      }\n\t    });\n\t    if (!digests.length) {\n\t      return finish();\n\t    }\n\t    var numDone = 0;\n\t    var err;\n\t\n\t    function checkDone() {\n\t      if (++numDone === digests.length) {\n\t        finish(err);\n\t      }\n\t    }\n\t    digests.forEach(function (digest) {\n\t      verifyAttachment(digest, function (attErr) {\n\t        if (attErr && !err) {\n\t          err = attErr;\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function writeDoc(docInfo, winningRev, winningRevIsDeleted, newRevIsDeleted,\n\t                    isUpdate, delta, resultsIdx, callback) {\n\t\n\t    docCountDelta += delta;\n\t\n\t    docInfo.metadata.winningRev = winningRev;\n\t    docInfo.metadata.deleted = winningRevIsDeleted;\n\t\n\t    var doc = docInfo.data;\n\t    doc._id = docInfo.metadata.id;\n\t    doc._rev = docInfo.metadata.rev;\n\t\n\t    if (newRevIsDeleted) {\n\t      doc._deleted = true;\n\t    }\n\t\n\t    var hasAttachments = doc._attachments &&\n\t      Object.keys(doc._attachments).length;\n\t    if (hasAttachments) {\n\t      return writeAttachments(docInfo, winningRev, winningRevIsDeleted,\n\t        isUpdate, resultsIdx, callback);\n\t    }\n\t\n\t    finishDoc(docInfo, winningRev, winningRevIsDeleted,\n\t      isUpdate, resultsIdx, callback);\n\t  }\n\t\n\t  function finishDoc(docInfo, winningRev, winningRevIsDeleted,\n\t                     isUpdate, resultsIdx, callback) {\n\t\n\t    var doc = docInfo.data;\n\t    var metadata = docInfo.metadata;\n\t\n\t    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n\t    delete doc._id;\n\t    delete doc._rev;\n\t\n\t    function afterPutDoc(e) {\n\t      var revsToDelete = docInfo.stemmedRevs || [];\n\t\n\t      if (isUpdate && api.auto_compaction) {\n\t        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n\t      }\n\t\n\t      if (revsToDelete && revsToDelete.length) {\n\t        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n\t      }\n\t\n\t      metadata.seq = e.target.result;\n\t      // Current _rev is calculated from _rev_tree on read\n\t      delete metadata.rev;\n\t      var metadataToStore = encodeMetadata(metadata, winningRev,\n\t        winningRevIsDeleted);\n\t      var metaDataReq = docStore.put(metadataToStore);\n\t      metaDataReq.onsuccess = afterPutMetadata;\n\t    }\n\t\n\t    function afterPutDocError(e) {\n\t      // ConstraintError, need to update, not put (see #1638 for details)\n\t      e.preventDefault(); // avoid transaction abort\n\t      e.stopPropagation(); // avoid transaction onerror\n\t      var index = bySeqStore.index('_doc_id_rev');\n\t      var getKeyReq = index.getKey(doc._doc_id_rev);\n\t      getKeyReq.onsuccess = function (e) {\n\t        var putReq = bySeqStore.put(doc, e.target.result);\n\t        putReq.onsuccess = afterPutDoc;\n\t      };\n\t    }\n\t\n\t    function afterPutMetadata() {\n\t      results[resultsIdx] = {\n\t        ok: true,\n\t        id: metadata.id,\n\t        rev: winningRev\n\t      };\n\t      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n\t      insertAttachmentMappings(docInfo, metadata.seq, callback);\n\t    }\n\t\n\t    var putReq = bySeqStore.put(doc);\n\t\n\t    putReq.onsuccess = afterPutDoc;\n\t    putReq.onerror = afterPutDocError;\n\t  }\n\t\n\t  function writeAttachments(docInfo, winningRev, winningRevIsDeleted,\n\t                            isUpdate, resultsIdx, callback) {\n\t\n\t\n\t    var doc = docInfo.data;\n\t\n\t    var numDone = 0;\n\t    var attachments = Object.keys(doc._attachments);\n\t\n\t    function collectResults() {\n\t      if (numDone === attachments.length) {\n\t        finishDoc(docInfo, winningRev, winningRevIsDeleted,\n\t          isUpdate, resultsIdx, callback);\n\t      }\n\t    }\n\t\n\t    function attachmentSaved() {\n\t      numDone++;\n\t      collectResults();\n\t    }\n\t\n\t    attachments.forEach(function (key) {\n\t      var att = docInfo.data._attachments[key];\n\t      if (!att.stub) {\n\t        var data = att.data;\n\t        delete att.data;\n\t        att.revpos = parseInt(winningRev, 10);\n\t        var digest = att.digest;\n\t        saveAttachment(digest, data, attachmentSaved);\n\t      } else {\n\t        numDone++;\n\t        collectResults();\n\t      }\n\t    });\n\t  }\n\t\n\t  // map seqs to attachment digests, which\n\t  // we will need later during compaction\n\t  function insertAttachmentMappings(docInfo, seq, callback) {\n\t\n\t    var attsAdded = 0;\n\t    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\t\n\t    if (!attsToAdd.length) {\n\t      return callback();\n\t    }\n\t\n\t    function checkDone() {\n\t      if (++attsAdded === attsToAdd.length) {\n\t        callback();\n\t      }\n\t    }\n\t\n\t    function add(att) {\n\t      var digest = docInfo.data._attachments[att].digest;\n\t      var req = attachAndSeqStore.put({\n\t        seq: seq,\n\t        digestSeq: digest + '::' + seq\n\t      });\n\t\n\t      req.onsuccess = checkDone;\n\t      req.onerror = function (e) {\n\t        // this callback is for a constaint error, which we ignore\n\t        // because this docid/rev has already been associated with\n\t        // the digest (e.g. when new_edits == false)\n\t        e.preventDefault(); // avoid transaction abort\n\t        e.stopPropagation(); // avoid transaction onerror\n\t        checkDone();\n\t      };\n\t    }\n\t    for (var i = 0; i < attsToAdd.length; i++) {\n\t      add(attsToAdd[i]); // do in parallel\n\t    }\n\t  }\n\t\n\t  function saveAttachment(digest, data, callback) {\n\t\n\t\n\t    var getKeyReq = attachStore.count(digest);\n\t    getKeyReq.onsuccess = function (e) {\n\t      var count = e.target.result;\n\t      if (count) {\n\t        return callback(); // already exists\n\t      }\n\t      var newAtt = {\n\t        digest: digest,\n\t        body: data\n\t      };\n\t      var putReq = attachStore.put(newAtt);\n\t      putReq.onsuccess = callback;\n\t    };\n\t  }\n\t}\n\t\n\tfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n\t  try {\n\t    if (start && end) {\n\t      if (descending) {\n\t        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n\t      } else {\n\t        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n\t      }\n\t    } else if (start) {\n\t      if (descending) {\n\t        return IDBKeyRange.upperBound(start);\n\t      } else {\n\t        return IDBKeyRange.lowerBound(start);\n\t      }\n\t    } else if (end) {\n\t      if (descending) {\n\t        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n\t      } else {\n\t        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n\t      }\n\t    } else if (key) {\n\t      return IDBKeyRange.only(key);\n\t    }\n\t  } catch (e) {\n\t    return {error: e};\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction handleKeyRangeError(api, opts, err, callback) {\n\t  if (err.name === \"DataError\" && err.code === 0) {\n\t    // data error, start is less than end\n\t    return callback(null, {\n\t      total_rows: api._meta.docCount,\n\t      offset: opts.skip,\n\t      rows: []\n\t    });\n\t  }\n\t  callback(createError(IDB_ERROR, err.name, err.message));\n\t}\n\t\n\tfunction idbAllDocs(opts, api, idb, callback) {\n\t\n\t  function allDocsQuery(opts, callback) {\n\t    var start = 'startkey' in opts ? opts.startkey : false;\n\t    var end = 'endkey' in opts ? opts.endkey : false;\n\t    var key = 'key' in opts ? opts.key : false;\n\t    var skip = opts.skip || 0;\n\t    var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n\t    var inclusiveEnd = opts.inclusive_end !== false;\n\t    var descending = 'descending' in opts && opts.descending ? 'prev' : null;\n\t\n\t    var keyRange = createKeyRange(start, end, inclusiveEnd, key, descending);\n\t    if (keyRange && keyRange.error) {\n\t      return handleKeyRangeError(api, opts, keyRange.error, callback);\n\t    }\n\t\n\t    var stores = [DOC_STORE, BY_SEQ_STORE];\n\t\n\t    if (opts.attachments) {\n\t      stores.push(ATTACH_STORE);\n\t    }\n\t    var txnResult = openTransactionSafely(idb, stores, 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t    var cursor = descending ?\n\t      docStore.openCursor(keyRange, descending) :\n\t      docStore.openCursor(keyRange);\n\t    var docIdRevIndex = seqStore.index('_doc_id_rev');\n\t    var results = [];\n\t    var docCount = 0;\n\t\n\t    // if the user specifies include_docs=true, then we don't\n\t    // want to block the main cursor while we're fetching the doc\n\t    function fetchDocAsynchronously(metadata, row, winningRev) {\n\t      var key = metadata.id + \"::\" + winningRev;\n\t      docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n\t        row.doc = decodeDoc(e.target.result);\n\t        if (opts.conflicts) {\n\t          row.doc._conflicts = collectConflicts(metadata);\n\t        }\n\t        fetchAttachmentsIfNecessary(row.doc, opts, txn);\n\t      };\n\t    }\n\t\n\t    function allDocsInner(cursor, winningRev, metadata) {\n\t      var row = {\n\t        id: metadata.id,\n\t        key: metadata.id,\n\t        value: {\n\t          rev: winningRev\n\t        }\n\t      };\n\t      var deleted = metadata.deleted;\n\t      if (opts.deleted === 'ok') {\n\t        results.push(row);\n\t        // deleted docs are okay with \"keys\" requests\n\t        if (deleted) {\n\t          row.value.deleted = true;\n\t          row.doc = null;\n\t        } else if (opts.include_docs) {\n\t          fetchDocAsynchronously(metadata, row, winningRev);\n\t        }\n\t      } else if (!deleted && skip-- <= 0) {\n\t        results.push(row);\n\t        if (opts.include_docs) {\n\t          fetchDocAsynchronously(metadata, row, winningRev);\n\t        }\n\t        if (--limit === 0) {\n\t          return;\n\t        }\n\t      }\n\t      cursor.continue();\n\t    }\n\t\n\t    function onGetCursor(e) {\n\t      docCount = api._meta.docCount; // do this within the txn for consistency\n\t      var cursor = e.target.result;\n\t      if (!cursor) {\n\t        return;\n\t      }\n\t      var metadata = decodeMetadata(cursor.value);\n\t      var winningRev = metadata.winningRev;\n\t\n\t      allDocsInner(cursor, winningRev, metadata);\n\t    }\n\t\n\t    function onResultsReady() {\n\t      callback(null, {\n\t        total_rows: docCount,\n\t        offset: opts.skip,\n\t        rows: results\n\t      });\n\t    }\n\t\n\t    function onTxnComplete() {\n\t      if (opts.attachments) {\n\t        postProcessAttachments(results, opts.binary).then(onResultsReady);\n\t      } else {\n\t        onResultsReady();\n\t      }\n\t    }\n\t\n\t    txn.oncomplete = onTxnComplete;\n\t    cursor.onsuccess = onGetCursor;\n\t  }\n\t\n\t  function allDocs(opts, callback) {\n\t\n\t    if (opts.limit === 0) {\n\t      return callback(null, {\n\t        total_rows: api._meta.docCount,\n\t        offset: opts.skip,\n\t        rows: []\n\t      });\n\t    }\n\t    allDocsQuery(opts, callback);\n\t  }\n\t\n\t  allDocs(opts, callback);\n\t}\n\t\n\t//\n\t// Blobs are not supported in all versions of IndexedDB, notably\n\t// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n\t//\n\t// Various other blob bugs exist in Chrome v37-42 (inclusive).\n\t// Detecting them is expensive and confusing to users, and Chrome 37-42\n\t// is at very low usage worldwide, so we do a hacky userAgent check instead.\n\t//\n\t// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n\t// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n\t// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n\t//\n\tfunction checkBlobSupport(txn) {\n\t  return new PouchPromise(function (resolve) {\n\t    var blob = createBlob(['']);\n\t    txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\t\n\t    txn.onabort = function (e) {\n\t      // If the transaction aborts now its due to not being able to\n\t      // write to the database, likely due to the disk being full\n\t      e.preventDefault();\n\t      e.stopPropagation();\n\t      resolve(false);\n\t    };\n\t\n\t    txn.oncomplete = function () {\n\t      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n\t      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n\t      // MS Edge pretends to be Chrome 42:\n\t      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n\t      resolve(matchedEdge || !matchedChrome ||\n\t        parseInt(matchedChrome[1], 10) >= 43);\n\t    };\n\t  }).catch(function () {\n\t    return false; // error, so assume unsupported\n\t  });\n\t}\n\t\n\tvar cachedDBs = new _Map();\n\tvar blobSupportPromise;\n\tvar idbChanges = new Changes();\n\tvar openReqList = new _Map();\n\t\n\tfunction IdbPouch(opts, callback) {\n\t  var api = this;\n\t\n\t  taskQueue.queue.push({\n\t    action: function (thisCallback) {\n\t      init(api, opts, thisCallback);\n\t    },\n\t    callback: callback\n\t  });\n\t  applyNext(api.constructor);\n\t}\n\t\n\tfunction init(api, opts, callback) {\n\t\n\t  var dbName = opts.name;\n\t\n\t  var idb = null;\n\t  api._meta = null;\n\t\n\t  // called when creating a fresh new database\n\t  function createSchema(db) {\n\t    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n\t    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n\t      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n\t    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n\t    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n\t    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\t\n\t    // added in v2\n\t    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\t\n\t    // added in v3\n\t    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\t\n\t    // added in v4\n\t    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n\t      {autoIncrement: true});\n\t    attAndSeqStore.createIndex('seq', 'seq');\n\t    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n\t  }\n\t\n\t  // migration to version 2\n\t  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n\t  // store local docs in the main doc-store, but whaddyagonnado\n\t  function addDeletedOrLocalIndex(txn, callback) {\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\t\n\t    docStore.openCursor().onsuccess = function (event) {\n\t      var cursor = event.target.result;\n\t      if (cursor) {\n\t        var metadata = cursor.value;\n\t        var deleted = isDeleted(metadata);\n\t        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n\t        docStore.put(metadata);\n\t        cursor.continue();\n\t      } else {\n\t        callback();\n\t      }\n\t    };\n\t  }\n\t\n\t  // migration to version 3 (part 1)\n\t  function createLocalStoreSchema(db) {\n\t    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n\t      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n\t  }\n\t\n\t  // migration to version 3 (part 2)\n\t  function migrateLocalStore(txn, cb) {\n\t    var localStore = txn.objectStore(LOCAL_STORE);\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t\n\t    var cursor = docStore.openCursor();\n\t    cursor.onsuccess = function (event) {\n\t      var cursor = event.target.result;\n\t      if (cursor) {\n\t        var metadata = cursor.value;\n\t        var docId = metadata.id;\n\t        var local = isLocalId(docId);\n\t        var rev = winningRev(metadata);\n\t        if (local) {\n\t          var docIdRev = docId + \"::\" + rev;\n\t          // remove all seq entries\n\t          // associated with this docId\n\t          var start = docId + \"::\";\n\t          var end = docId + \"::~\";\n\t          var index = seqStore.index('_doc_id_rev');\n\t          var range = IDBKeyRange.bound(start, end, false, false);\n\t          var seqCursor = index.openCursor(range);\n\t          seqCursor.onsuccess = function (e) {\n\t            seqCursor = e.target.result;\n\t            if (!seqCursor) {\n\t              // done\n\t              docStore.delete(cursor.primaryKey);\n\t              cursor.continue();\n\t            } else {\n\t              var data = seqCursor.value;\n\t              if (data._doc_id_rev === docIdRev) {\n\t                localStore.put(data);\n\t              }\n\t              seqStore.delete(seqCursor.primaryKey);\n\t              seqCursor.continue();\n\t            }\n\t          };\n\t        } else {\n\t          cursor.continue();\n\t        }\n\t      } else if (cb) {\n\t        cb();\n\t      }\n\t    };\n\t  }\n\t\n\t  // migration to version 4 (part 1)\n\t  function addAttachAndSeqStore(db) {\n\t    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n\t      {autoIncrement: true});\n\t    attAndSeqStore.createIndex('seq', 'seq');\n\t    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n\t  }\n\t\n\t  // migration to version 4 (part 2)\n\t  function migrateAttsAndSeqs(txn, callback) {\n\t    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t    var attStore = txn.objectStore(ATTACH_STORE);\n\t    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t\n\t    // need to actually populate the table. this is the expensive part,\n\t    // so as an optimization, check first that this database even\n\t    // contains attachments\n\t    var req = attStore.count();\n\t    req.onsuccess = function (e) {\n\t      var count = e.target.result;\n\t      if (!count) {\n\t        return callback(); // done\n\t      }\n\t\n\t      seqStore.openCursor().onsuccess = function (e) {\n\t        var cursor = e.target.result;\n\t        if (!cursor) {\n\t          return callback(); // done\n\t        }\n\t        var doc = cursor.value;\n\t        var seq = cursor.primaryKey;\n\t        var atts = Object.keys(doc._attachments || {});\n\t        var digestMap = {};\n\t        for (var j = 0; j < atts.length; j++) {\n\t          var att = doc._attachments[atts[j]];\n\t          digestMap[att.digest] = true; // uniq digests, just in case\n\t        }\n\t        var digests = Object.keys(digestMap);\n\t        for (j = 0; j < digests.length; j++) {\n\t          var digest = digests[j];\n\t          attAndSeqStore.put({\n\t            seq: seq,\n\t            digestSeq: digest + '::' + seq\n\t          });\n\t        }\n\t        cursor.continue();\n\t      };\n\t    };\n\t  }\n\t\n\t  // migration to version 5\n\t  // Instead of relying on on-the-fly migration of metadata,\n\t  // this brings the doc-store to its modern form:\n\t  // - metadata.winningrev\n\t  // - metadata.seq\n\t  // - stringify the metadata when storing it\n\t  function migrateMetadata(txn) {\n\t\n\t    function decodeMetadataCompat(storedObject) {\n\t      if (!storedObject.data) {\n\t        // old format, when we didn't store it stringified\n\t        storedObject.deleted = storedObject.deletedOrLocal === '1';\n\t        return storedObject;\n\t      }\n\t      return decodeMetadata(storedObject);\n\t    }\n\t\n\t    // ensure that every metadata has a winningRev and seq,\n\t    // which was previously created on-the-fly but better to migrate\n\t    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    var cursor = docStore.openCursor();\n\t    cursor.onsuccess = function (e) {\n\t      var cursor = e.target.result;\n\t      if (!cursor) {\n\t        return; // done\n\t      }\n\t      var metadata = decodeMetadataCompat(cursor.value);\n\t\n\t      metadata.winningRev = metadata.winningRev ||\n\t        winningRev(metadata);\n\t\n\t      function fetchMetadataSeq() {\n\t        // metadata.seq was added post-3.2.0, so if it's missing,\n\t        // we need to fetch it manually\n\t        var start = metadata.id + '::';\n\t        var end = metadata.id + '::\\uffff';\n\t        var req = bySeqStore.index('_doc_id_rev').openCursor(\n\t          IDBKeyRange.bound(start, end));\n\t\n\t        var metadataSeq = 0;\n\t        req.onsuccess = function (e) {\n\t          var cursor = e.target.result;\n\t          if (!cursor) {\n\t            metadata.seq = metadataSeq;\n\t            return onGetMetadataSeq();\n\t          }\n\t          var seq = cursor.primaryKey;\n\t          if (seq > metadataSeq) {\n\t            metadataSeq = seq;\n\t          }\n\t          cursor.continue();\n\t        };\n\t      }\n\t\n\t      function onGetMetadataSeq() {\n\t        var metadataToStore = encodeMetadata(metadata,\n\t          metadata.winningRev, metadata.deleted);\n\t\n\t        var req = docStore.put(metadataToStore);\n\t        req.onsuccess = function () {\n\t          cursor.continue();\n\t        };\n\t      }\n\t\n\t      if (metadata.seq) {\n\t        return onGetMetadataSeq();\n\t      }\n\t\n\t      fetchMetadataSeq();\n\t    };\n\t\n\t  }\n\t\n\t  api.type = function () {\n\t    return 'idb';\n\t  };\n\t\n\t  api._id = toPromise(function (callback) {\n\t    callback(null, api._meta.instanceId);\n\t  });\n\t\n\t  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n\t    idbBulkDocs(opts, req, reqOpts, api, idb, idbChanges, callback);\n\t  };\n\t\n\t  // First we look up the metadata in the ids database, then we fetch the\n\t  // current revision(s) from the by sequence store\n\t  api._get = function idb_get(id, opts, callback) {\n\t    var doc;\n\t    var metadata;\n\t    var err;\n\t    var txn = opts.ctx;\n\t    if (!txn) {\n\t      var txnResult = openTransactionSafely(idb,\n\t        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      txn = txnResult.txn;\n\t    }\n\t\n\t    function finish() {\n\t      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n\t    }\n\t\n\t    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n\t      metadata = decodeMetadata(e.target.result);\n\t      // we can determine the result here if:\n\t      // 1. there is no such document\n\t      // 2. the document is deleted and we don't ask about specific rev\n\t      // When we ask with opts.rev we expect the answer to be either\n\t      // doc (possibly with _deleted=true) or missing error\n\t      if (!metadata) {\n\t        err = createError(MISSING_DOC, 'missing');\n\t        return finish();\n\t      }\n\t      if (isDeleted(metadata) && !opts.rev) {\n\t        err = createError(MISSING_DOC, \"deleted\");\n\t        return finish();\n\t      }\n\t      var objectStore = txn.objectStore(BY_SEQ_STORE);\n\t\n\t      var rev = opts.rev || metadata.winningRev;\n\t      var key = metadata.id + '::' + rev;\n\t\n\t      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n\t        doc = e.target.result;\n\t        if (doc) {\n\t          doc = decodeDoc(doc);\n\t        }\n\t        if (!doc) {\n\t          err = createError(MISSING_DOC, 'missing');\n\t          return finish();\n\t        }\n\t        finish();\n\t      };\n\t    };\n\t  };\n\t\n\t  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n\t    var txn;\n\t    if (opts.ctx) {\n\t      txn = opts.ctx;\n\t    } else {\n\t      var txnResult = openTransactionSafely(idb,\n\t        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      txn = txnResult.txn;\n\t    }\n\t    var digest = attachment.digest;\n\t    var type = attachment.content_type;\n\t\n\t    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n\t      var body = e.target.result.body;\n\t      readBlobData(body, type, opts.binary, function (blobData) {\n\t        callback(null, blobData);\n\t      });\n\t    };\n\t  };\n\t\n\t  api._info = function idb_info(callback) {\n\t\n\t    if (idb === null || !cachedDBs.has(dbName)) {\n\t      var error = new Error('db isn\\'t open');\n\t      error.id = 'idbNull';\n\t      return callback(error);\n\t    }\n\t    var updateSeq;\n\t    var docCount;\n\t\n\t    var txnResult = openTransactionSafely(idb, [BY_SEQ_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t    var cursor = txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev');\n\t    cursor.onsuccess = function (event) {\n\t      var cursor = event.target.result;\n\t      updateSeq = cursor ? cursor.key : 0;\n\t      // count within the same txn for consistency\n\t      docCount = api._meta.docCount;\n\t    };\n\t\n\t    txn.oncomplete = function () {\n\t      callback(null, {\n\t        doc_count: docCount,\n\t        update_seq: updateSeq,\n\t        // for debugging\n\t        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n\t      });\n\t    };\n\t  };\n\t\n\t  api._allDocs = function idb_allDocs(opts, callback) {\n\t    idbAllDocs(opts, api, idb, callback);\n\t  };\n\t\n\t  api._changes = function (opts) {\n\t    opts = clone(opts);\n\t\n\t    if (opts.continuous) {\n\t      var id = dbName + ':' + uuid();\n\t      idbChanges.addListener(dbName, id, api, opts);\n\t      idbChanges.notify(dbName);\n\t      return {\n\t        cancel: function () {\n\t          idbChanges.removeListener(dbName, id);\n\t        }\n\t      };\n\t    }\n\t\n\t    var docIds = opts.doc_ids && new _Set(opts.doc_ids);\n\t\n\t    opts.since = opts.since || 0;\n\t    var lastSeq = opts.since;\n\t\n\t    var limit = 'limit' in opts ? opts.limit : -1;\n\t    if (limit === 0) {\n\t      limit = 1; // per CouchDB _changes spec\n\t    }\n\t    var returnDocs;\n\t    if ('return_docs' in opts) {\n\t      returnDocs = opts.return_docs;\n\t    } else if ('returnDocs' in opts) {\n\t      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t      returnDocs = opts.returnDocs;\n\t    } else {\n\t      returnDocs = true;\n\t    }\n\t\n\t    var results = [];\n\t    var numResults = 0;\n\t    var filter = filterChange(opts);\n\t    var docIdsToMetadata = new _Map();\n\t\n\t    var txn;\n\t    var bySeqStore;\n\t    var docStore;\n\t    var docIdRevIndex;\n\t\n\t    function onGetCursor(cursor) {\n\t\n\t      var doc = decodeDoc(cursor.value);\n\t      var seq = cursor.key;\n\t\n\t      if (docIds && !docIds.has(doc._id)) {\n\t        return cursor.continue();\n\t      }\n\t\n\t      var metadata;\n\t\n\t      function onGetMetadata() {\n\t        if (metadata.seq !== seq) {\n\t          // some other seq is later\n\t          return cursor.continue();\n\t        }\n\t\n\t        lastSeq = seq;\n\t\n\t        if (metadata.winningRev === doc._rev) {\n\t          return onGetWinningDoc(doc);\n\t        }\n\t\n\t        fetchWinningDoc();\n\t      }\n\t\n\t      function fetchWinningDoc() {\n\t        var docIdRev = doc._id + '::' + metadata.winningRev;\n\t        var req = docIdRevIndex.get(docIdRev);\n\t        req.onsuccess = function (e) {\n\t          onGetWinningDoc(decodeDoc(e.target.result));\n\t        };\n\t      }\n\t\n\t      function onGetWinningDoc(winningDoc) {\n\t\n\t        var change = opts.processChange(winningDoc, metadata, opts);\n\t        change.seq = metadata.seq;\n\t\n\t        var filtered = filter(change);\n\t        if (typeof filtered === 'object') {\n\t          return opts.complete(filtered);\n\t        }\n\t\n\t        if (filtered) {\n\t          numResults++;\n\t          if (returnDocs) {\n\t            results.push(change);\n\t          }\n\t          // process the attachment immediately\n\t          // for the benefit of live listeners\n\t          if (opts.attachments && opts.include_docs) {\n\t            fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n\t              postProcessAttachments([change], opts.binary).then(function () {\n\t                opts.onChange(change);\n\t              });\n\t            });\n\t          } else {\n\t            opts.onChange(change);\n\t          }\n\t        }\n\t        if (numResults !== limit) {\n\t          cursor.continue();\n\t        }\n\t      }\n\t\n\t      metadata = docIdsToMetadata.get(doc._id);\n\t      if (metadata) { // cached\n\t        return onGetMetadata();\n\t      }\n\t      // metadata not cached, have to go fetch it\n\t      docStore.get(doc._id).onsuccess = function (event) {\n\t        metadata = decodeMetadata(event.target.result);\n\t        docIdsToMetadata.set(doc._id, metadata);\n\t        onGetMetadata();\n\t      };\n\t    }\n\t\n\t    function onsuccess(event) {\n\t      var cursor = event.target.result;\n\t\n\t      if (!cursor) {\n\t        return;\n\t      }\n\t      onGetCursor(cursor);\n\t    }\n\t\n\t    function fetchChanges() {\n\t      var objectStores = [DOC_STORE, BY_SEQ_STORE];\n\t      if (opts.attachments) {\n\t        objectStores.push(ATTACH_STORE);\n\t      }\n\t      var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n\t      if (txnResult.error) {\n\t        return opts.complete(txnResult.error);\n\t      }\n\t      txn = txnResult.txn;\n\t      txn.onabort = idbError(opts.complete);\n\t      txn.oncomplete = onTxnComplete;\n\t\n\t      bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t      docStore = txn.objectStore(DOC_STORE);\n\t      docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\t\n\t      var req;\n\t\n\t      if (opts.descending) {\n\t        req = bySeqStore.openCursor(null, 'prev');\n\t      } else {\n\t        req = bySeqStore.openCursor(IDBKeyRange.lowerBound(opts.since, true));\n\t      }\n\t\n\t      req.onsuccess = onsuccess;\n\t    }\n\t\n\t    fetchChanges();\n\t\n\t    function onTxnComplete() {\n\t\n\t      function finish() {\n\t        opts.complete(null, {\n\t          results: results,\n\t          last_seq: lastSeq\n\t        });\n\t      }\n\t\n\t      if (!opts.continuous && opts.attachments) {\n\t        // cannot guarantee that postProcessing was already done,\n\t        // so do it again\n\t        postProcessAttachments(results).then(finish);\n\t      } else {\n\t        finish();\n\t      }\n\t    }\n\t  };\n\t\n\t  api._close = function (callback) {\n\t    if (idb === null) {\n\t      return callback(createError(NOT_OPEN));\n\t    }\n\t\n\t    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n\t    // \"Returns immediately and closes the connection in a separate thread...\"\n\t    idb.close();\n\t    cachedDBs.delete(dbName);\n\t    idb = null;\n\t    callback();\n\t  };\n\t\n\t  api._getRevisionTree = function (docId, callback) {\n\t    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t    var req = txn.objectStore(DOC_STORE).get(docId);\n\t    req.onsuccess = function (event) {\n\t      var doc = decodeMetadata(event.target.result);\n\t      if (!doc) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        callback(null, doc.rev_tree);\n\t      }\n\t    };\n\t  };\n\t\n\t  // This function removes revisions of document docId\n\t  // which are listed in revs and sets this document\n\t  // revision to to rev_tree\n\t  api._doCompaction = function (docId, revs, callback) {\n\t    var stores = [\n\t      DOC_STORE,\n\t      BY_SEQ_STORE,\n\t      ATTACH_STORE,\n\t      ATTACH_AND_SEQ_STORE\n\t    ];\n\t    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t\n\t    docStore.get(docId).onsuccess = function (event) {\n\t      var metadata = decodeMetadata(event.target.result);\n\t      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                                         revHash, ctx, opts) {\n\t        var rev = pos + '-' + revHash;\n\t        if (revs.indexOf(rev) !== -1) {\n\t          opts.status = 'missing';\n\t        }\n\t      });\n\t      compactRevs(revs, docId, txn);\n\t      var winningRev = metadata.winningRev;\n\t      var deleted = metadata.deleted;\n\t      txn.objectStore(DOC_STORE).put(\n\t        encodeMetadata(metadata, winningRev, deleted));\n\t    };\n\t    txn.onabort = idbError(callback);\n\t    txn.oncomplete = function () {\n\t      callback();\n\t    };\n\t  };\n\t\n\t\n\t  api._getLocal = function (id, callback) {\n\t    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var tx = txnResult.txn;\n\t    var req = tx.objectStore(LOCAL_STORE).get(id);\n\t\n\t    req.onerror = idbError(callback);\n\t    req.onsuccess = function (e) {\n\t      var doc = e.target.result;\n\t      if (!doc) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        delete doc['_doc_id_rev']; // for backwards compat\n\t        callback(null, doc);\n\t      }\n\t    };\n\t  };\n\t\n\t  api._putLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    delete doc._revisions; // ignore this, trust the rev\n\t    var oldRev = doc._rev;\n\t    var id = doc._id;\n\t    if (!oldRev) {\n\t      doc._rev = '0-1';\n\t    } else {\n\t      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n\t    }\n\t\n\t    var tx = opts.ctx;\n\t    var ret;\n\t    if (!tx) {\n\t      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      tx = txnResult.txn;\n\t      tx.onerror = idbError(callback);\n\t      tx.oncomplete = function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t\n\t    var oStore = tx.objectStore(LOCAL_STORE);\n\t    var req;\n\t    if (oldRev) {\n\t      req = oStore.get(id);\n\t      req.onsuccess = function (e) {\n\t        var oldDoc = e.target.result;\n\t        if (!oldDoc || oldDoc._rev !== oldRev) {\n\t          callback(createError(REV_CONFLICT));\n\t        } else { // update\n\t          var req = oStore.put(doc);\n\t          req.onsuccess = function () {\n\t            ret = {ok: true, id: doc._id, rev: doc._rev};\n\t            if (opts.ctx) { // return immediately\n\t              callback(null, ret);\n\t            }\n\t          };\n\t        }\n\t      };\n\t    } else { // new doc\n\t      req = oStore.add(doc);\n\t      req.onerror = function (e) {\n\t        // constraint error, already exists\n\t        callback(createError(REV_CONFLICT));\n\t        e.preventDefault(); // avoid transaction abort\n\t        e.stopPropagation(); // avoid transaction onerror\n\t      };\n\t      req.onsuccess = function () {\n\t        ret = {ok: true, id: doc._id, rev: doc._rev};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  api._removeLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var tx = opts.ctx;\n\t    if (!tx) {\n\t      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      tx = txnResult.txn;\n\t      tx.oncomplete = function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t    var ret;\n\t    var id = doc._id;\n\t    var oStore = tx.objectStore(LOCAL_STORE);\n\t    var req = oStore.get(id);\n\t\n\t    req.onerror = idbError(callback);\n\t    req.onsuccess = function (e) {\n\t      var oldDoc = e.target.result;\n\t      if (!oldDoc || oldDoc._rev !== doc._rev) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        oStore.delete(id);\n\t        ret = {ok: true, id: id, rev: '0-0'};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  api._destroy = function (opts, callback) {\n\t    idbChanges.removeAllListeners(dbName);\n\t\n\t    //Close open request for \"dbName\" database to fix ie delay.\n\t    var openReq = openReqList.get(dbName);\n\t    if (openReq && openReq.result) {\n\t      openReq.result.close();\n\t      cachedDBs.delete(dbName);\n\t    }\n\t    var req = indexedDB.deleteDatabase(dbName);\n\t\n\t    req.onsuccess = function () {\n\t      //Remove open request from the list.\n\t      openReqList.delete(dbName);\n\t      if (hasLocalStorage() && (dbName in localStorage)) {\n\t        delete localStorage[dbName];\n\t      }\n\t      callback(null, { 'ok': true });\n\t    };\n\t\n\t    req.onerror = idbError(callback);\n\t  };\n\t\n\t  var cached = cachedDBs.get(dbName);\n\t\n\t  if (cached) {\n\t    idb = cached.idb;\n\t    api._meta = cached.global;\n\t    process.nextTick(function () {\n\t      callback(null, api);\n\t    });\n\t    return;\n\t  }\n\t\n\t  var req;\n\t  if (opts.storage) {\n\t    req = tryStorageOption(dbName, opts.storage);\n\t  } else {\n\t    req = indexedDB.open(dbName, ADAPTER_VERSION);\n\t  }\n\t\n\t  openReqList.set(dbName, req);\n\t\n\t  req.onupgradeneeded = function (e) {\n\t    var db = e.target.result;\n\t    if (e.oldVersion < 1) {\n\t      return createSchema(db); // new db, initial schema\n\t    }\n\t    // do migrations\n\t\n\t    var txn = e.currentTarget.transaction;\n\t    // these migrations have to be done in this function, before\n\t    // control is returned to the event loop, because IndexedDB\n\t\n\t    if (e.oldVersion < 3) {\n\t      createLocalStoreSchema(db); // v2 -> v3\n\t    }\n\t    if (e.oldVersion < 4) {\n\t      addAttachAndSeqStore(db); // v3 -> v4\n\t    }\n\t\n\t    var migrations = [\n\t      addDeletedOrLocalIndex, // v1 -> v2\n\t      migrateLocalStore,      // v2 -> v3\n\t      migrateAttsAndSeqs,     // v3 -> v4\n\t      migrateMetadata         // v4 -> v5\n\t    ];\n\t\n\t    var i = e.oldVersion;\n\t\n\t    function next() {\n\t      var migration = migrations[i - 1];\n\t      i++;\n\t      if (migration) {\n\t        migration(txn, next);\n\t      }\n\t    }\n\t\n\t    next();\n\t  };\n\t\n\t  req.onsuccess = function (e) {\n\t\n\t    idb = e.target.result;\n\t\n\t    idb.onversionchange = function () {\n\t      idb.close();\n\t      cachedDBs.delete(dbName);\n\t    };\n\t\n\t    idb.onabort = function (e) {\n\t      guardedConsole('error', 'Database has a global failure', e.target.error);\n\t      idb.close();\n\t      cachedDBs.delete(dbName);\n\t    };\n\t\n\t    var txn = idb.transaction([\n\t      META_STORE,\n\t      DETECT_BLOB_SUPPORT_STORE,\n\t      DOC_STORE\n\t    ], 'readwrite');\n\t\n\t    var req = txn.objectStore(META_STORE).get(META_STORE);\n\t\n\t    var blobSupport = null;\n\t    var docCount = null;\n\t    var instanceId = null;\n\t\n\t    req.onsuccess = function (e) {\n\t\n\t      var checkSetupComplete = function () {\n\t        if (blobSupport === null || docCount === null ||\n\t            instanceId === null) {\n\t          return;\n\t        } else {\n\t          api._meta = {\n\t            name: dbName,\n\t            instanceId: instanceId,\n\t            blobSupport: blobSupport,\n\t            docCount: docCount\n\t          };\n\t\n\t          cachedDBs.set(dbName, {\n\t            idb: idb,\n\t            global: api._meta\n\t          });\n\t          callback(null, api);\n\t        }\n\t      };\n\t\n\t      //\n\t      // fetch/store the id\n\t      //\n\t\n\t      var meta = e.target.result || {id: META_STORE};\n\t      if (dbName  + '_id' in meta) {\n\t        instanceId = meta[dbName + '_id'];\n\t        checkSetupComplete();\n\t      } else {\n\t        instanceId = uuid();\n\t        meta[dbName + '_id'] = instanceId;\n\t        txn.objectStore(META_STORE).put(meta).onsuccess = function () {\n\t          checkSetupComplete();\n\t        };\n\t      }\n\t\n\t      //\n\t      // check blob support\n\t      //\n\t\n\t      if (!blobSupportPromise) {\n\t        // make sure blob support is only checked once\n\t        blobSupportPromise = checkBlobSupport(txn);\n\t      }\n\t\n\t      blobSupportPromise.then(function (val) {\n\t        blobSupport = val;\n\t        checkSetupComplete();\n\t      });\n\t\n\t      //\n\t      // count docs\n\t      //\n\t\n\t      var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n\t      index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n\t        docCount = e.target.result;\n\t        checkSetupComplete();\n\t      };\n\t\n\t    };\n\t  };\n\t\n\t  req.onerror = function () {\n\t    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n\t    guardedConsole('error', msg);\n\t    callback(createError(IDB_ERROR, msg));\n\t  };\n\t}\n\t\n\tIdbPouch.valid = function () {\n\t  // Issue #2533, we finally gave up on doing bug\n\t  // detection instead of browser sniffing. Safari brought us\n\t  // to our knees.\n\t  var isSafari = typeof openDatabase !== 'undefined' &&\n\t    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n\t    !/Chrome/.test(navigator.userAgent) &&\n\t    !/BlackBerry/.test(navigator.platform);\n\t\n\t  // some outdated implementations of IDB that appear on Samsung\n\t  // and HTC Android devices <4.4 are missing IDBKeyRange\n\t  return !isSafari && typeof indexedDB !== 'undefined' &&\n\t    typeof IDBKeyRange !== 'undefined';\n\t};\n\t\n\tfunction tryStorageOption(dbName, storage) {\n\t  try { // option only available in Firefox 26+\n\t    return indexedDB.open(dbName, {\n\t      version: ADAPTER_VERSION,\n\t      storage: storage\n\t    });\n\t  } catch(err) {\n\t      return indexedDB.open(dbName, ADAPTER_VERSION);\n\t  }\n\t}\n\t\n\tfunction IDBPouch (PouchDB) {\n\t  PouchDB.adapter('idb', IdbPouch, true);\n\t}\n\t\n\t//\n\t// Parsing hex strings. Yeah.\n\t//\n\t// So basically we need this because of a bug in WebSQL:\n\t// https://code.google.com/p/chromium/issues/detail?id=422690\n\t// https://bugs.webkit.org/show_bug.cgi?id=137637\n\t//\n\t// UTF-8 and UTF-16 are provided as separate functions\n\t// for meager performance improvements\n\t//\n\t\n\tfunction decodeUtf8(str) {\n\t  return decodeURIComponent(escape(str));\n\t}\n\t\n\tfunction hexToInt(charCode) {\n\t  // '0'-'9' is 48-57\n\t  // 'A'-'F' is 65-70\n\t  // SQLite will only give us uppercase hex\n\t  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n\t}\n\t\n\t\n\t// Example:\n\t// pragma encoding=utf8;\n\t// select hex('A');\n\t// returns '41'\n\tfunction parseHexUtf8(str, start, end) {\n\t  var result = '';\n\t  while (start < end) {\n\t    result += String.fromCharCode(\n\t      (hexToInt(str.charCodeAt(start++)) << 4) |\n\t        hexToInt(str.charCodeAt(start++)));\n\t  }\n\t  return result;\n\t}\n\t\n\t// Example:\n\t// pragma encoding=utf16;\n\t// select hex('A');\n\t// returns '4100'\n\t// notice that the 00 comes after the 41 (i.e. it's swizzled)\n\tfunction parseHexUtf16(str, start, end) {\n\t  var result = '';\n\t  while (start < end) {\n\t    // UTF-16, so swizzle the bytes\n\t    result += String.fromCharCode(\n\t      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n\t        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n\t        (hexToInt(str.charCodeAt(start)) << 4) |\n\t        hexToInt(str.charCodeAt(start + 1)));\n\t    start += 4;\n\t  }\n\t  return result;\n\t}\n\t\n\tfunction parseHexString(str, encoding) {\n\t  if (encoding === 'UTF-8') {\n\t    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n\t  } else {\n\t    return parseHexUtf16(str, 0, str.length);\n\t  }\n\t}\n\t\n\tfunction quote(str) {\n\t  return \"'\" + str + \"'\";\n\t}\n\t\n\tvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\t\n\t// The object stores created for each database\n\t// DOC_STORE stores the document meta data, its revision history and state\n\tvar DOC_STORE$1 = quote('document-store');\n\t// BY_SEQ_STORE stores a particular version of a document, keyed by its\n\t// sequence id\n\tvar BY_SEQ_STORE$1 = quote('by-sequence');\n\t// Where we store attachments\n\tvar ATTACH_STORE$1 = quote('attach-store');\n\tvar LOCAL_STORE$1 = quote('local-store');\n\tvar META_STORE$1 = quote('metadata-store');\n\t// where we store many-to-many relations between attachment\n\t// digests and seqs\n\tvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\t\n\t// escapeBlob and unescapeBlob are workarounds for a websql bug:\n\t// https://code.google.com/p/chromium/issues/detail?id=422690\n\t// https://bugs.webkit.org/show_bug.cgi?id=137637\n\t// The goal is to never actually insert the \\u0000 character\n\t// in the database.\n\tfunction escapeBlob(str) {\n\t  return str\n\t    .replace(/\\u0002/g, '\\u0002\\u0002')\n\t    .replace(/\\u0001/g, '\\u0001\\u0002')\n\t    .replace(/\\u0000/g, '\\u0001\\u0001');\n\t}\n\t\n\tfunction unescapeBlob(str) {\n\t  return str\n\t    .replace(/\\u0001\\u0001/g, '\\u0000')\n\t    .replace(/\\u0001\\u0002/g, '\\u0001')\n\t    .replace(/\\u0002\\u0002/g, '\\u0002');\n\t}\n\t\n\tfunction stringifyDoc(doc) {\n\t  // don't bother storing the id/rev. it uses lots of space,\n\t  // in persistent map/reduce especially\n\t  delete doc._id;\n\t  delete doc._rev;\n\t  return JSON.stringify(doc);\n\t}\n\t\n\tfunction unstringifyDoc(doc, id, rev) {\n\t  doc = JSON.parse(doc);\n\t  doc._id = id;\n\t  doc._rev = rev;\n\t  return doc;\n\t}\n\t\n\t// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\n\tfunction qMarks(num) {\n\t  var s = '(';\n\t  while (num--) {\n\t    s += '?';\n\t    if (num) {\n\t      s += ',';\n\t    }\n\t  }\n\t  return s + ')';\n\t}\n\t\n\tfunction select(selector, table, joiner, where, orderBy) {\n\t  return 'SELECT ' + selector + ' FROM ' +\n\t    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n\t    (joiner ? (' ON ' + joiner) : '') +\n\t    (where ? (' WHERE ' +\n\t    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n\t    (orderBy ? (' ORDER BY ' + orderBy) : '');\n\t}\n\t\n\tfunction compactRevs$1(revs, docId, tx) {\n\t\n\t  if (!revs.length) {\n\t    return;\n\t  }\n\t\n\t  var numDone = 0;\n\t  var seqs = [];\n\t\n\t  function checkDone() {\n\t    if (++numDone === revs.length) { // done\n\t      deleteOrphans();\n\t    }\n\t  }\n\t\n\t  function deleteOrphans() {\n\t    // find orphaned attachment digests\n\t\n\t    if (!seqs.length) {\n\t      return;\n\t    }\n\t\n\t    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n\t      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\t\n\t    tx.executeSql(sql, seqs, function (tx, res) {\n\t\n\t      var digestsToCheck = [];\n\t      for (var i = 0; i < res.rows.length; i++) {\n\t        digestsToCheck.push(res.rows.item(i).digest);\n\t      }\n\t      if (!digestsToCheck.length) {\n\t        return;\n\t      }\n\t\n\t      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n\t        ' WHERE seq IN (' +\n\t        seqs.map(function () { return '?'; }).join(',') +\n\t        ')';\n\t      tx.executeSql(sql, seqs, function (tx) {\n\t\n\t        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n\t          ' WHERE digest IN (' +\n\t          digestsToCheck.map(function () { return '?'; }).join(',') +\n\t          ')';\n\t        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n\t          var nonOrphanedDigests = new _Set();\n\t          for (var i = 0; i < res.rows.length; i++) {\n\t            nonOrphanedDigests.add(res.rows.item(i).digest);\n\t          }\n\t          digestsToCheck.forEach(function (digest) {\n\t            if (nonOrphanedDigests.has(digest)) {\n\t              return;\n\t            }\n\t            tx.executeSql(\n\t              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n\t              [digest]);\n\t            tx.executeSql(\n\t              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // update by-seq and attach stores in parallel\n\t  revs.forEach(function (rev) {\n\t    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n\t      ' WHERE doc_id=? AND rev=?';\n\t\n\t    tx.executeSql(sql, [docId, rev], function (tx, res) {\n\t      if (!res.rows.length) { // already deleted\n\t        return checkDone();\n\t      }\n\t      var seq = res.rows.item(0).seq;\n\t      seqs.push(seq);\n\t\n\t      tx.executeSql(\n\t        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n\t    });\n\t  });\n\t}\n\t\n\tfunction websqlError(callback) {\n\t  return function (event) {\n\t    guardedConsole('error', 'WebSQL threw an error', event);\n\t    // event may actually be a SQLError object, so report is as such\n\t    var errorNameMatch = event && event.constructor.toString()\n\t        .match(/function ([^\\(]+)/);\n\t    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n\t    var errorReason = event.target || event.message;\n\t    callback(createError(WSQ_ERROR, errorReason, errorName));\n\t  };\n\t}\n\t\n\tfunction getSize(opts) {\n\t  if ('size' in opts) {\n\t    // triggers immediate popup in iOS, fixes #2347\n\t    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n\t    return opts.size * 1000000;\n\t  }\n\t  // In iOS, doesn't matter as long as it's <= 5000000.\n\t  // Except that if you request too much, our tests fail\n\t  // because of the native \"do you accept?\" popup.\n\t  // In Android <=4.3, this value is actually used as an\n\t  // honest-to-god ceiling for data, so we need to\n\t  // set it to a decently high number.\n\t  var isAndroid = typeof navigator !== 'undefined' &&\n\t    /Android/.test(navigator.userAgent);\n\t  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n\t}\n\t\n\tfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n\t  var newEdits = opts.new_edits;\n\t  var userDocs = req.docs;\n\t\n\t  // Parse the docs, give them a sequence number for the result\n\t  var docInfos = userDocs.map(function (doc) {\n\t    if (doc._id && isLocalId(doc._id)) {\n\t      return doc;\n\t    }\n\t    var newDoc = parseDoc(doc, newEdits);\n\t    return newDoc;\n\t  });\n\t\n\t  var docInfoErrors = docInfos.filter(function (docInfo) {\n\t    return docInfo.error;\n\t  });\n\t  if (docInfoErrors.length) {\n\t    return callback(docInfoErrors[0]);\n\t  }\n\t\n\t  var tx;\n\t  var results = new Array(docInfos.length);\n\t  var fetchedDocs = new _Map();\n\t\n\t  var preconditionErrored;\n\t  function complete() {\n\t    if (preconditionErrored) {\n\t      return callback(preconditionErrored);\n\t    }\n\t    websqlChanges.notify(api._name);\n\t    api._docCount = -1; // invalidate\n\t    callback(null, results);\n\t  }\n\t\n\t  function verifyAttachment(digest, callback) {\n\t    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n\t      ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      if (result.rows.item(0).cnt === 0) {\n\t        var err = createError(MISSING_STUB,\n\t          'unknown stub attachment with digest ' +\n\t          digest);\n\t        callback(err);\n\t      } else {\n\t        callback();\n\t      }\n\t    });\n\t  }\n\t\n\t  function verifyAttachments(finish) {\n\t    var digests = [];\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo.data && docInfo.data._attachments) {\n\t        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n\t          var att = docInfo.data._attachments[filename];\n\t          if (att.stub) {\n\t            digests.push(att.digest);\n\t          }\n\t        });\n\t      }\n\t    });\n\t    if (!digests.length) {\n\t      return finish();\n\t    }\n\t    var numDone = 0;\n\t    var err;\n\t\n\t    function checkDone() {\n\t      if (++numDone === digests.length) {\n\t        finish(err);\n\t      }\n\t    }\n\t    digests.forEach(function (digest) {\n\t      verifyAttachment(digest, function (attErr) {\n\t        if (attErr && !err) {\n\t          err = attErr;\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function writeDoc(docInfo, winningRev, winningRevIsDeleted, newRevIsDeleted,\n\t                    isUpdate, delta, resultsIdx, callback) {\n\t\n\t    function finish() {\n\t      var data = docInfo.data;\n\t      var deletedInt = newRevIsDeleted ? 1 : 0;\n\t\n\t      var id = data._id;\n\t      var rev = data._rev;\n\t      var json = stringifyDoc(data);\n\t      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n\t        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n\t      var sqlArgs = [id, rev, json, deletedInt];\n\t\n\t      // map seqs to attachment digests, which\n\t      // we will need later during compaction\n\t      function insertAttachmentMappings(seq, callback) {\n\t        var attsAdded = 0;\n\t        var attsToAdd = Object.keys(data._attachments || {});\n\t\n\t        if (!attsToAdd.length) {\n\t          return callback();\n\t        }\n\t        function checkDone() {\n\t          if (++attsAdded === attsToAdd.length) {\n\t            callback();\n\t          }\n\t          return false; // ack handling a constraint error\n\t        }\n\t        function add(att) {\n\t          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n\t            ' (digest, seq) VALUES (?,?)';\n\t          var sqlArgs = [data._attachments[att].digest, seq];\n\t          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n\t          // second callback is for a constaint error, which we ignore\n\t          // because this docid/rev has already been associated with\n\t          // the digest (e.g. when new_edits == false)\n\t        }\n\t        for (var i = 0; i < attsToAdd.length; i++) {\n\t          add(attsToAdd[i]); // do in parallel\n\t        }\n\t      }\n\t\n\t      tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t        var seq = result.insertId;\n\t        insertAttachmentMappings(seq, function () {\n\t          dataWritten(tx, seq);\n\t        });\n\t      }, function () {\n\t        // constraint error, recover by updating instead (see #1638)\n\t        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n\t          'doc_id=? AND rev=?');\n\t        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n\t          var seq = res.rows.item(0).seq;\n\t          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n\t            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n\t          var sqlArgs = [json, deletedInt, id, rev];\n\t          tx.executeSql(sql, sqlArgs, function (tx) {\n\t            insertAttachmentMappings(seq, function () {\n\t              dataWritten(tx, seq);\n\t            });\n\t          });\n\t        });\n\t        return false; // ack that we've handled the error\n\t      });\n\t    }\n\t\n\t    function collectResults(attachmentErr) {\n\t      if (!err) {\n\t        if (attachmentErr) {\n\t          err = attachmentErr;\n\t          callback(err);\n\t        } else if (recv === attachments.length) {\n\t          finish();\n\t        }\n\t      }\n\t    }\n\t\n\t    var err = null;\n\t    var recv = 0;\n\t\n\t    docInfo.data._id = docInfo.metadata.id;\n\t    docInfo.data._rev = docInfo.metadata.rev;\n\t    var attachments = Object.keys(docInfo.data._attachments || {});\n\t\n\t\n\t    if (newRevIsDeleted) {\n\t      docInfo.data._deleted = true;\n\t    }\n\t\n\t    function attachmentSaved(err) {\n\t      recv++;\n\t      collectResults(err);\n\t    }\n\t\n\t    attachments.forEach(function (key) {\n\t      var att = docInfo.data._attachments[key];\n\t      if (!att.stub) {\n\t        var data = att.data;\n\t        delete att.data;\n\t        att.revpos = parseInt(winningRev, 10);\n\t        var digest = att.digest;\n\t        saveAttachment(digest, data, attachmentSaved);\n\t      } else {\n\t        recv++;\n\t        collectResults();\n\t      }\n\t    });\n\t\n\t    if (!attachments.length) {\n\t      finish();\n\t    }\n\t\n\t    function dataWritten(tx, seq) {\n\t      var id = docInfo.metadata.id;\n\t\n\t      var revsToCompact = docInfo.stemmedRevs || [];\n\t      if (isUpdate && api.auto_compaction) {\n\t        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n\t      }\n\t      if (revsToCompact.length) {\n\t        compactRevs$1(revsToCompact, id, tx);\n\t      }\n\t\n\t      docInfo.metadata.seq = seq;\n\t      delete docInfo.metadata.rev;\n\t\n\t      var sql = isUpdate ?\n\t      'UPDATE ' + DOC_STORE$1 +\n\t      ' SET json=?, max_seq=?, winningseq=' +\n\t      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n\t      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n\t        : 'INSERT INTO ' + DOC_STORE$1 +\n\t      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n\t      var metadataStr = safeJsonStringify(docInfo.metadata);\n\t      var params = isUpdate ?\n\t        [metadataStr, seq, winningRev, id] :\n\t        [id, seq, seq, metadataStr];\n\t      tx.executeSql(sql, params, function () {\n\t        results[resultsIdx] = {\n\t          ok: true,\n\t          id: docInfo.metadata.id,\n\t          rev: winningRev\n\t        };\n\t        fetchedDocs.set(id, docInfo.metadata);\n\t        callback();\n\t      });\n\t    }\n\t  }\n\t\n\t  function websqlProcessDocs() {\n\t    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n\t                results, writeDoc, opts);\n\t  }\n\t\n\t  function fetchExistingDocs(callback) {\n\t    if (!docInfos.length) {\n\t      return callback();\n\t    }\n\t\n\t    var numFetched = 0;\n\t\n\t    function checkDone() {\n\t      if (++numFetched === docInfos.length) {\n\t        callback();\n\t      }\n\t    }\n\t\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo._id && isLocalId(docInfo._id)) {\n\t        return checkDone(); // skip local docs\n\t      }\n\t      var id = docInfo.metadata.id;\n\t      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n\t      ' WHERE id = ?', [id], function (tx, result) {\n\t        if (result.rows.length) {\n\t          var metadata = safeJsonParse(result.rows.item(0).json);\n\t          fetchedDocs.set(id, metadata);\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function saveAttachment(digest, data, callback) {\n\t    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      if (result.rows.length) { // attachment already exists\n\t        return callback();\n\t      }\n\t      // we could just insert before selecting and catch the error,\n\t      // but my hunch is that it's cheaper not to serialize the blob\n\t      // from JS to C if we don't have to (TODO: confirm this)\n\t      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n\t      ' (digest, body, escaped) VALUES (?,?,1)';\n\t      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n\t        callback();\n\t      }, function () {\n\t        // ignore constaint errors, means it already exists\n\t        callback();\n\t        return false; // ack we handled the error\n\t      });\n\t    });\n\t  }\n\t\n\t  preprocessAttachments(docInfos, 'binary', function (err) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    db.transaction(function (txn) {\n\t      tx = txn;\n\t      verifyAttachments(function (err) {\n\t        if (err) {\n\t          preconditionErrored = err;\n\t        } else {\n\t          fetchExistingDocs(websqlProcessDocs);\n\t        }\n\t      });\n\t    }, websqlError(callback), complete);\n\t  });\n\t}\n\t\n\tvar cachedDatabases = new _Map();\n\t\n\t// openDatabase passed in through opts (e.g. for node-websql)\n\tfunction openDatabaseWithOpts(opts) {\n\t  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n\t}\n\t\n\tfunction openDBSafely(opts) {\n\t  try {\n\t    return {\n\t      db: openDatabaseWithOpts(opts)\n\t    };\n\t  } catch (err) {\n\t    return {\n\t      error: err\n\t    };\n\t  }\n\t}\n\t\n\tfunction openDB$1(opts) {\n\t  var cachedResult = cachedDatabases.get(opts.name);\n\t  if (!cachedResult) {\n\t    cachedResult = openDBSafely(opts);\n\t    cachedDatabases.set(opts.name, cachedResult);\n\t  }\n\t  return cachedResult;\n\t}\n\t\n\tvar websqlChanges = new Changes();\n\t\n\tfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n\t  var attachments = Object.keys(doc._attachments || {});\n\t  if (!attachments.length) {\n\t    return cb && cb();\n\t  }\n\t  var numDone = 0;\n\t\n\t  function checkDone() {\n\t    if (++numDone === attachments.length && cb) {\n\t      cb();\n\t    }\n\t  }\n\t\n\t  function fetchAttachment(doc, att) {\n\t    var attObj = doc._attachments[att];\n\t    var attOpts = {binary: opts.binary, ctx: txn};\n\t    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n\t      doc._attachments[att] = extend$1(\n\t        pick(attObj, ['digest', 'content_type']),\n\t        { data: data }\n\t      );\n\t      checkDone();\n\t    });\n\t  }\n\t\n\t  attachments.forEach(function (att) {\n\t    if (opts.attachments && opts.include_docs) {\n\t      fetchAttachment(doc, att);\n\t    } else {\n\t      doc._attachments[att].stub = true;\n\t      checkDone();\n\t    }\n\t  });\n\t}\n\t\n\tvar POUCH_VERSION = 1;\n\t\n\t// these indexes cover the ground for most allDocs queries\n\tvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n\t  BY_SEQ_STORE$1 + ' (seq, deleted)';\n\tvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n\t  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n\t    BY_SEQ_STORE$1 + ' (doc_id, rev)';\n\tvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n\t  DOC_STORE$1 + ' (winningseq)';\n\tvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n\t    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\n\tvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n\t  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n\t    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\t\n\tvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n\t  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\t\n\tvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n\t  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n\t  BY_SEQ_STORE$1 + '.json AS data, ' +\n\t  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n\t  DOC_STORE$1 + '.json AS metadata';\n\t\n\tfunction WebSqlPouch$1(opts, callback) {\n\t  var api = this;\n\t  var instanceId = null;\n\t  var size = getSize(opts);\n\t  var idRequests = [];\n\t  var encoding;\n\t\n\t  api._docCount = -1; // cache sqlite count(*) for performance\n\t  api._name = opts.name;\n\t\n\t  // extend the options here, because sqlite plugin has a ton of options\n\t  // and they are constantly changing, so it's more prudent to allow anything\n\t  var websqlOpts = extend$1({}, opts, {\n\t    version: POUCH_VERSION,\n\t    description: opts.name,\n\t    size: size\n\t  });\n\t  var openDBResult = openDB$1(websqlOpts);\n\t  if (openDBResult.error) {\n\t    return websqlError(callback)(openDBResult.error);\n\t  }\n\t  var db = openDBResult.db;\n\t  if (typeof db.readTransaction !== 'function') {\n\t    // doesn't exist in sqlite plugin\n\t    db.readTransaction = db.transaction;\n\t  }\n\t\n\t  function dbCreated() {\n\t    // note the db name in case the browser upgrades to idb\n\t    if (hasLocalStorage()) {\n\t      window.localStorage['_pouch__websqldb_' + api._name] = true;\n\t    }\n\t    callback(null, api);\n\t  }\n\t\n\t  // In this migration, we added the 'deleted' and 'local' columns to the\n\t  // by-seq and doc store tables.\n\t  // To preserve existing user data, we re-process all the existing JSON\n\t  // and add these values.\n\t  // Called migration2 because it corresponds to adapter version (db_version) #2\n\t  function runMigration2(tx, callback) {\n\t    // index used for the join in the allDocs query\n\t    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\t\n\t    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n\t      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n\t      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n\t      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n\t        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n\t        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n\t          DOC_STORE$1 + ' (local, id)');\n\t\n\t        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n\t          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n\t          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\t\n\t        tx.executeSql(sql, [], function (tx, result) {\n\t\n\t          var deleted = [];\n\t          var local = [];\n\t\n\t          for (var i = 0; i < result.rows.length; i++) {\n\t            var item = result.rows.item(i);\n\t            var seq = item.seq;\n\t            var metadata = JSON.parse(item.metadata);\n\t            if (isDeleted(metadata)) {\n\t              deleted.push(seq);\n\t            }\n\t            if (isLocalId(metadata.id)) {\n\t              local.push(metadata.id);\n\t            }\n\t          }\n\t          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n\t            qMarks(local.length), local, function () {\n\t            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n\t              ' SET deleted = 1 WHERE seq IN ' +\n\t              qMarks(deleted.length), deleted, callback);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we make all the local docs unversioned\n\t  function runMigration3(tx, callback) {\n\t    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n\t      ' (id UNIQUE, rev, json)';\n\t    tx.executeSql(local, [], function () {\n\t      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n\t        BY_SEQ_STORE$1 + '.json AS data ' +\n\t        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n\t        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n\t        DOC_STORE$1 + '.winningseq WHERE local = 1';\n\t      tx.executeSql(sql, [], function (tx, res) {\n\t        var rows = [];\n\t        for (var i = 0; i < res.rows.length; i++) {\n\t          rows.push(res.rows.item(i));\n\t        }\n\t        function doNext() {\n\t          if (!rows.length) {\n\t            return callback(tx);\n\t          }\n\t          var row = rows.shift();\n\t          var rev = JSON.parse(row.data)._rev;\n\t          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n\t              ' (id, rev, json) VALUES (?,?,?)',\n\t              [row.id, rev, row.data], function (tx) {\n\t            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n\t                [row.id], function (tx) {\n\t              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n\t                  [row.seq], function () {\n\t                doNext();\n\t              });\n\t            });\n\t          });\n\t        }\n\t        doNext();\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we remove doc_id_rev and just use rev\n\t  function runMigration4(tx, callback) {\n\t\n\t    function updateRows(rows) {\n\t      function doNext() {\n\t        if (!rows.length) {\n\t          return callback(tx);\n\t        }\n\t        var row = rows.shift();\n\t        var doc_id_rev = parseHexString(row.hex, encoding);\n\t        var idx = doc_id_rev.lastIndexOf('::');\n\t        var doc_id = doc_id_rev.substring(0, idx);\n\t        var rev = doc_id_rev.substring(idx + 2);\n\t        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n\t          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n\t        tx.executeSql(sql, [doc_id, rev, doc_id_rev], function () {\n\t          doNext();\n\t        });\n\t      }\n\t      doNext();\n\t    }\n\t\n\t    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n\t    tx.executeSql(sql, [], function (tx) {\n\t      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n\t      tx.executeSql(sql, [], function (tx) {\n\t        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n\t          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n\t          tx.executeSql(sql, [], function (tx, res) {\n\t            var rows = [];\n\t            for (var i = 0; i < res.rows.length; i++) {\n\t              rows.push(res.rows.item(i));\n\t            }\n\t            updateRows(rows);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we add the attach_and_seq table\n\t  // for issue #2818\n\t  function runMigration5(tx, callback) {\n\t\n\t    function migrateAttsAndSeqs(tx) {\n\t      // need to actually populate the table. this is the expensive part,\n\t      // so as an optimization, check first that this database even\n\t      // contains attachments\n\t      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n\t      tx.executeSql(sql, [], function (tx, res) {\n\t        var count = res.rows.item(0).cnt;\n\t        if (!count) {\n\t          return callback(tx);\n\t        }\n\t\n\t        var offset = 0;\n\t        var pageSize = 10;\n\t        function nextPage() {\n\t          var sql = select(\n\t            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n\t            [DOC_STORE$1, BY_SEQ_STORE$1],\n\t            DOC_STORE_AND_BY_SEQ_JOINER,\n\t            null,\n\t            DOC_STORE$1 + '.id '\n\t          );\n\t          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n\t          offset += pageSize;\n\t          tx.executeSql(sql, [], function (tx, res) {\n\t            if (!res.rows.length) {\n\t              return callback(tx);\n\t            }\n\t            var digestSeqs = {};\n\t            function addDigestSeq(digest, seq) {\n\t              // uniq digest/seq pairs, just in case there are dups\n\t              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n\t              if (seqs.indexOf(seq) === -1) {\n\t                seqs.push(seq);\n\t              }\n\t            }\n\t            for (var i = 0; i < res.rows.length; i++) {\n\t              var row = res.rows.item(i);\n\t              var doc = unstringifyDoc(row.data, row.id, row.rev);\n\t              var atts = Object.keys(doc._attachments || {});\n\t              for (var j = 0; j < atts.length; j++) {\n\t                var att = doc._attachments[atts[j]];\n\t                addDigestSeq(att.digest, row.seq);\n\t              }\n\t            }\n\t            var digestSeqPairs = [];\n\t            Object.keys(digestSeqs).forEach(function (digest) {\n\t              var seqs = digestSeqs[digest];\n\t              seqs.forEach(function (seq) {\n\t                digestSeqPairs.push([digest, seq]);\n\t              });\n\t            });\n\t            if (!digestSeqPairs.length) {\n\t              return nextPage();\n\t            }\n\t            var numDone = 0;\n\t            digestSeqPairs.forEach(function (pair) {\n\t              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n\t                ' (digest, seq) VALUES (?,?)';\n\t              tx.executeSql(sql, pair, function () {\n\t                if (++numDone === digestSeqPairs.length) {\n\t                  nextPage();\n\t                }\n\t              });\n\t            });\n\t          });\n\t        }\n\t        nextPage();\n\t      });\n\t    }\n\t\n\t    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n\t      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n\t    tx.executeSql(attachAndRev, [], function (tx) {\n\t      tx.executeSql(\n\t        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n\t          tx.executeSql(\n\t            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n\t            migrateAttsAndSeqs);\n\t        });\n\t    });\n\t  }\n\t\n\t  // in this migration, we use escapeBlob() and unescapeBlob()\n\t  // instead of reading out the binary as HEX, which is slow\n\t  function runMigration6(tx, callback) {\n\t    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n\t      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n\t    tx.executeSql(sql, [], callback);\n\t  }\n\t\n\t  // issue #3136, in this migration we need a \"latest seq\" as well\n\t  // as the \"winning seq\" in the doc store\n\t  function runMigration7(tx, callback) {\n\t    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n\t      ' ADD COLUMN max_seq INTEGER';\n\t    tx.executeSql(sql, [], function (tx) {\n\t      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n\t        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n\t      tx.executeSql(sql, [], function (tx) {\n\t        // add unique index after filling, else we'll get a constraint\n\t        // error when we do the ALTER TABLE\n\t        var sql =\n\t          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n\t          DOC_STORE$1 + ' (max_seq)';\n\t        tx.executeSql(sql, [], callback);\n\t      });\n\t    });\n\t  }\n\t\n\t  function checkEncoding(tx, cb) {\n\t    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n\t    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n\t        var hex = res.rows.item(0).hex;\n\t        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n\t        cb();\n\t      }\n\t    );\n\t  }\n\t\n\t  function onGetInstanceId() {\n\t    while (idRequests.length > 0) {\n\t      var idCallback = idRequests.pop();\n\t      idCallback(null, instanceId);\n\t    }\n\t  }\n\t\n\t  function onGetVersion(tx, dbVersion) {\n\t    if (dbVersion === 0) {\n\t      // initial schema\n\t\n\t      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n\t        ' (dbid, db_version INTEGER)';\n\t      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n\t        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n\t      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n\t        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n\t      // TODO: migrate winningseq to INTEGER\n\t      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n\t        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n\t      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n\t        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n\t        'json, deleted TINYINT(1), doc_id, rev)';\n\t      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n\t        ' (id UNIQUE, rev, json)';\n\t\n\t      // creates\n\t      tx.executeSql(attach);\n\t      tx.executeSql(local);\n\t      tx.executeSql(attachAndRev, [], function () {\n\t        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n\t        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n\t      });\n\t      tx.executeSql(doc, [], function () {\n\t        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\t        tx.executeSql(seq, [], function () {\n\t          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n\t          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n\t          tx.executeSql(meta, [], function () {\n\t            // mark the db version, and new dbid\n\t            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n\t              ' (db_version, dbid) VALUES (?,?)';\n\t            instanceId = uuid();\n\t            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n\t            tx.executeSql(initSeq, initSeqArgs, function () {\n\t              onGetInstanceId();\n\t            });\n\t          });\n\t        });\n\t      });\n\t    } else { // version > 0\n\t\n\t      var setupDone = function () {\n\t        var migrated = dbVersion < ADAPTER_VERSION$1;\n\t        if (migrated) {\n\t          // update the db version within this transaction\n\t          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n\t            ADAPTER_VERSION$1);\n\t        }\n\t        // notify db.id() callers\n\t        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n\t        tx.executeSql(sql, [], function (tx, result) {\n\t          instanceId = result.rows.item(0).dbid;\n\t          onGetInstanceId();\n\t        });\n\t      };\n\t\n\t      // would love to use promises here, but then websql\n\t      // ends the transaction early\n\t      var tasks = [\n\t        runMigration2,\n\t        runMigration3,\n\t        runMigration4,\n\t        runMigration5,\n\t        runMigration6,\n\t        runMigration7,\n\t        setupDone\n\t      ];\n\t\n\t      // run each migration sequentially\n\t      var i = dbVersion;\n\t      var nextMigration = function (tx) {\n\t        tasks[i - 1](tx, nextMigration);\n\t        i++;\n\t      };\n\t      nextMigration(tx);\n\t    }\n\t  }\n\t\n\t  function setup() {\n\t    db.transaction(function (tx) {\n\t      // first check the encoding\n\t      checkEncoding(tx, function () {\n\t        // then get the version\n\t        fetchVersion(tx);\n\t      });\n\t    }, websqlError(callback), dbCreated);\n\t  }\n\t\n\t  function fetchVersion(tx) {\n\t    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n\t    tx.executeSql(sql, [], function (tx, result) {\n\t      if (!result.rows.length) {\n\t        // database hasn't even been created yet (version 0)\n\t        onGetVersion(tx, 0);\n\t      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n\t        // table was created, but without the new db_version column,\n\t        // so add it.\n\t        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n\t          ' ADD COLUMN db_version INTEGER', [], function () {\n\t          // before version 2, this column didn't even exist\n\t          onGetVersion(tx, 1);\n\t        });\n\t      } else { // column exists, we can safely get it\n\t        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n\t          [], function (tx, result) {\n\t          var dbVersion = result.rows.item(0).db_version;\n\t          onGetVersion(tx, dbVersion);\n\t        });\n\t      }\n\t    });\n\t  }\n\t\n\t  setup();\n\t\n\t  api.type = function () {\n\t    return 'websql';\n\t  };\n\t\n\t  api._id = toPromise(function (callback) {\n\t    callback(null, instanceId);\n\t  });\n\t\n\t  api._info = function (callback) {\n\t    db.readTransaction(function (tx) {\n\t      countDocs(tx, function (docCount) {\n\t        var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n\t        tx.executeSql(sql, [], function (tx, res) {\n\t          var updateSeq = res.rows.item(0).seq || 0;\n\t          callback(null, {\n\t            doc_count: docCount,\n\t            update_seq: updateSeq,\n\t            websql_encoding: encoding\n\t          });\n\t        });\n\t      });\n\t    }, websqlError(callback));\n\t  };\n\t\n\t  api._bulkDocs = function (req, reqOpts, callback) {\n\t    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n\t  };\n\t\n\t  api._get = function (id, opts, callback) {\n\t    var doc;\n\t    var metadata;\n\t    var err;\n\t    var tx = opts.ctx;\n\t    if (!tx) {\n\t      return db.readTransaction(function (txn) {\n\t        api._get(id, extend$1({ctx: txn}, opts), callback);\n\t      });\n\t    }\n\t\n\t    function finish() {\n\t      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n\t    }\n\t\n\t    var sql;\n\t    var sqlArgs;\n\t    if (opts.rev) {\n\t      sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n\t        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n\t      sqlArgs = [id, opts.rev];\n\t    } else {\n\t      sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE_AND_BY_SEQ_JOINER,\n\t        DOC_STORE$1 + '.id=?');\n\t      sqlArgs = [id];\n\t    }\n\t    tx.executeSql(sql, sqlArgs, function (a, results) {\n\t      if (!results.rows.length) {\n\t        err = createError(MISSING_DOC, 'missing');\n\t        return finish();\n\t      }\n\t      var item = results.rows.item(0);\n\t      metadata = safeJsonParse(item.metadata);\n\t      if (item.deleted && !opts.rev) {\n\t        err = createError(MISSING_DOC, 'deleted');\n\t        return finish();\n\t      }\n\t      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n\t      finish();\n\t    });\n\t  };\n\t\n\t  function countDocs(tx, callback) {\n\t\n\t    if (api._docCount !== -1) {\n\t      return callback(api._docCount);\n\t    }\n\t\n\t    // count the total rows\n\t    var sql = select(\n\t      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n\t      [DOC_STORE$1, BY_SEQ_STORE$1],\n\t      DOC_STORE_AND_BY_SEQ_JOINER,\n\t      BY_SEQ_STORE$1 + '.deleted=0');\n\t\n\t    tx.executeSql(sql, [], function (tx, result) {\n\t      api._docCount = result.rows.item(0).num;\n\t      callback(api._docCount);\n\t    });\n\t  }\n\t\n\t  api._allDocs = function (opts, callback) {\n\t    var results = [];\n\t    var totalRows;\n\t\n\t    var start = 'startkey' in opts ? opts.startkey : false;\n\t    var end = 'endkey' in opts ? opts.endkey : false;\n\t    var key = 'key' in opts ? opts.key : false;\n\t    var descending = 'descending' in opts ? opts.descending : false;\n\t    var limit = 'limit' in opts ? opts.limit : -1;\n\t    var offset = 'skip' in opts ? opts.skip : 0;\n\t    var inclusiveEnd = opts.inclusive_end !== false;\n\t\n\t    var sqlArgs = [];\n\t    var criteria = [];\n\t\n\t    if (key !== false) {\n\t      criteria.push(DOC_STORE$1 + '.id = ?');\n\t      sqlArgs.push(key);\n\t    } else if (start !== false || end !== false) {\n\t      if (start !== false) {\n\t        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n\t        sqlArgs.push(start);\n\t      }\n\t      if (end !== false) {\n\t        var comparator = descending ? '>' : '<';\n\t        if (inclusiveEnd) {\n\t          comparator += '=';\n\t        }\n\t        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n\t        sqlArgs.push(end);\n\t      }\n\t      if (key !== false) {\n\t        criteria.push(DOC_STORE$1 + '.id = ?');\n\t        sqlArgs.push(key);\n\t      }\n\t    }\n\t\n\t    if (opts.deleted !== 'ok') {\n\t      // report deleted if keys are specified\n\t      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n\t    }\n\t\n\t    db.readTransaction(function (tx) {\n\t\n\t      // first count up the total rows\n\t      countDocs(tx, function (count) {\n\t        totalRows = count;\n\t\n\t        if (limit === 0) {\n\t          return;\n\t        }\n\t\n\t        // then actually fetch the documents\n\t        var sql = select(\n\t          SELECT_DOCS,\n\t          [DOC_STORE$1, BY_SEQ_STORE$1],\n\t          DOC_STORE_AND_BY_SEQ_JOINER,\n\t          criteria,\n\t          DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n\t          );\n\t        sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\t\n\t        tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t          for (var i = 0, l = result.rows.length; i < l; i++) {\n\t            var item = result.rows.item(i);\n\t            var metadata = safeJsonParse(item.metadata);\n\t            var id = metadata.id;\n\t            var data = unstringifyDoc(item.data, id, item.rev);\n\t            var winningRev = data._rev;\n\t            var doc = {\n\t              id: id,\n\t              key: id,\n\t              value: {rev: winningRev}\n\t            };\n\t            if (opts.include_docs) {\n\t              doc.doc = data;\n\t              doc.doc._rev = winningRev;\n\t              if (opts.conflicts) {\n\t                doc.doc._conflicts = collectConflicts(metadata);\n\t              }\n\t              fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n\t            }\n\t            if (item.deleted) {\n\t              if (opts.deleted === 'ok') {\n\t                doc.value.deleted = true;\n\t                doc.doc = null;\n\t              } else {\n\t                continue;\n\t              }\n\t            }\n\t            results.push(doc);\n\t          }\n\t        });\n\t      });\n\t    }, websqlError(callback), function () {\n\t      callback(null, {\n\t        total_rows: totalRows,\n\t        offset: opts.skip,\n\t        rows: results\n\t      });\n\t    });\n\t  };\n\t\n\t  api._changes = function (opts) {\n\t    opts = clone(opts);\n\t\n\t    if (opts.continuous) {\n\t      var id = api._name + ':' + uuid();\n\t      websqlChanges.addListener(api._name, id, api, opts);\n\t      websqlChanges.notify(api._name);\n\t      return {\n\t        cancel: function () {\n\t          websqlChanges.removeListener(api._name, id);\n\t        }\n\t      };\n\t    }\n\t\n\t    var descending = opts.descending;\n\t\n\t    // Ignore the `since` parameter when `descending` is true\n\t    opts.since = opts.since && !descending ? opts.since : 0;\n\t\n\t    var limit = 'limit' in opts ? opts.limit : -1;\n\t    if (limit === 0) {\n\t      limit = 1; // per CouchDB _changes spec\n\t    }\n\t\n\t    var returnDocs;\n\t    if ('return_docs' in opts) {\n\t      returnDocs = opts.return_docs;\n\t    } else if ('returnDocs' in opts) {\n\t      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t      returnDocs = opts.returnDocs;\n\t    } else {\n\t      returnDocs = true;\n\t    }\n\t    var results = [];\n\t    var numResults = 0;\n\t\n\t    function fetchChanges() {\n\t\n\t      var selectStmt =\n\t        DOC_STORE$1 + '.json AS metadata, ' +\n\t        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n\t        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n\t        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\t\n\t      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\t\n\t      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n\t        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\t\n\t      var criteria = ['maxSeq > ?'];\n\t      var sqlArgs = [opts.since];\n\t\n\t      if (opts.doc_ids) {\n\t        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n\t        sqlArgs = sqlArgs.concat(opts.doc_ids);\n\t      }\n\t\n\t      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\t\n\t      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\t\n\t      var filter = filterChange(opts);\n\t      if (!opts.view && !opts.filter) {\n\t        // we can just limit in the query\n\t        sql += ' LIMIT ' + limit;\n\t      }\n\t\n\t      var lastSeq = opts.since || 0;\n\t      db.readTransaction(function (tx) {\n\t        tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t          function reportChange(change) {\n\t            return function () {\n\t              opts.onChange(change);\n\t            };\n\t          }\n\t          for (var i = 0, l = result.rows.length; i < l; i++) {\n\t            var item = result.rows.item(i);\n\t            var metadata = safeJsonParse(item.metadata);\n\t            lastSeq = item.maxSeq;\n\t\n\t            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n\t              item.winningRev);\n\t            var change = opts.processChange(doc, metadata, opts);\n\t            change.seq = item.maxSeq;\n\t\n\t            var filtered = filter(change);\n\t            if (typeof filtered === 'object') {\n\t              return opts.complete(filtered);\n\t            }\n\t\n\t            if (filtered) {\n\t              numResults++;\n\t              if (returnDocs) {\n\t                results.push(change);\n\t              }\n\t              // process the attachment immediately\n\t              // for the benefit of live listeners\n\t              if (opts.attachments && opts.include_docs) {\n\t                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n\t                  reportChange(change));\n\t              } else {\n\t                reportChange(change)();\n\t              }\n\t            }\n\t            if (numResults === limit) {\n\t              break;\n\t            }\n\t          }\n\t        });\n\t      }, websqlError(opts.complete), function () {\n\t        if (!opts.continuous) {\n\t          opts.complete(null, {\n\t            results: results,\n\t            last_seq: lastSeq\n\t          });\n\t        }\n\t      });\n\t    }\n\t\n\t    fetchChanges();\n\t  };\n\t\n\t  api._close = function (callback) {\n\t    //WebSQL databases do not need to be closed\n\t    callback();\n\t  };\n\t\n\t  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n\t    var res;\n\t    var tx = opts.ctx;\n\t    var digest = attachment.digest;\n\t    var type = attachment.content_type;\n\t    var sql = 'SELECT escaped, ' +\n\t      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n\t      ATTACH_STORE$1 + ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      // websql has a bug where \\u0000 causes early truncation in strings\n\t      // and blobs. to work around this, we used to use the hex() function,\n\t      // but that's not performant. after migration 6, we remove \\u0000\n\t      // and add it back in afterwards\n\t      var item = result.rows.item(0);\n\t      var data = item.escaped ? unescapeBlob(item.body) :\n\t        parseHexString(item.body, encoding);\n\t      if (opts.binary) {\n\t        res = binStringToBluffer(data, type);\n\t      } else {\n\t        res = btoa$1(data);\n\t      }\n\t      callback(null, res);\n\t    });\n\t  };\n\t\n\t  api._getRevisionTree = function (docId, callback) {\n\t    db.readTransaction(function (tx) {\n\t      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n\t      tx.executeSql(sql, [docId], function (tx, result) {\n\t        if (!result.rows.length) {\n\t          callback(createError(MISSING_DOC));\n\t        } else {\n\t          var data = safeJsonParse(result.rows.item(0).metadata);\n\t          callback(null, data.rev_tree);\n\t        }\n\t      });\n\t    });\n\t  };\n\t\n\t  api._doCompaction = function (docId, revs, callback) {\n\t    if (!revs.length) {\n\t      return callback();\n\t    }\n\t    db.transaction(function (tx) {\n\t\n\t      // update doc store\n\t      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n\t      tx.executeSql(sql, [docId], function (tx, result) {\n\t        var metadata = safeJsonParse(result.rows.item(0).metadata);\n\t        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                                           revHash, ctx, opts) {\n\t          var rev = pos + '-' + revHash;\n\t          if (revs.indexOf(rev) !== -1) {\n\t            opts.status = 'missing';\n\t          }\n\t        });\n\t\n\t        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n\t        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n\t      });\n\t\n\t      compactRevs$1(revs, docId, tx);\n\t    }, websqlError(callback), function () {\n\t      callback();\n\t    });\n\t  };\n\t\n\t  api._getLocal = function (id, callback) {\n\t    db.readTransaction(function (tx) {\n\t      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n\t      tx.executeSql(sql, [id], function (tx, res) {\n\t        if (res.rows.length) {\n\t          var item = res.rows.item(0);\n\t          var doc = unstringifyDoc(item.json, id, item.rev);\n\t          callback(null, doc);\n\t        } else {\n\t          callback(createError(MISSING_DOC));\n\t        }\n\t      });\n\t    });\n\t  };\n\t\n\t  api._putLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    delete doc._revisions; // ignore this, trust the rev\n\t    var oldRev = doc._rev;\n\t    var id = doc._id;\n\t    var newRev;\n\t    if (!oldRev) {\n\t      newRev = doc._rev = '0-1';\n\t    } else {\n\t      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n\t    }\n\t    var json = stringifyDoc(doc);\n\t\n\t    var ret;\n\t    function putLocal(tx) {\n\t      var sql;\n\t      var values;\n\t      if (oldRev) {\n\t        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n\t          'WHERE id=? AND rev=?';\n\t        values = [newRev, json, id, oldRev];\n\t      } else {\n\t        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n\t        values = [id, newRev, json];\n\t      }\n\t      tx.executeSql(sql, values, function (tx, res) {\n\t        if (res.rowsAffected) {\n\t          ret = {ok: true, id: id, rev: newRev};\n\t          if (opts.ctx) { // return immediately\n\t            callback(null, ret);\n\t          }\n\t        } else {\n\t          callback(createError(REV_CONFLICT));\n\t        }\n\t      }, function () {\n\t        callback(createError(REV_CONFLICT));\n\t        return false; // ack that we handled the error\n\t      });\n\t    }\n\t\n\t    if (opts.ctx) {\n\t      putLocal(opts.ctx);\n\t    } else {\n\t      db.transaction(putLocal, websqlError(callback), function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  api._removeLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var ret;\n\t\n\t    function removeLocal(tx) {\n\t      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n\t      var params = [doc._id, doc._rev];\n\t      tx.executeSql(sql, params, function (tx, res) {\n\t        if (!res.rowsAffected) {\n\t          return callback(createError(MISSING_DOC));\n\t        }\n\t        ret = {ok: true, id: doc._id, rev: '0-0'};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t\n\t    if (opts.ctx) {\n\t      removeLocal(opts.ctx);\n\t    } else {\n\t      db.transaction(removeLocal, websqlError(callback), function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  api._destroy = function (opts, callback) {\n\t    websqlChanges.removeAllListeners(api._name);\n\t    db.transaction(function (tx) {\n\t      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n\t        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n\t      stores.forEach(function (store) {\n\t        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n\t      });\n\t    }, websqlError(callback), function () {\n\t      if (hasLocalStorage()) {\n\t        delete window.localStorage['_pouch__websqldb_' + api._name];\n\t        delete window.localStorage[api._name];\n\t      }\n\t      callback(null, {'ok': true});\n\t    });\n\t  };\n\t}\n\t\n\tfunction canOpenTestDB() {\n\t  try {\n\t    openDatabase('_pouch_validate_websql', 1, '', 1);\n\t    return true;\n\t  } catch (err) {\n\t    return false;\n\t  }\n\t}\n\t\n\t// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n\t// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n\t// https://github.com/pouchdb/pouchdb/issues/5079)\n\t// This has been fixed in latest WebKit, so we try to detect it here.\n\tfunction isValidWebSQL() {\n\t  // WKWebView UA:\n\t  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n\t  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n\t  // Chrome for iOS UA:\n\t  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n\t  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n\t  //   Mobile/9B206 Safari/7534.48.3\n\t  // Firefox for iOS UA:\n\t  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n\t  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\t\n\t  // indexedDB is null on some UIWebViews and undefined in others\n\t  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n\t  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n\t      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n\t    // definitely not WKWebView, avoid creating an unnecessary database\n\t    return true;\n\t  }\n\t  // Cache the result in LocalStorage. Reason we do this is because if we\n\t  // call openDatabase() too many times, Safari craps out in SauceLabs and\n\t  // starts throwing DOM Exception 14s.\n\t  var hasLS = hasLocalStorage();\n\t  // Include user agent in the hash, so that if Safari is upgraded, we don't\n\t  // continually think it's broken.\n\t  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n\t  if (hasLS && localStorage[localStorageKey]) {\n\t    return localStorage[localStorageKey] === '1';\n\t  }\n\t  var openedTestDB = canOpenTestDB();\n\t  if (hasLS) {\n\t    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n\t  }\n\t  return openedTestDB;\n\t}\n\t\n\tfunction valid() {\n\t  if (typeof openDatabase !== 'function') {\n\t    return false;\n\t  }\n\t  return isValidWebSQL();\n\t}\n\t\n\tfunction openDB(name, version, description, size) {\n\t  // Traditional WebSQL API\n\t  return openDatabase(name, version, description, size);\n\t}\n\t\n\tfunction WebSQLPouch(opts, callback) {\n\t  var _opts = extend$1({\n\t    websql: openDB\n\t  }, opts);\n\t\n\t  WebSqlPouch$1.call(this, _opts, callback);\n\t}\n\t\n\tWebSQLPouch.valid = valid;\n\t\n\tWebSQLPouch.use_prefix = true;\n\t\n\tfunction WebSqlPouch (PouchDB) {\n\t  PouchDB.adapter('websql', WebSQLPouch, true);\n\t}\n\t\n\t/* global fetch */\n\t/* global Headers */\n\tfunction wrappedFetch() {\n\t  var wrappedPromise = {};\n\t\n\t  var promise = new PouchPromise(function (resolve, reject) {\n\t    wrappedPromise.resolve = resolve;\n\t    wrappedPromise.reject = reject;\n\t  });\n\t\n\t  var args = new Array(arguments.length);\n\t\n\t  for (var i = 0; i < args.length; i++) {\n\t    args[i] = arguments[i];\n\t  }\n\t\n\t  wrappedPromise.promise = promise;\n\t\n\t  PouchPromise.resolve().then(function () {\n\t    return fetch.apply(null, args);\n\t  }).then(function (response) {\n\t    wrappedPromise.resolve(response);\n\t  }).catch(function (error) {\n\t    wrappedPromise.reject(error);\n\t  });\n\t\n\t  return wrappedPromise;\n\t}\n\t\n\tfunction fetchRequest(options, callback) {\n\t  var wrappedPromise, timer, response;\n\t\n\t  var headers = new Headers();\n\t\n\t  var fetchOptions = {\n\t    method: options.method,\n\t    credentials: 'include',\n\t    headers: headers\n\t  };\n\t\n\t  if (options.json) {\n\t    headers.set('Accept', 'application/json');\n\t    headers.set('Content-Type', options.headers['Content-Type'] ||\n\t      'application/json');\n\t  }\n\t\n\t  if (options.body && (options.body instanceof Blob)) {\n\t    readAsArrayBuffer(options.body, function (arrayBuffer) {\n\t      fetchOptions.body = arrayBuffer;\n\t    });\n\t  } else if (options.body &&\n\t             options.processData &&\n\t             typeof options.body !== 'string') {\n\t    fetchOptions.body = JSON.stringify(options.body);\n\t  } else if ('body' in options) {\n\t    fetchOptions.body = options.body;\n\t  } else {\n\t    fetchOptions.body = null;\n\t  }\n\t\n\t  Object.keys(options.headers).forEach(function (key) {\n\t    if (options.headers.hasOwnProperty(key)) {\n\t      headers.set(key, options.headers[key]);\n\t    }\n\t  });\n\t\n\t  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\t\n\t  if (options.timeout > 0) {\n\t    timer = setTimeout(function () {\n\t      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n\t        options.url));\n\t    }, options.timeout);\n\t  }\n\t\n\t  wrappedPromise.promise.then(function (fetchResponse) {\n\t    response = {\n\t      statusCode: fetchResponse.status\n\t    };\n\t\n\t    if (options.timeout > 0) {\n\t      clearTimeout(timer);\n\t    }\n\t\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n\t    }\n\t\n\t    return fetchResponse.json();\n\t  }).then(function (result) {\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      callback(null, response, result);\n\t    } else {\n\t      callback(result, response);\n\t    }\n\t  }).catch(function (error) {\n\t    callback(error, response);\n\t  });\n\t\n\t  return {abort: wrappedPromise.reject};\n\t}\n\t\n\tfunction xhRequest(options, callback) {\n\t\n\t  var xhr, timer;\n\t  var timedout = false;\n\t\n\t  var abortReq = function () {\n\t    xhr.abort();\n\t    cleanUp();\n\t  };\n\t\n\t  var timeoutReq = function () {\n\t    timedout = true;\n\t    xhr.abort();\n\t    cleanUp();\n\t  };\n\t\n\t  var ret = {abort: abortReq};\n\t\n\t  var cleanUp = function () {\n\t    clearTimeout(timer);\n\t    ret.abort = function () {};\n\t    if (xhr) {\n\t      xhr.onprogress = undefined;\n\t      if (xhr.upload) {\n\t        xhr.upload.onprogress = undefined;\n\t      }\n\t      xhr.onreadystatechange = undefined;\n\t      xhr = undefined;\n\t    }\n\t  };\n\t\n\t  if (options.xhr) {\n\t    xhr = new options.xhr();\n\t  } else {\n\t    xhr = new XMLHttpRequest();\n\t  }\n\t\n\t  try {\n\t    xhr.open(options.method, options.url);\n\t  } catch (exception) {\n\t    return callback(new Error(exception.name || 'Url is invalid'));\n\t  }\n\t\n\t  xhr.withCredentials = ('withCredentials' in options) ?\n\t    options.withCredentials : true;\n\t\n\t  if (options.method === 'GET') {\n\t    delete options.headers['Content-Type'];\n\t  } else if (options.json) {\n\t    options.headers.Accept = 'application/json';\n\t    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n\t      'application/json';\n\t    if (options.body &&\n\t        options.processData &&\n\t        typeof options.body !== \"string\") {\n\t      options.body = JSON.stringify(options.body);\n\t    }\n\t  }\n\t\n\t  if (options.binary) {\n\t    xhr.responseType = 'arraybuffer';\n\t  }\n\t\n\t  if (!('body' in options)) {\n\t    options.body = null;\n\t  }\n\t\n\t  for (var key in options.headers) {\n\t    if (options.headers.hasOwnProperty(key)) {\n\t      xhr.setRequestHeader(key, options.headers[key]);\n\t    }\n\t  }\n\t\n\t  if (options.timeout > 0) {\n\t    timer = setTimeout(timeoutReq, options.timeout);\n\t    xhr.onprogress = function () {\n\t      clearTimeout(timer);\n\t      if(xhr.readyState !== 4) {\n\t        timer = setTimeout(timeoutReq, options.timeout);\n\t      }\n\t    };\n\t    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n\t      xhr.upload.onprogress = xhr.onprogress;\n\t    }\n\t  }\n\t\n\t  xhr.onreadystatechange = function () {\n\t    if (xhr.readyState !== 4) {\n\t      return;\n\t    }\n\t\n\t    var response = {\n\t      statusCode: xhr.status\n\t    };\n\t\n\t    if (xhr.status >= 200 && xhr.status < 300) {\n\t      var data;\n\t      if (options.binary) {\n\t        data = createBlob([xhr.response || ''], {\n\t          type: xhr.getResponseHeader('Content-Type')\n\t        });\n\t      } else {\n\t        data = xhr.responseText;\n\t      }\n\t      callback(null, response, data);\n\t    } else {\n\t      var err = {};\n\t      if (timedout) {\n\t        err = new Error('ETIMEDOUT');\n\t        err.code = 'ETIMEDOUT';\n\t      } else if (typeof xhr.response === 'string') {\n\t        try {\n\t          err = JSON.parse(xhr.response);\n\t        } catch(e) {}\n\t      }\n\t      err.status = xhr.status;\n\t      callback(err);\n\t    }\n\t    cleanUp();\n\t  };\n\t\n\t  if (options.body && (options.body instanceof Blob)) {\n\t    readAsArrayBuffer(options.body, function (arrayBuffer) {\n\t      xhr.send(arrayBuffer);\n\t    });\n\t  } else {\n\t    xhr.send(options.body);\n\t  }\n\t\n\t  return ret;\n\t}\n\t\n\tfunction testXhr() {\n\t  try {\n\t    new XMLHttpRequest();\n\t    return true;\n\t  } catch (err) {\n\t    return false;\n\t  }\n\t}\n\t\n\tvar hasXhr = testXhr();\n\t\n\tfunction ajax$1(options, callback) {\n\t  if (hasXhr || options.xhr) {\n\t    return xhRequest(options, callback);\n\t  } else {\n\t    return fetchRequest(options, callback);\n\t  }\n\t}\n\t\n\t// the blob already has a type; do nothing\n\tvar res$2 = function () {};\n\t\n\tfunction defaultBody() {\n\t  return '';\n\t}\n\t\n\tfunction ajaxCore(options, callback) {\n\t\n\t  options = clone(options);\n\t\n\t  var defaultOptions = {\n\t    method : \"GET\",\n\t    headers: {},\n\t    json: true,\n\t    processData: true,\n\t    timeout: 10000,\n\t    cache: false\n\t  };\n\t\n\t  options = extend$1(defaultOptions, options);\n\t\n\t  function onSuccess(obj, resp, cb) {\n\t    if (!options.binary && options.json && typeof obj === 'string') {\n\t      /* istanbul ignore next */\n\t      try {\n\t        obj = JSON.parse(obj);\n\t      } catch (e) {\n\t        // Probably a malformed JSON from server\n\t        return cb(e);\n\t      }\n\t    }\n\t    if (Array.isArray(obj)) {\n\t      obj = obj.map(function (v) {\n\t        if (v.error || v.missing) {\n\t          return generateErrorFromResponse(v);\n\t        } else {\n\t          return v;\n\t        }\n\t      });\n\t    }\n\t    if (options.binary) {\n\t      res$2(obj, resp);\n\t    }\n\t    cb(null, obj, resp);\n\t  }\n\t\n\t  if (options.json) {\n\t    if (!options.binary) {\n\t      options.headers.Accept = 'application/json';\n\t    }\n\t    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n\t      'application/json';\n\t  }\n\t\n\t  if (options.binary) {\n\t    options.encoding = null;\n\t    options.json = false;\n\t  }\n\t\n\t  if (!options.processData) {\n\t    options.json = false;\n\t  }\n\t\n\t  return ajax$1(options, function (err, response, body) {\n\t\n\t    if (err) {\n\t      return callback(generateErrorFromResponse(err));\n\t    }\n\t\n\t    var error;\n\t    var content_type = response.headers && response.headers['content-type'];\n\t    var data = body || defaultBody();\n\t\n\t    // CouchDB doesn't always return the right content-type for JSON data, so\n\t    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n\t    if (!options.binary && (options.json || !options.processData) &&\n\t        typeof data !== 'object' &&\n\t        (/json/.test(content_type) ||\n\t         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n\t      try {\n\t        data = JSON.parse(data.toString());\n\t      } catch (e) {}\n\t    }\n\t\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      onSuccess(data, response, callback);\n\t    } else {\n\t      error = generateErrorFromResponse(data);\n\t      error.status = response.statusCode;\n\t      callback(error);\n\t    }\n\t  });\n\t}\n\t\n\tfunction ajax(opts, callback) {\n\t\n\t  // cache-buster, specifically designed to work around IE's aggressive caching\n\t  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n\t  // Also Safari caches POSTs, so we need to cache-bust those too.\n\t  var ua = (navigator && navigator.userAgent) ?\n\t    navigator.userAgent.toLowerCase() : '';\n\t\n\t  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n\t  var isIE = ua.indexOf('msie') !== -1;\n\t  var isEdge = ua.indexOf('edge') !== -1;\n\t\n\t  // it appears the new version of safari also caches GETs,\n\t  // see https://github.com/pouchdb/pouchdb/issues/5010\n\t  var shouldCacheBust = (isSafari ||\n\t    ((isIE || isEdge) && opts.method === 'GET'));\n\t\n\t  var cache = 'cache' in opts ? opts.cache : true;\n\t\n\t  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\t\n\t  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n\t    var hasArgs = opts.url.indexOf('?') !== -1;\n\t    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n\t  }\n\t\n\t  return ajaxCore(opts, callback);\n\t}\n\t\n\tvar CHANGES_BATCH_SIZE = 25;\n\tvar MAX_SIMULTANEOUS_REVS = 50;\n\t\n\tvar supportsBulkGetMap = {};\n\t\n\tvar log$1 = debug('pouchdb:http');\n\t\n\tfunction readAttachmentsAsBlobOrBuffer(row) {\n\t  var atts = row.doc && row.doc._attachments;\n\t  if (!atts) {\n\t    return;\n\t  }\n\t  Object.keys(atts).forEach(function (filename) {\n\t    var att = atts[filename];\n\t    att.data = b64ToBluffer(att.data, att.content_type);\n\t  });\n\t}\n\t\n\tfunction encodeDocId(id) {\n\t  if (/^_design/.test(id)) {\n\t    return '_design/' + encodeURIComponent(id.slice(8));\n\t  }\n\t  if (/^_local/.test(id)) {\n\t    return '_local/' + encodeURIComponent(id.slice(7));\n\t  }\n\t  return encodeURIComponent(id);\n\t}\n\t\n\tfunction preprocessAttachments$1(doc) {\n\t  if (!doc._attachments || !Object.keys(doc._attachments)) {\n\t    return PouchPromise.resolve();\n\t  }\n\t\n\t  return PouchPromise.all(Object.keys(doc._attachments).map(function (key) {\n\t    var attachment = doc._attachments[key];\n\t    if (attachment.data && typeof attachment.data !== 'string') {\n\t      return new PouchPromise(function (resolve) {\n\t        blobToBase64(attachment.data, resolve);\n\t      }).then(function (b64) {\n\t        attachment.data = b64;\n\t      });\n\t    }\n\t  }));\n\t}\n\t\n\tfunction hasUrlPrefix(opts) {\n\t  if (!opts.prefix) {\n\t    return false;\n\t  }\n\t\n\t  var protocol = parseUri(opts.prefix).protocol;\n\t\n\t  return protocol === 'http' || protocol === 'https';\n\t}\n\t\n\t// Get all the information you possibly can about the URI given by name and\n\t// return it as a suitable object.\n\tfunction getHost(name, opts) {\n\t\n\t  // encode db name if opts.prefix is a url (#5574)\n\t  if (hasUrlPrefix(opts)) {\n\t    var dbName = opts.name.substr(opts.prefix.length);\n\t    name = opts.prefix + encodeURIComponent(dbName);\n\t  }\n\t\n\t  // Prase the URI into all its little bits\n\t  var uri = parseUri(name);\n\t\n\t  // Store the user and password as a separate auth object\n\t  if (uri.user || uri.password) {\n\t    uri.auth = {username: uri.user, password: uri.password};\n\t  }\n\t\n\t  // Split the path part of the URI into parts using '/' as the delimiter\n\t  // after removing any leading '/' and any trailing '/'\n\t  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\t\n\t  // Store the first part as the database name and remove it from the parts\n\t  // array\n\t  uri.db = parts.pop();\n\t  // Prevent double encoding of URI component\n\t  if (uri.db.indexOf('%') === -1) {\n\t    uri.db = encodeURIComponent(uri.db);\n\t  }\n\t\n\t  // Restore the path by joining all the remaining parts (all the parts\n\t  // except for the database name) with '/'s\n\t  uri.path = parts.join('/');\n\t\n\t  return uri;\n\t}\n\t\n\t// Generate a URL with the host data given by opts and the given path\n\tfunction genDBUrl(opts, path) {\n\t  return genUrl(opts, opts.db + '/' + path);\n\t}\n\t\n\t// Generate a URL with the host data given by opts and the given path\n\tfunction genUrl(opts, path) {\n\t  // If the host already has a path, then we need to have a path delimiter\n\t  // Otherwise, the path delimiter is the empty string\n\t  var pathDel = !opts.path ? '' : '/';\n\t\n\t  // If the host already has a path, then we need to have a path delimiter\n\t  // Otherwise, the path delimiter is the empty string\n\t  return opts.protocol + '://' + opts.host +\n\t         (opts.port ? (':' + opts.port) : '') +\n\t         '/' + opts.path + pathDel + path;\n\t}\n\t\n\tfunction paramsToStr(params) {\n\t  return '?' + Object.keys(params).map(function (k) {\n\t    return k + '=' + encodeURIComponent(params[k]);\n\t  }).join('&');\n\t}\n\t\n\t// Implements the PouchDB API for dealing with CouchDB instances over HTTP\n\tfunction HttpPouch(opts, callback) {\n\t\n\t  // The functions that will be publicly available for HttpPouch\n\t  var api = this;\n\t\n\t  var host = getHost(opts.name, opts);\n\t  var dbUrl = genDBUrl(host, '');\n\t\n\t  opts = clone(opts);\n\t  var ajaxOpts = opts.ajax || {};\n\t\n\t  if (opts.auth || host.auth) {\n\t    var nAuth = opts.auth || host.auth;\n\t    var str = nAuth.username + ':' + nAuth.password;\n\t    var token = btoa$1(unescape(encodeURIComponent(str)));\n\t    ajaxOpts.headers = ajaxOpts.headers || {};\n\t    ajaxOpts.headers.Authorization = 'Basic ' + token;\n\t  }\n\t\n\t  // Not strictly necessary, but we do this because numerous tests\n\t  // rely on swapping ajax in and out.\n\t  api._ajax = ajax;\n\t\n\t  function ajax$$(userOpts, options, callback) {\n\t    var reqAjax = userOpts.ajax || {};\n\t    var reqOpts = extend$1(clone(ajaxOpts), reqAjax, options);\n\t    log$1(reqOpts.method + ' ' + reqOpts.url);\n\t    return api._ajax(reqOpts, callback);\n\t  }\n\t\n\t  function ajaxPromise(userOpts, opts) {\n\t    return new PouchPromise(function (resolve, reject) {\n\t      ajax$$(userOpts, opts, function (err, res) {\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        resolve(res);\n\t      });\n\t    });\n\t  }\n\t\n\t  function adapterFun$$(name, fun) {\n\t    return adapterFun(name, getArguments(function (args) {\n\t      setup().then(function () {\n\t        return fun.apply(this, args);\n\t      }).catch(function (e) {\n\t        var callback = args.pop();\n\t        callback(e);\n\t      });\n\t    }));\n\t  }\n\t\n\t  var setupPromise;\n\t\n\t  function setup() {\n\t    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n\t    if (opts.skipSetup || opts.skip_setup) {\n\t      return PouchPromise.resolve();\n\t    }\n\t\n\t    // If there is a setup in process or previous successful setup\n\t    // done then we will use that\n\t    // If previous setups have been rejected we will try again\n\t    if (setupPromise) {\n\t      return setupPromise;\n\t    }\n\t\n\t    var checkExists = {method: 'GET', url: dbUrl};\n\t    setupPromise = ajaxPromise({}, checkExists).catch(function (err) {\n\t      if (err && err.status && err.status === 404) {\n\t        // Doesnt exist, create it\n\t        explainError(404, 'PouchDB is just detecting if the remote exists.');\n\t        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n\t      } else {\n\t        return PouchPromise.reject(err);\n\t      }\n\t    }).catch(function (err) {\n\t      // If we try to create a database that already exists, skipped in\n\t      // istanbul since its catching a race condition.\n\t      /* istanbul ignore if */\n\t      if (err && err.status && err.status === 412) {\n\t        return true;\n\t      }\n\t      return PouchPromise.reject(err);\n\t    });\n\t\n\t    setupPromise.catch(function () {\n\t      setupPromise = null;\n\t    });\n\t\n\t    return setupPromise;\n\t  }\n\t\n\t  setTimeout(function () {\n\t    callback(null, api);\n\t  });\n\t\n\t  api.type = function () {\n\t    return 'http';\n\t  };\n\t\n\t  api.id = adapterFun$$('id', function (callback) {\n\t    ajax$$({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n\t      var uuid = (result && result.uuid) ?\n\t        (result.uuid + host.db) : genDBUrl(host, '');\n\t      callback(null, uuid);\n\t    });\n\t  });\n\t\n\t  api.request = adapterFun$$('request', function (options, callback) {\n\t    options.url = genDBUrl(host, options.url);\n\t    ajax$$({}, options, callback);\n\t  });\n\t\n\t  // Sends a POST request to the host calling the couchdb _compact function\n\t  //    version: The version of CouchDB it is running\n\t  api.compact = adapterFun$$('compact', function (opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t    ajax$$(opts, {\n\t      url: genDBUrl(host, '_compact'),\n\t      method: 'POST'\n\t    }, function () {\n\t      function ping() {\n\t        api.info(function (err, res) {\n\t          if (res && !res.compact_running) {\n\t            callback(null, {ok: true});\n\t          } else {\n\t            setTimeout(ping, opts.interval || 200);\n\t          }\n\t        });\n\t      }\n\t      // Ping the http if it's finished compaction\n\t      ping();\n\t    });\n\t  });\n\t\n\t  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n\t    var self = this;\n\t\n\t    function doBulkGet(cb) {\n\t      var params = {};\n\t      if (opts.revs) {\n\t        params.revs = true;\n\t      }\n\t      if (opts.attachments) {\n\t        /* istanbul ignore next */\n\t        params.attachments = true;\n\t      }\n\t      ajax$$({}, {\n\t        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n\t        method: 'POST',\n\t        body: { docs: opts.docs}\n\t      }, cb);\n\t    }\n\t\n\t    function doBulkGetShim() {\n\t      // avoid \"url too long error\" by splitting up into multiple requests\n\t      var batchSize = MAX_SIMULTANEOUS_REVS;\n\t      var numBatches = Math.ceil(opts.docs.length / batchSize);\n\t      var numDone = 0;\n\t      var results = new Array(numBatches);\n\t\n\t      function onResult(batchNum) {\n\t        return function (err, res) {\n\t          // err is impossible because shim returns a list of errs in that case\n\t          results[batchNum] = res.results;\n\t          if (++numDone === numBatches) {\n\t            callback(null, {results: flatten(results)});\n\t          }\n\t        };\n\t      }\n\t\n\t      for (var i = 0; i < numBatches; i++) {\n\t        var subOpts = pick(opts, ['revs', 'attachments']);\n\t        subOpts.ajax = ajaxOpts;\n\t        subOpts.docs = opts.docs.slice(i * batchSize,\n\t          Math.min(opts.docs.length, (i + 1) * batchSize));\n\t        bulkGet(self, subOpts, onResult(i));\n\t      }\n\t    }\n\t\n\t    // mark the whole database as either supporting or not supporting _bulk_get\n\t    var dbUrl = genUrl(host, '');\n\t    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\t\n\t    if (typeof supportsBulkGet !== 'boolean') {\n\t      // check if this database supports _bulk_get\n\t      doBulkGet(function (err, res) {\n\t        /* istanbul ignore else */\n\t        if (err) {\n\t          var status = Math.floor(err.status / 100);\n\t          /* istanbul ignore else */\n\t          if (status === 4 || status === 5) { // 40x or 50x\n\t            supportsBulkGetMap[dbUrl] = false;\n\t            explainError(\n\t              err.status,\n\t              'PouchDB is just detecting if the remote ' +\n\t              'supports the _bulk_get API.'\n\t            );\n\t            doBulkGetShim();\n\t          } else {\n\t            callback(err);\n\t          }\n\t        } else {\n\t          supportsBulkGetMap[dbUrl] = true;\n\t          callback(null, res);\n\t        }\n\t      });\n\t    } else if (supportsBulkGet) {\n\t      /* istanbul ignore next */\n\t      doBulkGet(callback);\n\t    } else {\n\t      doBulkGetShim();\n\t    }\n\t  });\n\t\n\t  // Calls GET on the host, which gets back a JSON string containing\n\t  //    couchdb: A welcome string\n\t  //    version: The version of CouchDB it is running\n\t  api._info = function (callback) {\n\t    setup().then(function () {\n\t      ajax$$({}, {\n\t        method: 'GET',\n\t        url: genDBUrl(host, '')\n\t      }, function (err, res) {\n\t        /* istanbul ignore next */\n\t        if (err) {\n\t        return callback(err);\n\t        }\n\t        res.host = genDBUrl(host, '');\n\t        callback(null, res);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t  // Get the document with the given id from the database given by host.\n\t  // The id could be solely the _id in the database, or it may be a\n\t  // _design/ID or _local/ID path\n\t  api.get = adapterFun$$('get', function (id, opts, callback) {\n\t    // If no options were given, set the callback to the second parameter\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t\n\t    // List of parameters to add to the GET request\n\t    var params = {};\n\t\n\t    if (opts.revs) {\n\t      params.revs = true;\n\t    }\n\t\n\t    if (opts.revs_info) {\n\t      params.revs_info = true;\n\t    }\n\t\n\t    if (opts.open_revs) {\n\t      if (opts.open_revs !== \"all\") {\n\t        opts.open_revs = JSON.stringify(opts.open_revs);\n\t      }\n\t      params.open_revs = opts.open_revs;\n\t    }\n\t\n\t    if (opts.rev) {\n\t      params.rev = opts.rev;\n\t    }\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = opts.conflicts;\n\t    }\n\t\n\t    id = encodeDocId(id);\n\t\n\t    // Set the options for the ajax call\n\t    var options = {\n\t      method: 'GET',\n\t      url: genDBUrl(host, id + paramsToStr(params))\n\t    };\n\t\n\t    function fetchAttachments(doc) {\n\t      var atts = doc._attachments;\n\t      var filenames = atts && Object.keys(atts);\n\t      if (!atts || !filenames.length) {\n\t        return;\n\t      }\n\t      // we fetch these manually in separate XHRs, because\n\t      // Sync Gateway would normally send it back as multipart/mixed,\n\t      // which we cannot parse. Also, this is more efficient than\n\t      // receiving attachments as base64-encoded strings.\n\t      function fetch() {\n\t\n\t        if (!filenames.length) {\n\t          return null;\n\t        }\n\t\n\t        var filename = filenames.pop();\n\t        var att = atts[filename];\n\t        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n\t          '?rev=' + doc._rev;\n\t        return ajaxPromise(opts, {\n\t          method: 'GET',\n\t          url: genDBUrl(host, path),\n\t          binary: true\n\t        }).then(function (blob) {\n\t          if (opts.binary) {\n\t            return blob;\n\t          }\n\t          return new PouchPromise(function (resolve) {\n\t            blobToBase64(blob, resolve);\n\t          });\n\t        }).then(function (data) {\n\t          delete att.stub;\n\t          delete att.length;\n\t          att.data = data;\n\t        });\n\t      }\n\t\n\t      // This limits the number of parallel xhr requests to 5 any time\n\t      // to avoid issues with maximum browser request limits\n\t      return new PromisePool(fetch, 5, {promise: PouchPromise}).start();\n\t    }\n\t\n\t    function fetchAllAttachments(docOrDocs) {\n\t      if (Array.isArray(docOrDocs)) {\n\t        return PouchPromise.all(docOrDocs.map(function (doc) {\n\t          if (doc.ok) {\n\t            return fetchAttachments(doc.ok);\n\t          }\n\t        }));\n\t      }\n\t      return fetchAttachments(docOrDocs);\n\t    }\n\t\n\t    ajaxPromise(opts, options).then(function (res) {\n\t      return PouchPromise.resolve().then(function () {\n\t        if (opts.attachments) {\n\t          return fetchAllAttachments(res);\n\t        }\n\t      }).then(function () {\n\t        callback(null, res);\n\t      });\n\t    }).catch(callback);\n\t  });\n\t\n\t  // Delete the document given by doc from the database given by host.\n\t  api.remove = adapterFun$$('remove',\n\t      function (docOrId, optsOrRev, opts, callback) {\n\t    var doc;\n\t    if (typeof optsOrRev === 'string') {\n\t      // id, rev, opts, callback style\n\t      doc = {\n\t        _id: docOrId,\n\t        _rev: optsOrRev\n\t      };\n\t      if (typeof opts === 'function') {\n\t        callback = opts;\n\t        opts = {};\n\t      }\n\t    } else {\n\t      // doc, opts, callback style\n\t      doc = docOrId;\n\t      if (typeof optsOrRev === 'function') {\n\t        callback = optsOrRev;\n\t        opts = {};\n\t      } else {\n\t        callback = opts;\n\t        opts = optsOrRev;\n\t      }\n\t    }\n\t\n\t    var rev = (doc._rev || opts.rev);\n\t\n\t    // Delete the document\n\t    ajax$$(opts, {\n\t      method: 'DELETE',\n\t      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev\n\t    }, callback);\n\t  });\n\t\n\t  function encodeAttachmentId(attachmentId) {\n\t    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n\t  }\n\t\n\t  // Get the attachment\n\t  api.getAttachment =\n\t    adapterFun$$('getAttachment', function (docId, attachmentId, opts,\n\t                                                callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n\t    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n\t      encodeAttachmentId(attachmentId) + params;\n\t    ajax$$(opts, {\n\t      method: 'GET',\n\t      url: url,\n\t      binary: true\n\t    }, callback);\n\t  });\n\t\n\t  // Remove the attachment given by the id and rev\n\t  api.removeAttachment =\n\t    adapterFun$$('removeAttachment', function (docId, attachmentId, rev,\n\t                                                   callback) {\n\t\n\t    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n\t      encodeAttachmentId(attachmentId)) + '?rev=' + rev;\n\t\n\t    ajax$$({}, {\n\t      method: 'DELETE',\n\t      url: url\n\t    }, callback);\n\t  });\n\t\n\t  // Add the attachment given by blob and its contentType property\n\t  // to the document with the given id, the revision given by rev, and\n\t  // add it to the database given by host.\n\t  api.putAttachment =\n\t    adapterFun$$('putAttachment', function (docId, attachmentId, rev, blob,\n\t                                                type, callback) {\n\t    if (typeof type === 'function') {\n\t      callback = type;\n\t      type = blob;\n\t      blob = rev;\n\t      rev = null;\n\t    }\n\t    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n\t    var url = genDBUrl(host, id);\n\t    if (rev) {\n\t      url += '?rev=' + rev;\n\t    }\n\t\n\t    if (typeof blob === 'string') {\n\t      // input is assumed to be a base64 string\n\t      var binary;\n\t      try {\n\t        binary = atob$1(blob);\n\t      } catch (err) {\n\t        return callback(createError(BAD_ARG,\n\t                        'Attachment is not a valid base64 string'));\n\t      }\n\t      blob = binary ? binStringToBluffer(binary, type) : '';\n\t    }\n\t\n\t    var opts = {\n\t      headers: {'Content-Type': type},\n\t      method: 'PUT',\n\t      url: url,\n\t      processData: false,\n\t      body: blob,\n\t      timeout: ajaxOpts.timeout || 60000\n\t    };\n\t    // Add the attachment\n\t    ajax$$({}, opts, callback);\n\t  });\n\t\n\t  // Update/create multiple documents given by req in the database\n\t  // given by host.\n\t  api._bulkDocs = function (req, opts, callback) {\n\t    // If new_edits=false then it prevents the database from creating\n\t    // new revision numbers for the documents. Instead it just uses\n\t    // the old ones. This is used in database replication.\n\t    req.new_edits = opts.new_edits;\n\t\n\t    setup().then(function () {\n\t      return PouchPromise.all(req.docs.map(preprocessAttachments$1));\n\t    }).then(function () {\n\t      // Update/create the documents\n\t      ajax$$(opts, {\n\t        method: 'POST',\n\t        url: genDBUrl(host, '_bulk_docs'),\n\t        timeout: opts.timeout,\n\t        body: req\n\t      }, function (err, results) {\n\t        if (err) {\n\t          return callback(err);\n\t        }\n\t        results.forEach(function (result) {\n\t          result.ok = true; // smooths out cloudant not adding this\n\t        });\n\t        callback(null, results);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t\n\t  // Update/create document\n\t  api._put = function (doc, opts, callback) {\n\t    setup().then(function () {\n\t      return preprocessAttachments$1(doc);\n\t    }).then(function () {\n\t      // Update/create the document\n\t      ajax$$(opts, {\n\t        method: 'PUT',\n\t        url: genDBUrl(host, encodeDocId(doc._id)),\n\t        body: doc\n\t      }, function (err, result) {\n\t        if (err) {\n\t          return callback(err);\n\t        }\n\t        callback(null, result);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t\n\t  // Get a listing of the documents in the database given\n\t  // by host and ordered by increasing id.\n\t  api.allDocs = adapterFun$$('allDocs', function (opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t\n\t    // List of parameters to add to the GET request\n\t    var params = {};\n\t    var body;\n\t    var method = 'GET';\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = true;\n\t    }\n\t\n\t    if (opts.descending) {\n\t      params.descending = true;\n\t    }\n\t\n\t    if (opts.include_docs) {\n\t      params.include_docs = true;\n\t    }\n\t\n\t    // added in CouchDB 1.6.0\n\t    if (opts.attachments) {\n\t      params.attachments = true;\n\t    }\n\t\n\t    if (opts.key) {\n\t      params.key = JSON.stringify(opts.key);\n\t    }\n\t\n\t    if (opts.start_key) {\n\t      opts.startkey = opts.start_key;\n\t    }\n\t\n\t    if (opts.startkey) {\n\t      params.startkey = JSON.stringify(opts.startkey);\n\t    }\n\t\n\t    if (opts.end_key) {\n\t      opts.endkey = opts.end_key;\n\t    }\n\t\n\t    if (opts.endkey) {\n\t      params.endkey = JSON.stringify(opts.endkey);\n\t    }\n\t\n\t    if (typeof opts.inclusive_end !== 'undefined') {\n\t      params.inclusive_end = !!opts.inclusive_end;\n\t    }\n\t\n\t    if (typeof opts.limit !== 'undefined') {\n\t      params.limit = opts.limit;\n\t    }\n\t\n\t    if (typeof opts.skip !== 'undefined') {\n\t      params.skip = opts.skip;\n\t    }\n\t\n\t    var paramStr = paramsToStr(params);\n\t\n\t    if (typeof opts.keys !== 'undefined') {\n\t      method = 'POST';\n\t      body = {keys: opts.keys};\n\t    }\n\t\n\t    // Get the document listing\n\t    ajaxPromise(opts, {\n\t      method: method,\n\t      url: genDBUrl(host, '_all_docs' + paramStr),\n\t      body: body\n\t    }).then(function (res) {\n\t      if (opts.include_docs && opts.attachments && opts.binary) {\n\t        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n\t      }\n\t      callback(null, res);\n\t    }).catch(callback);\n\t  });\n\t\n\t  // Get a list of changes made to documents in the database given by host.\n\t  // TODO According to the README, there should be two other methods here,\n\t  // api.changes.addListener and api.changes.removeListener.\n\t  api._changes = function (opts) {\n\t\n\t    // We internally page the results of a changes request, this means\n\t    // if there is a large set of changes to be returned we can start\n\t    // processing them quicker instead of waiting on the entire\n\t    // set of changes to return and attempting to process them at once\n\t    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\t\n\t    opts = clone(opts);\n\t    opts.timeout = ('timeout' in opts) ? opts.timeout :\n\t      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n\t      30 * 1000;\n\t\n\t    // We give a 5 second buffer for CouchDB changes to respond with\n\t    // an ok timeout (if a timeout it set)\n\t    var params = opts.timeout ? {timeout: opts.timeout - (5 * 1000)} : {};\n\t    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n\t    var returnDocs;\n\t    if ('return_docs' in opts) {\n\t      returnDocs = opts.return_docs;\n\t    } else if ('returnDocs' in opts) {\n\t      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t      returnDocs = opts.returnDocs;\n\t    } else {\n\t      returnDocs = true;\n\t    }\n\t    //\n\t    var leftToFetch = limit;\n\t\n\t    if (opts.style) {\n\t      params.style = opts.style;\n\t    }\n\t\n\t    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n\t      params.include_docs = true;\n\t    }\n\t\n\t    if (opts.attachments) {\n\t      params.attachments = true;\n\t    }\n\t\n\t    if (opts.continuous) {\n\t      params.feed = 'longpoll';\n\t    }\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = true;\n\t    }\n\t\n\t    if (opts.descending) {\n\t      params.descending = true;\n\t    }\n\t\n\t    if ('heartbeat' in opts) {\n\t      // If the heartbeat value is false, it disables the default heartbeat\n\t      if (opts.heartbeat) {\n\t        params.heartbeat = opts.heartbeat;\n\t      }\n\t    } else {\n\t      // Default heartbeat to 10 seconds\n\t      params.heartbeat = 10000;\n\t    }\n\t\n\t    if (opts.filter && typeof opts.filter === 'string') {\n\t      params.filter = opts.filter;\n\t    }\n\t\n\t    if (opts.view && typeof opts.view === 'string') {\n\t      params.filter = '_view';\n\t      params.view = opts.view;\n\t    }\n\t\n\t    // If opts.query_params exists, pass it through to the changes request.\n\t    // These parameters may be used by the filter on the source database.\n\t    if (opts.query_params && typeof opts.query_params === 'object') {\n\t      for (var param_name in opts.query_params) {\n\t        /* istanbul ignore else */\n\t        if (opts.query_params.hasOwnProperty(param_name)) {\n\t          params[param_name] = opts.query_params[param_name];\n\t        }\n\t      }\n\t    }\n\t\n\t    var method = 'GET';\n\t    var body;\n\t\n\t    if (opts.doc_ids) {\n\t      // set this automagically for the user; it's annoying that couchdb\n\t      // requires both a \"filter\" and a \"doc_ids\" param.\n\t      params.filter = '_doc_ids';\n\t      method = 'POST';\n\t      body = {doc_ids: opts.doc_ids };\n\t    }\n\t\n\t    var xhr;\n\t    var lastFetchedSeq;\n\t\n\t    // Get all the changes starting wtih the one immediately after the\n\t    // sequence number given by since.\n\t    var fetch = function (since, callback) {\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t      params.since = since;\n\t      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n\t      /* istanbul ignore next */\n\t      if (typeof params.since === \"object\") {\n\t        params.since = JSON.stringify(params.since);\n\t      }\n\t\n\t      if (opts.descending) {\n\t        if (limit) {\n\t          params.limit = leftToFetch;\n\t        }\n\t      } else {\n\t        params.limit = (!limit || leftToFetch > batchSize) ?\n\t          batchSize : leftToFetch;\n\t      }\n\t\n\t      // Set the options for the ajax call\n\t      var xhrOpts = {\n\t        method: method,\n\t        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n\t        timeout: opts.timeout,\n\t        body: body\n\t      };\n\t      lastFetchedSeq = since;\n\t\n\t      /* istanbul ignore if */\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t\n\t      // Get the changes\n\t      setup().then(function () {\n\t        xhr = ajax$$(opts, xhrOpts, callback);\n\t      }).catch(callback);\n\t    };\n\t\n\t    // If opts.since exists, get all the changes from the sequence\n\t    // number given by opts.since. Otherwise, get all the changes\n\t    // from the sequence number 0.\n\t    var results = {results: []};\n\t\n\t    var fetched = function (err, res) {\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t      var raw_results_length = 0;\n\t      // If the result of the ajax call (res) contains changes (res.results)\n\t      if (res && res.results) {\n\t        raw_results_length = res.results.length;\n\t        results.last_seq = res.last_seq;\n\t        // For each change\n\t        var req = {};\n\t        req.query = opts.query_params;\n\t        res.results = res.results.filter(function (c) {\n\t          leftToFetch--;\n\t          var ret = filterChange(opts)(c);\n\t          if (ret) {\n\t            if (opts.include_docs && opts.attachments && opts.binary) {\n\t              readAttachmentsAsBlobOrBuffer(c);\n\t            }\n\t            if (returnDocs) {\n\t              results.results.push(c);\n\t            }\n\t            opts.onChange(c);\n\t          }\n\t          return ret;\n\t        });\n\t      } else if (err) {\n\t        // In case of an error, stop listening for changes and call\n\t        // opts.complete\n\t        opts.aborted = true;\n\t        opts.complete(err);\n\t        return;\n\t      }\n\t\n\t      // The changes feed may have timed out with no results\n\t      // if so reuse last update sequence\n\t      if (res && res.last_seq) {\n\t        lastFetchedSeq = res.last_seq;\n\t      }\n\t\n\t      var finished = (limit && leftToFetch <= 0) ||\n\t        (res && raw_results_length < batchSize) ||\n\t        (opts.descending);\n\t\n\t      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n\t        // Queue a call to fetch again with the newest sequence number\n\t        setTimeout(function () { fetch(lastFetchedSeq, fetched); }, 0);\n\t      } else {\n\t        // We're done, call the callback\n\t        opts.complete(null, results);\n\t      }\n\t    };\n\t\n\t    fetch(opts.since || 0, fetched);\n\t\n\t    // Return a method to cancel this method from processing any more\n\t    return {\n\t      cancel: function () {\n\t        opts.aborted = true;\n\t        if (xhr) {\n\t          xhr.abort();\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  // Given a set of document/revision IDs (given by req), tets the subset of\n\t  // those that do NOT correspond to revisions stored in the database.\n\t  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n\t  api.revsDiff = adapterFun$$('revsDiff', function (req, opts, callback) {\n\t    // If no options were given, set the callback to be the second parameter\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t\n\t    // Get the missing document/revision IDs\n\t    ajax$$(opts, {\n\t      method: 'POST',\n\t      url: genDBUrl(host, '_revs_diff'),\n\t      body: req\n\t    }, callback);\n\t  });\n\t\n\t  api._close = function (callback) {\n\t    callback();\n\t  };\n\t\n\t  api._destroy = function (options, callback) {\n\t    ajax$$(options, {\n\t      url: genDBUrl(host, ''),\n\t      method: 'DELETE'\n\t    }, function (err, resp) {\n\t      if (err && err.status && err.status !== 404) {\n\t        return callback(err);\n\t      }\n\t      callback(null, resp);\n\t    });\n\t  };\n\t}\n\t\n\t// HttpPouch is a valid adapter.\n\tHttpPouch.valid = function () {\n\t  return true;\n\t};\n\t\n\tfunction HttpPouch$1 (PouchDB) {\n\t  PouchDB.adapter('http', HttpPouch, false);\n\t  PouchDB.adapter('https', HttpPouch, false);\n\t}\n\t\n\tfunction pad(str, padWith, upToLength) {\n\t  var padding = '';\n\t  var targetLength = upToLength - str.length;\n\t  /* istanbul ignore next */\n\t  while (padding.length < targetLength) {\n\t    padding += padWith;\n\t  }\n\t  return padding;\n\t}\n\t\n\tfunction padLeft(str, padWith, upToLength) {\n\t  var padding = pad(str, padWith, upToLength);\n\t  return padding + str;\n\t}\n\t\n\tvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\n\tvar MAGNITUDE_DIGITS = 3; // ditto\n\tvar SEP = ''; // set to '_' for easier debugging \n\t\n\tfunction collate(a, b) {\n\t\n\t  if (a === b) {\n\t    return 0;\n\t  }\n\t\n\t  a = normalizeKey(a);\n\t  b = normalizeKey(b);\n\t\n\t  var ai = collationIndex(a);\n\t  var bi = collationIndex(b);\n\t  if ((ai - bi) !== 0) {\n\t    return ai - bi;\n\t  }\n\t  if (a === null) {\n\t    return 0;\n\t  }\n\t  switch (typeof a) {\n\t    case 'number':\n\t      return a - b;\n\t    case 'boolean':\n\t      return a === b ? 0 : (a < b ? -1 : 1);\n\t    case 'string':\n\t      return stringCollate(a, b);\n\t  }\n\t  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n\t}\n\t\n\t// couch considers null/NaN/Infinity/-Infinity === undefined,\n\t// for the purposes of mapreduce indexes. also, dates get stringified.\n\tfunction normalizeKey(key) {\n\t  switch (typeof key) {\n\t    case 'undefined':\n\t      return null;\n\t    case 'number':\n\t      if (key === Infinity || key === -Infinity || isNaN(key)) {\n\t        return null;\n\t      }\n\t      return key;\n\t    case 'object':\n\t      var origKey = key;\n\t      if (Array.isArray(key)) {\n\t        var len = key.length;\n\t        key = new Array(len);\n\t        for (var i = 0; i < len; i++) {\n\t          key[i] = normalizeKey(origKey[i]);\n\t        }\n\t      /* istanbul ignore next */\n\t      } else if (key instanceof Date) {\n\t        return key.toJSON();\n\t      } else if (key !== null) { // generic object\n\t        key = {};\n\t        for (var k in origKey) {\n\t          if (origKey.hasOwnProperty(k)) {\n\t            var val = origKey[k];\n\t            if (typeof val !== 'undefined') {\n\t              key[k] = normalizeKey(val);\n\t            }\n\t          }\n\t        }\n\t      }\n\t  }\n\t  return key;\n\t}\n\t\n\tfunction indexify(key) {\n\t  if (key !== null) {\n\t    switch (typeof key) {\n\t      case 'boolean':\n\t        return key ? 1 : 0;\n\t      case 'number':\n\t        return numToIndexableString(key);\n\t      case 'string':\n\t        // We've to be sure that key does not contain \\u0000\n\t        // Do order-preserving replacements:\n\t        // 0 -> 1, 1\n\t        // 1 -> 1, 2\n\t        // 2 -> 2, 2\n\t        return key\n\t          .replace(/\\u0002/g, '\\u0002\\u0002')\n\t          .replace(/\\u0001/g, '\\u0001\\u0002')\n\t          .replace(/\\u0000/g, '\\u0001\\u0001');\n\t      case 'object':\n\t        var isArray = Array.isArray(key);\n\t        var arr = isArray ? key : Object.keys(key);\n\t        var i = -1;\n\t        var len = arr.length;\n\t        var result = '';\n\t        if (isArray) {\n\t          while (++i < len) {\n\t            result += toIndexableString(arr[i]);\n\t          }\n\t        } else {\n\t          while (++i < len) {\n\t            var objKey = arr[i];\n\t            result += toIndexableString(objKey) +\n\t                toIndexableString(key[objKey]);\n\t          }\n\t        }\n\t        return result;\n\t    }\n\t  }\n\t  return '';\n\t}\n\t\n\t// convert the given key to a string that would be appropriate\n\t// for lexical sorting, e.g. within a database, where the\n\t// sorting is the same given by the collate() function.\n\tfunction toIndexableString(key) {\n\t  var zero = '\\u0000';\n\t  key = normalizeKey(key);\n\t  return collationIndex(key) + SEP + indexify(key) + zero;\n\t}\n\t\n\tfunction parseNumber(str, i) {\n\t  var originalIdx = i;\n\t  var num;\n\t  var zero = str[i] === '1';\n\t  if (zero) {\n\t    num = 0;\n\t    i++;\n\t  } else {\n\t    var neg = str[i] === '0';\n\t    i++;\n\t    var numAsString = '';\n\t    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n\t    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n\t    /* istanbul ignore next */\n\t    if (neg) {\n\t      magnitude = -magnitude;\n\t    }\n\t    i += MAGNITUDE_DIGITS;\n\t    while (true) {\n\t      var ch = str[i];\n\t      if (ch === '\\u0000') {\n\t        break;\n\t      } else {\n\t        numAsString += ch;\n\t      }\n\t      i++;\n\t    }\n\t    numAsString = numAsString.split('.');\n\t    if (numAsString.length === 1) {\n\t      num = parseInt(numAsString, 10);\n\t    } else {\n\t      /* istanbul ignore next */\n\t      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n\t    }\n\t    /* istanbul ignore next */\n\t    if (neg) {\n\t      num = num - 10;\n\t    }\n\t    /* istanbul ignore next */\n\t    if (magnitude !== 0) {\n\t      // parseFloat is more reliable than pow due to rounding errors\n\t      // e.g. Number.MAX_VALUE would return Infinity if we did\n\t      // num * Math.pow(10, magnitude);\n\t      num = parseFloat(num + 'e' + magnitude);\n\t    }\n\t  }\n\t  return {num: num, length : i - originalIdx};\n\t}\n\t\n\t// move up the stack while parsing\n\t// this function moved outside of parseIndexableString for performance\n\tfunction pop(stack, metaStack) {\n\t  var obj = stack.pop();\n\t\n\t  if (metaStack.length) {\n\t    var lastMetaElement = metaStack[metaStack.length - 1];\n\t    if (obj === lastMetaElement.element) {\n\t      // popping a meta-element, e.g. an object whose value is another object\n\t      metaStack.pop();\n\t      lastMetaElement = metaStack[metaStack.length - 1];\n\t    }\n\t    var element = lastMetaElement.element;\n\t    var lastElementIndex = lastMetaElement.index;\n\t    if (Array.isArray(element)) {\n\t      element.push(obj);\n\t    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t      var key = stack.pop();\n\t      element[key] = obj;\n\t    } else {\n\t      stack.push(obj); // obj with key only\n\t    }\n\t  }\n\t}\n\t\n\tfunction parseIndexableString(str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t\n\t  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\t  while (true) {\n\t    var collationIndex = str[i++];\n\t    if (collationIndex === '\\u0000') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case '1':\n\t        stack.push(null);\n\t        break;\n\t      case '2':\n\t        stack.push(str[i] === '1');\n\t        i++;\n\t        break;\n\t      case '3':\n\t        var parsedNum = parseNumber(str, i);\n\t        stack.push(parsedNum.num);\n\t        i += parsedNum.length;\n\t        break;\n\t      case '4':\n\t        var parsedStr = '';\n\t        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\t        while (true) {\n\t          var ch = str[i];\n\t          if (ch === '\\u0000') {\n\t            break;\n\t          }\n\t          parsedStr += ch;\n\t          i++;\n\t        }\n\t        // perform the reverse of the order-preserving replacement\n\t        // algorithm (see above)\n\t        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n\t          .replace(/\\u0001\\u0002/g, '\\u0001')\n\t          .replace(/\\u0002\\u0002/g, '\\u0002');\n\t        stack.push(parsedStr);\n\t        break;\n\t      case '5':\n\t        var arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '6':\n\t        var objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      /* istanbul ignore next */\n\t      default:\n\t        throw new Error(\n\t          'bad collationIndex or unexpectedly reached end of input: ' +\n\t            collationIndex);\n\t    }\n\t  }\n\t}\n\t\n\tfunction arrayCollate(a, b) {\n\t  var len = Math.min(a.length, b.length);\n\t  for (var i = 0; i < len; i++) {\n\t    var sort = collate(a[i], b[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t  }\n\t  return (a.length === b.length) ? 0 :\n\t    (a.length > b.length) ? 1 : -1;\n\t}\n\tfunction stringCollate(a, b) {\n\t  // See: https://github.com/daleharvey/pouchdb/issues/40\n\t  // This is incompatible with the CouchDB implementation, but its the\n\t  // best we can do for now\n\t  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n\t}\n\tfunction objectCollate(a, b) {\n\t  var ak = Object.keys(a), bk = Object.keys(b);\n\t  var len = Math.min(ak.length, bk.length);\n\t  for (var i = 0; i < len; i++) {\n\t    // First sort the keys\n\t    var sort = collate(ak[i], bk[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t    // if the keys are equal sort the values\n\t    sort = collate(a[ak[i]], b[bk[i]]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t\n\t  }\n\t  return (ak.length === bk.length) ? 0 :\n\t    (ak.length > bk.length) ? 1 : -1;\n\t}\n\t// The collation is defined by erlangs ordered terms\n\t// the atoms null, true, false come first, then numbers, strings,\n\t// arrays, then objects\n\t// null/undefined/NaN/Infinity/-Infinity are all considered null\n\tfunction collationIndex(x) {\n\t  var id = ['boolean', 'number', 'string', 'object'];\n\t  var idx = id.indexOf(typeof x);\n\t  //false if -1 otherwise true, but fast!!!!1\n\t  if (~idx) {\n\t    if (x === null) {\n\t      return 1;\n\t    }\n\t    if (Array.isArray(x)) {\n\t      return 5;\n\t    }\n\t    return idx < 3 ? (idx + 2) : (idx + 3);\n\t  }\n\t  /* istanbul ignore next */\n\t  if (Array.isArray(x)) {\n\t    return 5;\n\t  }\n\t}\n\t\n\t// conversion:\n\t// x yyy zz...zz\n\t// x = 0 for negative, 1 for 0, 2 for positive\n\t// y = exponent (for negative numbers negated) moved so that it's >= 0\n\t// z = mantisse\n\tfunction numToIndexableString(num) {\n\t\n\t  if (num === 0) {\n\t    return '1';\n\t  }\n\t\n\t  // convert number to exponential format for easier and\n\t  // more succinct string sorting\n\t  var expFormat = num.toExponential().split(/e\\+?/);\n\t  var magnitude = parseInt(expFormat[1], 10);\n\t\n\t  var neg = num < 0;\n\t\n\t  var result = neg ? '0' : '2';\n\t\n\t  // first sort by magnitude\n\t  // it's easier if all magnitudes are positive\n\t  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n\t  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\t\n\t  result += SEP + magString;\n\t\n\t  // then sort by the factor\n\t  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n\t  /* istanbul ignore next */\n\t  if (neg) { // for negative reverse ordering\n\t    factor = 10 - factor;\n\t  }\n\t\n\t  var factorStr = factor.toFixed(20);\n\t\n\t  // strip zeros from the end\n\t  factorStr = factorStr.replace(/\\.?0+$/, '');\n\t\n\t  result += SEP + factorStr;\n\t\n\t  return result;\n\t}\n\t\n\t/*\n\t * Simple task queue to sequentialize actions. Assumes\n\t * callbacks will eventually fire (once).\n\t */\n\t\n\tfunction TaskQueue$1() {\n\t  this.promise = new PouchPromise(function (fulfill) {fulfill(); });\n\t}\n\tTaskQueue$1.prototype.add = function (promiseFactory) {\n\t  this.promise = this.promise.catch(function () {\n\t    // just recover\n\t  }).then(function () {\n\t    return promiseFactory();\n\t  });\n\t  return this.promise;\n\t};\n\tTaskQueue$1.prototype.finish = function () {\n\t  return this.promise;\n\t};\n\t\n\tfunction createView(opts) {\n\t  var sourceDB = opts.db;\n\t  var viewName = opts.viewName;\n\t  var mapFun = opts.map;\n\t  var reduceFun = opts.reduce;\n\t  var temporary = opts.temporary;\n\t\n\t  // the \"undefined\" part is for backwards compatibility\n\t  var viewSignature = mapFun.toString() + (reduceFun && reduceFun.toString()) +\n\t    'undefined';\n\t\n\t  var cachedViews;\n\t  if (!temporary) {\n\t    // cache this to ensure we don't try to update the same view twice\n\t    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n\t    if (cachedViews[viewSignature]) {\n\t      return cachedViews[viewSignature];\n\t    }\n\t  }\n\t\n\t  var promiseForView = sourceDB.info().then(function (info) {\n\t\n\t    var depDbName = info.db_name + '-mrview-' +\n\t      (temporary ? 'temp' : stringMd5(viewSignature));\n\t\n\t    // save the view name in the source db so it can be cleaned up if necessary\n\t    // (e.g. when the _design doc is deleted, remove all associated view data)\n\t    function diffFunction(doc) {\n\t      doc.views = doc.views || {};\n\t      var fullViewName = viewName;\n\t      if (fullViewName.indexOf('/') === -1) {\n\t        fullViewName = viewName + '/' + viewName;\n\t      }\n\t      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n\t      /* istanbul ignore if */\n\t      if (depDbs[depDbName]) {\n\t        return; // no update necessary\n\t      }\n\t      depDbs[depDbName] = true;\n\t      return doc;\n\t    }\n\t    return upsert(sourceDB, '_local/mrviews', diffFunction).then(function () {\n\t      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n\t        var db = res.db;\n\t        db.auto_compaction = true;\n\t        var view = {\n\t          name: depDbName,\n\t          db: db,\n\t          sourceDB: sourceDB,\n\t          adapter: sourceDB.adapter,\n\t          mapFun: mapFun,\n\t          reduceFun: reduceFun\n\t        };\n\t        return view.db.get('_local/lastSeq').catch(function (err) {\n\t          /* istanbul ignore if */\n\t          if (err.status !== 404) {\n\t            throw err;\n\t          }\n\t        }).then(function (lastSeqDoc) {\n\t          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n\t          if (cachedViews) {\n\t            view.db.once('destroyed', function () {\n\t              delete cachedViews[viewSignature];\n\t            });\n\t          }\n\t          return view;\n\t        });\n\t      });\n\t    });\n\t  });\n\t\n\t  if (cachedViews) {\n\t    cachedViews[viewSignature] = promiseForView;\n\t  }\n\t  return promiseForView;\n\t}\n\t\n\tfunction QueryParseError(message) {\n\t  this.status = 400;\n\t  this.name = 'query_parse_error';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, QueryParseError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(QueryParseError, Error);\n\t\n\tfunction NotFoundError(message) {\n\t  this.status = 404;\n\t  this.name = 'not_found';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, NotFoundError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(NotFoundError, Error);\n\t\n\tfunction BuiltInError(message) {\n\t  this.status = 500;\n\t  this.name = 'invalid_value';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, BuiltInError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(BuiltInError, Error);\n\t\n\tfunction createBuiltInError(name) {\n\t  var message = 'builtin ' + name +\n\t    ' function requires map values to be numbers' +\n\t    ' or number arrays';\n\t  return new BuiltInError(message);\n\t}\n\t\n\tfunction sum(values) {\n\t  var result = 0;\n\t  for (var i = 0, len = values.length; i < len; i++) {\n\t    var num = values[i];\n\t    if (typeof num !== 'number') {\n\t      if (Array.isArray(num)) {\n\t        // lists of numbers are also allowed, sum them separately\n\t        result = typeof result === 'number' ? [result] : result;\n\t        for (var j = 0, jLen = num.length; j < jLen; j++) {\n\t          var jNum = num[j];\n\t          if (typeof jNum !== 'number') {\n\t            throw createBuiltInError('_sum');\n\t          } else if (typeof result[j] === 'undefined') {\n\t            result.push(jNum);\n\t          } else {\n\t            result[j] += jNum;\n\t          }\n\t        }\n\t      } else { // not array/number\n\t        throw createBuiltInError('_sum');\n\t      }\n\t    } else if (typeof result === 'number') {\n\t      result += num;\n\t    } else { // add number to array\n\t      result[0] += num;\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tvar log$2 = guardedConsole.bind(null, 'log');\n\tvar isArray = Array.isArray;\n\tvar toJSON = JSON.parse;\n\t\n\tfunction evalFunctionWithEval(func, emit) {\n\t  return scopedEval(\n\t    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n\t    {\n\t      emit: emit,\n\t      sum: sum,\n\t      log: log$2,\n\t      isArray: isArray,\n\t      toJSON: toJSON\n\t    }\n\t  );\n\t}\n\t\n\tvar promisedCallback = function (promise, callback) {\n\t  if (callback) {\n\t    promise.then(function (res) {\n\t      process.nextTick(function () {\n\t        callback(null, res);\n\t      });\n\t    }, function (reason) {\n\t      process.nextTick(function () {\n\t        callback(reason);\n\t      });\n\t    });\n\t  }\n\t  return promise;\n\t};\n\t\n\tvar callbackify = function (fun) {\n\t  return getArguments(function (args) {\n\t    var cb = args.pop();\n\t    var promise = fun.apply(this, args);\n\t    if (typeof cb === 'function') {\n\t      promisedCallback(promise, cb);\n\t    }\n\t    return promise;\n\t  });\n\t};\n\t\n\t// Promise finally util similar to Q.finally\n\tvar fin = function (promise, finalPromiseFactory) {\n\t  return promise.then(function (res) {\n\t    return finalPromiseFactory().then(function () {\n\t      return res;\n\t    });\n\t  }, function (reason) {\n\t    return finalPromiseFactory().then(function () {\n\t      throw reason;\n\t    });\n\t  });\n\t};\n\t\n\tvar sequentialize = function (queue, promiseFactory) {\n\t  return function () {\n\t    var args = arguments;\n\t    var that = this;\n\t    return queue.add(function () {\n\t      return promiseFactory.apply(that, args);\n\t    });\n\t  };\n\t};\n\t\n\t// uniq an array of strings, order not guaranteed\n\t// similar to underscore/lodash _.uniq\n\tvar uniq = function (arr) {\n\t  var map = {};\n\t\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    map['$' + arr[i]] = true;\n\t  }\n\t\n\t  var keys = Object.keys(map);\n\t  var output = new Array(keys.length);\n\t\n\t  for (i = 0, len = keys.length; i < len; i++) {\n\t    output[i] = keys[i].substring(1);\n\t  }\n\t  return output;\n\t};\n\t\n\tvar persistentQueues = {};\n\tvar tempViewQueue = new TaskQueue$1();\n\tvar CHANGES_BATCH_SIZE$1 = 50;\n\t\n\tfunction parseViewName(name) {\n\t  // can be either 'ddocname/viewname' or just 'viewname'\n\t  // (where the ddoc name is the same)\n\t  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n\t}\n\t\n\tfunction isGenOne(changes) {\n\t  // only return true if the current change is 1-\n\t  // and there are no other leafs\n\t  return changes.length === 1 && /^1-/.test(changes[0].rev);\n\t}\n\t\n\tfunction emitError(db, e) {\n\t  try {\n\t    db.emit('error', e);\n\t  } catch (err) {\n\t    guardedConsole('error',\n\t      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n\t      'You can debug this error by doing:\\n' +\n\t      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n\t      'Please double-check your map/reduce function.');\n\t    guardedConsole('error', e);\n\t  }\n\t}\n\t\n\tfunction tryCode$1(db, fun, args) {\n\t  // emit an event if there was an error thrown by a map/reduce function.\n\t  // putting try/catches in a single function also avoids deoptimizations.\n\t  try {\n\t    return {\n\t      output : fun.apply(null, args)\n\t    };\n\t  } catch (e) {\n\t    emitError(db, e);\n\t    return {error: e};\n\t  }\n\t}\n\t\n\tfunction sortByKeyThenValue(x, y) {\n\t  var keyCompare = collate(x.key, y.key);\n\t  return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n\t}\n\t\n\tfunction sliceResults(results, limit, skip) {\n\t  skip = skip || 0;\n\t  if (typeof limit === 'number') {\n\t    return results.slice(skip, limit + skip);\n\t  } else if (skip > 0) {\n\t    return results.slice(skip);\n\t  }\n\t  return results;\n\t}\n\t\n\tfunction rowToDocId(row) {\n\t  var val = row.value;\n\t  // Users can explicitly specify a joined doc _id, or it\n\t  // defaults to the doc _id that emitted the key/value.\n\t  var docId = (val && typeof val === 'object' && val._id) || row.id;\n\t  return docId;\n\t}\n\t\n\tfunction readAttachmentsAsBlobOrBuffer$1(res) {\n\t  res.rows.forEach(function (row) {\n\t    var atts = row.doc && row.doc._attachments;\n\t    if (!atts) {\n\t      return;\n\t    }\n\t    Object.keys(atts).forEach(function (filename) {\n\t      var att = atts[filename];\n\t      atts[filename].data = b64ToBluffer(att.data, att.content_type);\n\t    });\n\t  });\n\t}\n\t\n\tfunction postprocessAttachments(opts) {\n\t  return function (res) {\n\t    if (opts.include_docs && opts.attachments && opts.binary) {\n\t      readAttachmentsAsBlobOrBuffer$1(res);\n\t    }\n\t    return res;\n\t  };\n\t}\n\t\n\tvar builtInReduce = {\n\t  _sum: function (keys, values) {\n\t    return sum(values);\n\t  },\n\t\n\t  _count: function (keys, values) {\n\t    return values.length;\n\t  },\n\t\n\t  _stats: function (keys, values) {\n\t    // no need to implement rereduce=true, because Pouch\n\t    // will never call it\n\t    function sumsqr(values) {\n\t      var _sumsqr = 0;\n\t      for (var i = 0, len = values.length; i < len; i++) {\n\t        var num = values[i];\n\t        _sumsqr += (num * num);\n\t      }\n\t      return _sumsqr;\n\t    }\n\t    return {\n\t      sum     : sum(values),\n\t      min     : Math.min.apply(null, values),\n\t      max     : Math.max.apply(null, values),\n\t      count   : values.length,\n\t      sumsqr : sumsqr(values)\n\t    };\n\t  }\n\t};\n\t\n\tfunction addHttpParam(paramName, opts, params, asJson) {\n\t  // add an http param from opts to params, optionally json-encoded\n\t  var val = opts[paramName];\n\t  if (typeof val !== 'undefined') {\n\t    if (asJson) {\n\t      val = encodeURIComponent(JSON.stringify(val));\n\t    }\n\t    params.push(paramName + '=' + val);\n\t  }\n\t}\n\t\n\tfunction coerceInteger(integerCandidate) {\n\t  if (typeof integerCandidate !== 'undefined') {\n\t    var asNumber = Number(integerCandidate);\n\t    // prevents e.g. '1foo' or '1.1' being coerced to 1\n\t    if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n\t      return asNumber;\n\t    } else {\n\t      return integerCandidate;\n\t    }\n\t  }\n\t}\n\t\n\tfunction coerceOptions(opts) {\n\t  opts.group_level = coerceInteger(opts.group_level);\n\t  opts.limit = coerceInteger(opts.limit);\n\t  opts.skip = coerceInteger(opts.skip);\n\t  return opts;\n\t}\n\t\n\tfunction checkPositiveInteger(number) {\n\t  if (number) {\n\t    if (typeof number !== 'number') {\n\t      return  new QueryParseError('Invalid value for integer: \"' +\n\t      number + '\"');\n\t    }\n\t    if (number < 0) {\n\t      return new QueryParseError('Invalid value for positive integer: ' +\n\t        '\"' + number + '\"');\n\t    }\n\t  }\n\t}\n\t\n\tfunction checkQueryParseError(options, fun) {\n\t  var startkeyName = options.descending ? 'endkey' : 'startkey';\n\t  var endkeyName = options.descending ? 'startkey' : 'endkey';\n\t\n\t  if (typeof options[startkeyName] !== 'undefined' &&\n\t    typeof options[endkeyName] !== 'undefined' &&\n\t    collate(options[startkeyName], options[endkeyName]) > 0) {\n\t    throw new QueryParseError('No rows can match your key range, ' +\n\t    'reverse your start_key and end_key or set {descending : true}');\n\t  } else if (fun.reduce && options.reduce !== false) {\n\t    if (options.include_docs) {\n\t      throw new QueryParseError('{include_docs:true} is invalid for reduce');\n\t    } else if (options.keys && options.keys.length > 1 &&\n\t        !options.group && !options.group_level) {\n\t      throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n\t      '{group: true}');\n\t    }\n\t  }\n\t  ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n\t    var error = checkPositiveInteger(options[optionName]);\n\t    if (error) {\n\t      throw error;\n\t    }\n\t  });\n\t}\n\t\n\tfunction httpQuery(db, fun, opts) {\n\t  // List of parameters to add to the PUT request\n\t  var params = [];\n\t  var body;\n\t  var method = 'GET';\n\t\n\t  // If opts.reduce exists and is defined, then add it to the list\n\t  // of parameters.\n\t  // If reduce=false then the results are that of only the map function\n\t  // not the final result of map and reduce.\n\t  addHttpParam('reduce', opts, params);\n\t  addHttpParam('include_docs', opts, params);\n\t  addHttpParam('attachments', opts, params);\n\t  addHttpParam('limit', opts, params);\n\t  addHttpParam('descending', opts, params);\n\t  addHttpParam('group', opts, params);\n\t  addHttpParam('group_level', opts, params);\n\t  addHttpParam('skip', opts, params);\n\t  addHttpParam('stale', opts, params);\n\t  addHttpParam('conflicts', opts, params);\n\t  addHttpParam('startkey', opts, params, true);\n\t  addHttpParam('start_key', opts, params, true);\n\t  addHttpParam('endkey', opts, params, true);\n\t  addHttpParam('end_key', opts, params, true);\n\t  addHttpParam('inclusive_end', opts, params);\n\t  addHttpParam('key', opts, params, true);\n\t\n\t  // Format the list of parameters into a valid URI query string\n\t  params = params.join('&');\n\t  params = params === '' ? '' : '?' + params;\n\t\n\t  // If keys are supplied, issue a POST to circumvent GET query string limits\n\t  // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n\t  if (typeof opts.keys !== 'undefined') {\n\t    var MAX_URL_LENGTH = 2000;\n\t    // according to http://stackoverflow.com/a/417184/680742,\n\t    // the de facto URL length limit is 2000 characters\n\t\n\t    var keysAsString =\n\t      'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n\t    if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n\t      // If the keys are short enough, do a GET. we do this to work around\n\t      // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n\t      params += (params[0] === '?' ? '&' : '?') + keysAsString;\n\t    } else {\n\t      method = 'POST';\n\t      if (typeof fun === 'string') {\n\t        body = {keys: opts.keys};\n\t      } else { // fun is {map : mapfun}, so append to this\n\t        fun.keys = opts.keys;\n\t      }\n\t    }\n\t  }\n\t\n\t  // We are referencing a query defined in the design doc\n\t  if (typeof fun === 'string') {\n\t    var parts = parseViewName(fun);\n\t    return db.request({\n\t      method: method,\n\t      url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n\t      body: body\n\t    }).then(postprocessAttachments(opts));\n\t  }\n\t\n\t  // We are using a temporary view, terrible for performance, good for testing\n\t  body = body || {};\n\t  Object.keys(fun).forEach(function (key) {\n\t    if (Array.isArray(fun[key])) {\n\t      body[key] = fun[key];\n\t    } else {\n\t      body[key] = fun[key].toString();\n\t    }\n\t  });\n\t  return db.request({\n\t    method: 'POST',\n\t    url: '_temp_view' + params,\n\t    body: body\n\t  }).then(postprocessAttachments(opts));\n\t}\n\t\n\t// custom adapters can define their own api._query\n\t// and override the default behavior\n\t/* istanbul ignore next */\n\tfunction customQuery(db, fun, opts) {\n\t  return new PouchPromise(function (resolve, reject) {\n\t    db._query(fun, opts, function (err, res) {\n\t      if (err) {\n\t        return reject(err);\n\t      }\n\t      resolve(res);\n\t    });\n\t  });\n\t}\n\t\n\t// custom adapters can define their own api._viewCleanup\n\t// and override the default behavior\n\t/* istanbul ignore next */\n\tfunction customViewCleanup(db) {\n\t  return new PouchPromise(function (resolve, reject) {\n\t    db._viewCleanup(function (err, res) {\n\t      if (err) {\n\t        return reject(err);\n\t      }\n\t      resolve(res);\n\t    });\n\t  });\n\t}\n\t\n\tfunction defaultsTo(value) {\n\t  return function (reason) {\n\t    /* istanbul ignore else */\n\t    if (reason.status === 404) {\n\t      return value;\n\t    } else {\n\t      throw reason;\n\t    }\n\t  };\n\t}\n\t\n\t// returns a promise for a list of docs to update, based on the input docId.\n\t// the order doesn't matter, because post-3.2.0, bulkDocs\n\t// is an atomic operation in all three adapters.\n\tfunction getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n\t  var metaDocId = '_local/doc_' + docId;\n\t  var defaultMetaDoc = {_id: metaDocId, keys: []};\n\t  var docData = docIdsToChangesAndEmits[docId];\n\t  var indexableKeysToKeyValues = docData.indexableKeysToKeyValues;\n\t  var changes = docData.changes;\n\t\n\t  function getMetaDoc() {\n\t    if (isGenOne(changes)) {\n\t      // generation 1, so we can safely assume initial state\n\t      // for performance reasons (avoids unnecessary GETs)\n\t      return PouchPromise.resolve(defaultMetaDoc);\n\t    }\n\t    return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n\t  }\n\t\n\t  function getKeyValueDocs(metaDoc) {\n\t    if (!metaDoc.keys.length) {\n\t      // no keys, no need for a lookup\n\t      return PouchPromise.resolve({rows: []});\n\t    }\n\t    return view.db.allDocs({\n\t      keys: metaDoc.keys,\n\t      include_docs: true\n\t    });\n\t  }\n\t\n\t  function processKvDocs(metaDoc, kvDocsRes) {\n\t    var kvDocs = [];\n\t    var oldKeysMap = {};\n\t\n\t    for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n\t      var row = kvDocsRes.rows[i];\n\t      var doc = row.doc;\n\t      if (!doc) { // deleted\n\t        continue;\n\t      }\n\t      kvDocs.push(doc);\n\t      oldKeysMap[doc._id] = true;\n\t      doc._deleted = !indexableKeysToKeyValues[doc._id];\n\t      if (!doc._deleted) {\n\t        var keyValue = indexableKeysToKeyValues[doc._id];\n\t        if ('value' in keyValue) {\n\t          doc.value = keyValue.value;\n\t        }\n\t      }\n\t    }\n\t\n\t    var newKeys = Object.keys(indexableKeysToKeyValues);\n\t    newKeys.forEach(function (key) {\n\t      if (!oldKeysMap[key]) {\n\t        // new doc\n\t        var kvDoc = {\n\t          _id: key\n\t        };\n\t        var keyValue = indexableKeysToKeyValues[key];\n\t        if ('value' in keyValue) {\n\t          kvDoc.value = keyValue.value;\n\t        }\n\t        kvDocs.push(kvDoc);\n\t      }\n\t    });\n\t    metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n\t    kvDocs.push(metaDoc);\n\t\n\t    return kvDocs;\n\t  }\n\t\n\t  return getMetaDoc().then(function (metaDoc) {\n\t    return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n\t      return processKvDocs(metaDoc, kvDocsRes);\n\t    });\n\t  });\n\t}\n\t\n\t// updates all emitted key/value docs and metaDocs in the mrview database\n\t// for the given batch of documents from the source database\n\tfunction saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n\t  var seqDocId = '_local/lastSeq';\n\t  return view.db.get(seqDocId)\n\t  .catch(defaultsTo({_id: seqDocId, seq: 0}))\n\t  .then(function (lastSeqDoc) {\n\t    var docIds = Object.keys(docIdsToChangesAndEmits);\n\t    return PouchPromise.all(docIds.map(function (docId) {\n\t      return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n\t    })).then(function (listOfDocsToPersist) {\n\t      var docsToPersist = flatten(listOfDocsToPersist);\n\t      lastSeqDoc.seq = seq;\n\t      docsToPersist.push(lastSeqDoc);\n\t      // write all docs in a single operation, update the seq once\n\t      return view.db.bulkDocs({docs : docsToPersist});\n\t    });\n\t  });\n\t}\n\t\n\tfunction getQueue(view) {\n\t  var viewName = typeof view === 'string' ? view : view.name;\n\t  var queue = persistentQueues[viewName];\n\t  if (!queue) {\n\t    queue = persistentQueues[viewName] = new TaskQueue$1();\n\t  }\n\t  return queue;\n\t}\n\t\n\tfunction updateView(view) {\n\t  return sequentialize(getQueue(view), function () {\n\t    return updateViewInQueue(view);\n\t  })();\n\t}\n\t\n\tfunction updateViewInQueue(view) {\n\t  // bind the emit function once\n\t  var mapResults;\n\t  var doc;\n\t\n\t  function emit(key, value) {\n\t    var output = {id: doc._id, key: normalizeKey(key)};\n\t    // Don't explicitly store the value unless it's defined and non-null.\n\t    // This saves on storage space, because often people don't use it.\n\t    if (typeof value !== 'undefined' && value !== null) {\n\t      output.value = normalizeKey(value);\n\t    }\n\t    mapResults.push(output);\n\t  }\n\t\n\t  var mapFun;\n\t  // for temp_views one can use emit(doc, emit), see #38\n\t  if (typeof view.mapFun === \"function\" && view.mapFun.length === 2) {\n\t    var origMap = view.mapFun;\n\t    mapFun = function (doc) {\n\t      return origMap(doc, emit);\n\t    };\n\t  } else {\n\t    mapFun = evalFunctionWithEval(view.mapFun.toString(), emit);\n\t  }\n\t\n\t  var currentSeq = view.seq || 0;\n\t\n\t  function processChange(docIdsToChangesAndEmits, seq) {\n\t    return function () {\n\t      return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n\t    };\n\t  }\n\t\n\t  var queue = new TaskQueue$1();\n\t  // TODO(neojski): https://github.com/daleharvey/pouchdb/issues/1521\n\t\n\t  return new PouchPromise(function (resolve, reject) {\n\t\n\t    function complete() {\n\t      queue.finish().then(function () {\n\t        view.seq = currentSeq;\n\t        resolve();\n\t      });\n\t    }\n\t\n\t    function processNextBatch() {\n\t      view.sourceDB.changes({\n\t        conflicts: true,\n\t        include_docs: true,\n\t        style: 'all_docs',\n\t        since: currentSeq,\n\t        limit: CHANGES_BATCH_SIZE$1\n\t      }).on('complete', function (response) {\n\t        var results = response.results;\n\t        if (!results.length) {\n\t          return complete();\n\t        }\n\t        var docIdsToChangesAndEmits = {};\n\t        for (var i = 0, l = results.length; i < l; i++) {\n\t          var change = results[i];\n\t          if (change.doc._id[0] !== '_') {\n\t            mapResults = [];\n\t            doc = change.doc;\n\t\n\t            if (!doc._deleted) {\n\t              tryCode$1(view.sourceDB, mapFun, [doc]);\n\t            }\n\t            mapResults.sort(sortByKeyThenValue);\n\t\n\t            var indexableKeysToKeyValues = {};\n\t            var lastKey;\n\t            for (var j = 0, jl = mapResults.length; j < jl; j++) {\n\t              var obj = mapResults[j];\n\t              var complexKey = [obj.key, obj.id];\n\t              if (collate(obj.key, lastKey) === 0) {\n\t                complexKey.push(j); // dup key+id, so make it unique\n\t              }\n\t              var indexableKey = toIndexableString(complexKey);\n\t              indexableKeysToKeyValues[indexableKey] = obj;\n\t              lastKey = obj.key;\n\t            }\n\t            docIdsToChangesAndEmits[change.doc._id] = {\n\t              indexableKeysToKeyValues: indexableKeysToKeyValues,\n\t              changes: change.changes\n\t            };\n\t          }\n\t          currentSeq = change.seq;\n\t        }\n\t        queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\t        if (results.length < CHANGES_BATCH_SIZE$1) {\n\t          return complete();\n\t        }\n\t        return processNextBatch();\n\t      }).on('error', onError);\n\t      /* istanbul ignore next */\n\t      function onError(err) {\n\t        reject(err);\n\t      }\n\t    }\n\t\n\t    processNextBatch();\n\t  });\n\t}\n\t\n\tfunction reduceView(view, results, options) {\n\t  if (options.group_level === 0) {\n\t    delete options.group_level;\n\t  }\n\t\n\t  var shouldGroup = options.group || options.group_level;\n\t\n\t  var reduceFun;\n\t  if (builtInReduce[view.reduceFun]) {\n\t    reduceFun = builtInReduce[view.reduceFun];\n\t  } else {\n\t    reduceFun = evalFunctionWithEval(view.reduceFun.toString());\n\t  }\n\t\n\t  var groups = [];\n\t  var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n\t    options.group_level;\n\t  results.forEach(function (e) {\n\t    var last = groups[groups.length - 1];\n\t    var groupKey = shouldGroup ? e.key : null;\n\t\n\t    // only set group_level for array keys\n\t    if (shouldGroup && Array.isArray(groupKey)) {\n\t      groupKey = groupKey.slice(0, lvl);\n\t    }\n\t\n\t    if (last && collate(last.groupKey, groupKey) === 0) {\n\t      last.keys.push([e.key, e.id]);\n\t      last.values.push(e.value);\n\t      return;\n\t    }\n\t    groups.push({\n\t      keys: [[e.key, e.id]],\n\t      values: [e.value],\n\t      groupKey: groupKey\n\t    });\n\t  });\n\t  results = [];\n\t  for (var i = 0, len = groups.length; i < len; i++) {\n\t    var e = groups[i];\n\t    var reduceTry = tryCode$1(view.sourceDB, reduceFun,\n\t      [e.keys, e.values, false]);\n\t    if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n\t      // CouchDB returns an error if a built-in errors out\n\t      throw reduceTry.error;\n\t    }\n\t    results.push({\n\t      // CouchDB just sets the value to null if a non-built-in errors out\n\t      value: reduceTry.error ? null : reduceTry.output,\n\t      key: e.groupKey\n\t    });\n\t  }\n\t  // no total_rows/offset when reducing\n\t  return {rows: sliceResults(results, options.limit, options.skip)};\n\t}\n\t\n\tfunction queryView(view, opts) {\n\t  return sequentialize(getQueue(view), function () {\n\t    return queryViewInQueue(view, opts);\n\t  })();\n\t}\n\t\n\tfunction queryViewInQueue(view, opts) {\n\t  var totalRows;\n\t  var shouldReduce = view.reduceFun && opts.reduce !== false;\n\t  var skip = opts.skip || 0;\n\t  if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n\t    // equivalent query\n\t    opts.limit = 0;\n\t    delete opts.keys;\n\t  }\n\t\n\t  function fetchFromView(viewOpts) {\n\t    viewOpts.include_docs = true;\n\t    return view.db.allDocs(viewOpts).then(function (res) {\n\t      totalRows = res.total_rows;\n\t      return res.rows.map(function (result) {\n\t\n\t        // implicit migration - in older versions of PouchDB,\n\t        // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n\t        // this is tested in a migration test\n\t        /* istanbul ignore next */\n\t        if ('value' in result.doc && typeof result.doc.value === 'object' &&\n\t            result.doc.value !== null) {\n\t          var keys = Object.keys(result.doc.value).sort();\n\t          // this detection method is not perfect, but it's unlikely the user\n\t          // emitted a value which was an object with these 3 exact keys\n\t          var expectedKeys = ['id', 'key', 'value'];\n\t          if (!(keys < expectedKeys || keys > expectedKeys)) {\n\t            return result.doc.value;\n\t          }\n\t        }\n\t\n\t        var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n\t        return {\n\t          key: parsedKeyAndDocId[0],\n\t          id: parsedKeyAndDocId[1],\n\t          value: ('value' in result.doc ? result.doc.value : null)\n\t        };\n\t      });\n\t    });\n\t  }\n\t\n\t  function onMapResultsReady(rows) {\n\t    var finalResults;\n\t    if (shouldReduce) {\n\t      finalResults = reduceView(view, rows, opts);\n\t    } else {\n\t      finalResults = {\n\t        total_rows: totalRows,\n\t        offset: skip,\n\t        rows: rows\n\t      };\n\t    }\n\t    if (opts.include_docs) {\n\t      var docIds = uniq(rows.map(rowToDocId));\n\t\n\t      return view.sourceDB.allDocs({\n\t        keys: docIds,\n\t        include_docs: true,\n\t        conflicts: opts.conflicts,\n\t        attachments: opts.attachments,\n\t        binary: opts.binary\n\t      }).then(function (allDocsRes) {\n\t        var docIdsToDocs = {};\n\t        allDocsRes.rows.forEach(function (row) {\n\t          if (row.doc) {\n\t            docIdsToDocs['$' + row.id] = row.doc;\n\t          }\n\t        });\n\t        rows.forEach(function (row) {\n\t          var docId = rowToDocId(row);\n\t          var doc = docIdsToDocs['$' + docId];\n\t          if (doc) {\n\t            row.doc = doc;\n\t          }\n\t        });\n\t        return finalResults;\n\t      });\n\t    } else {\n\t      return finalResults;\n\t    }\n\t  }\n\t\n\t  if (typeof opts.keys !== 'undefined') {\n\t    var keys = opts.keys;\n\t    var fetchPromises = keys.map(function (key) {\n\t      var viewOpts = {\n\t        startkey : toIndexableString([key]),\n\t        endkey   : toIndexableString([key, {}])\n\t      };\n\t      return fetchFromView(viewOpts);\n\t    });\n\t    return PouchPromise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n\t  } else { // normal query, no 'keys'\n\t    var viewOpts = {\n\t      descending : opts.descending\n\t    };\n\t    if (opts.start_key) {\n\t        opts.startkey = opts.start_key;\n\t    }\n\t    if (opts.end_key) {\n\t        opts.endkey = opts.end_key;\n\t    }\n\t    if (typeof opts.startkey !== 'undefined') {\n\t      viewOpts.startkey = opts.descending ?\n\t        toIndexableString([opts.startkey, {}]) :\n\t        toIndexableString([opts.startkey]);\n\t    }\n\t    if (typeof opts.endkey !== 'undefined') {\n\t      var inclusiveEnd = opts.inclusive_end !== false;\n\t      if (opts.descending) {\n\t        inclusiveEnd = !inclusiveEnd;\n\t      }\n\t\n\t      viewOpts.endkey = toIndexableString(\n\t        inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);\n\t    }\n\t    if (typeof opts.key !== 'undefined') {\n\t      var keyStart = toIndexableString([opts.key]);\n\t      var keyEnd = toIndexableString([opts.key, {}]);\n\t      if (viewOpts.descending) {\n\t        viewOpts.endkey = keyStart;\n\t        viewOpts.startkey = keyEnd;\n\t      } else {\n\t        viewOpts.startkey = keyStart;\n\t        viewOpts.endkey = keyEnd;\n\t      }\n\t    }\n\t    if (!shouldReduce) {\n\t      if (typeof opts.limit === 'number') {\n\t        viewOpts.limit = opts.limit;\n\t      }\n\t      viewOpts.skip = skip;\n\t    }\n\t    return fetchFromView(viewOpts).then(onMapResultsReady);\n\t  }\n\t}\n\t\n\tfunction httpViewCleanup(db) {\n\t  return db.request({\n\t    method: 'POST',\n\t    url: '_view_cleanup'\n\t  });\n\t}\n\t\n\tfunction localViewCleanup(db) {\n\t  return db.get('_local/mrviews').then(function (metaDoc) {\n\t    var docsToViews = {};\n\t    Object.keys(metaDoc.views).forEach(function (fullViewName) {\n\t      var parts = parseViewName(fullViewName);\n\t      var designDocName = '_design/' + parts[0];\n\t      var viewName = parts[1];\n\t      docsToViews[designDocName] = docsToViews[designDocName] || {};\n\t      docsToViews[designDocName][viewName] = true;\n\t    });\n\t    var opts = {\n\t      keys : Object.keys(docsToViews),\n\t      include_docs : true\n\t    };\n\t    return db.allDocs(opts).then(function (res) {\n\t      var viewsToStatus = {};\n\t      res.rows.forEach(function (row) {\n\t        var ddocName = row.key.substring(8);\n\t        Object.keys(docsToViews[row.key]).forEach(function (viewName) {\n\t          var fullViewName = ddocName + '/' + viewName;\n\t          /* istanbul ignore if */\n\t          if (!metaDoc.views[fullViewName]) {\n\t            // new format, without slashes, to support PouchDB 2.2.0\n\t            // migration test in pouchdb's browser.migration.js verifies this\n\t            fullViewName = viewName;\n\t          }\n\t          var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n\t          // design doc deleted, or view function nonexistent\n\t          var statusIsGood = row.doc && row.doc.views &&\n\t            row.doc.views[viewName];\n\t          viewDBNames.forEach(function (viewDBName) {\n\t            viewsToStatus[viewDBName] =\n\t              viewsToStatus[viewDBName] || statusIsGood;\n\t          });\n\t        });\n\t      });\n\t      var dbsToDelete = Object.keys(viewsToStatus).filter(\n\t        function (viewDBName) { return !viewsToStatus[viewDBName]; });\n\t      var destroyPromises = dbsToDelete.map(function (viewDBName) {\n\t        return sequentialize(getQueue(viewDBName), function () {\n\t          return new db.constructor(viewDBName, db.__opts).destroy();\n\t        })();\n\t      });\n\t      return PouchPromise.all(destroyPromises).then(function () {\n\t        return {ok: true};\n\t      });\n\t    });\n\t  }, defaultsTo({ok: true}));\n\t}\n\t\n\tvar viewCleanup = callbackify(function () {\n\t  var db = this;\n\t  if (db.type() === 'http') {\n\t    return httpViewCleanup(db);\n\t  }\n\t  /* istanbul ignore next */\n\t  if (typeof db._viewCleanup === 'function') {\n\t    return customViewCleanup(db);\n\t  }\n\t  return localViewCleanup(db);\n\t});\n\t\n\tfunction queryPromised(db, fun, opts) {\n\t  if (db.type() === 'http') {\n\t    return httpQuery(db, fun, opts);\n\t  }\n\t\n\t  /* istanbul ignore next */\n\t  if (typeof db._query === 'function') {\n\t    return customQuery(db, fun, opts);\n\t  }\n\t\n\t  if (typeof fun !== 'string') {\n\t    // temp_view\n\t    checkQueryParseError(opts, fun);\n\t\n\t    var createViewOpts = {\n\t      db : db,\n\t      viewName : 'temp_view/temp_view',\n\t      map : fun.map,\n\t      reduce : fun.reduce,\n\t      temporary : true\n\t    };\n\t    tempViewQueue.add(function () {\n\t      return createView(createViewOpts).then(function (view) {\n\t        function cleanup() {\n\t          return view.db.destroy();\n\t        }\n\t        return fin(updateView(view).then(function () {\n\t          return queryView(view, opts);\n\t        }), cleanup);\n\t      });\n\t    });\n\t    return tempViewQueue.finish();\n\t  } else {\n\t    // persistent view\n\t    var fullViewName = fun;\n\t    var parts = parseViewName(fullViewName);\n\t    var designDocName = parts[0];\n\t    var viewName = parts[1];\n\t    return db.get('_design/' + designDocName).then(function (doc) {\n\t      var fun = doc.views && doc.views[viewName];\n\t\n\t      if (!fun || typeof fun.map !== 'string') {\n\t        throw new NotFoundError('ddoc ' + designDocName +\n\t        ' has no view named ' + viewName);\n\t      }\n\t      checkQueryParseError(opts, fun);\n\t\n\t      var createViewOpts = {\n\t        db : db,\n\t        viewName : fullViewName,\n\t        map : fun.map,\n\t        reduce : fun.reduce\n\t      };\n\t      return createView(createViewOpts).then(function (view) {\n\t        if (opts.stale === 'ok' || opts.stale === 'update_after') {\n\t          if (opts.stale === 'update_after') {\n\t            process.nextTick(function () {\n\t              updateView(view);\n\t            });\n\t          }\n\t          return queryView(view, opts);\n\t        } else { // stale not ok\n\t          return updateView(view).then(function () {\n\t            return queryView(view, opts);\n\t          });\n\t        }\n\t      });\n\t    });\n\t  }\n\t}\n\t\n\tvar query = function (fun, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  opts = opts ? coerceOptions(opts) : {};\n\t\n\t  if (typeof fun === 'function') {\n\t    fun = {map : fun};\n\t  }\n\t\n\t  var db = this;\n\t  var promise = PouchPromise.resolve().then(function () {\n\t    return queryPromised(db, fun, opts);\n\t  });\n\t  promisedCallback(promise, callback);\n\t  return promise;\n\t};\n\t\n\t\n\tvar mapreduce = {\n\t  query: query,\n\t  viewCleanup: viewCleanup\n\t};\n\t\n\tfunction isGenOne$1(rev) {\n\t  return /^1-/.test(rev);\n\t}\n\t\n\tfunction fileHasChanged(localDoc, remoteDoc, filename) {\n\t  return !localDoc._attachments ||\n\t         !localDoc._attachments[filename] ||\n\t         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n\t}\n\t\n\tfunction getDocAttachments(db, doc) {\n\t  var filenames = Object.keys(doc._attachments);\n\t  return PouchPromise.all(filenames.map(function (filename) {\n\t    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n\t  }));\n\t}\n\t\n\tfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n\t  var doCheckForLocalAttachments = src.type() === 'http' && target.type() !== 'http';\n\t  var filenames = Object.keys(doc._attachments);\n\t\n\t  if (!doCheckForLocalAttachments) {\n\t    return getDocAttachments(src, doc);\n\t  }\n\t\n\t  return target.get(doc._id).then(function (localDoc) {\n\t    return PouchPromise.all(filenames.map(function (filename) {\n\t      if (fileHasChanged(localDoc, doc, filename)) {\n\t        return src.getAttachment(doc._id, filename);\n\t      }\n\t\n\t      return target.getAttachment(localDoc._id, filename);\n\t    }));\n\t  }).catch(function (error) {\n\t    /* istanbul ignore if */\n\t    if (error.status !== 404) {\n\t      throw error;\n\t    }\n\t\n\t    return getDocAttachments(src, doc);\n\t  });\n\t}\n\t\n\tfunction createBulkGetOpts(diffs) {\n\t  var requests = [];\n\t  Object.keys(diffs).forEach(function (id) {\n\t    var missingRevs = diffs[id].missing;\n\t    missingRevs.forEach(function (missingRev) {\n\t      requests.push({\n\t        id: id,\n\t        rev: missingRev\n\t      });\n\t    });\n\t  });\n\t\n\t  return {\n\t    docs: requests,\n\t    revs: true\n\t  };\n\t}\n\t\n\t//\n\t// Fetch all the documents from the src as described in the \"diffs\",\n\t// which is a mapping of docs IDs to revisions. If the state ever\n\t// changes to \"cancelled\", then the returned promise will be rejected.\n\t// Else it will be resolved with a list of fetched documents.\n\t//\n\tfunction getDocs(src, target, diffs, state) {\n\t  diffs = clone(diffs); // we do not need to modify this\n\t\n\t  var resultDocs = [],\n\t      ok = true;\n\t\n\t  function getAllDocs() {\n\t\n\t    var bulkGetOpts = createBulkGetOpts(diffs);\n\t\n\t    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n\t      return;\n\t    }\n\t\n\t    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n\t      /* istanbul ignore if */\n\t      if (state.cancelled) {\n\t        throw new Error('cancelled');\n\t      }\n\t      return PouchPromise.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n\t        return PouchPromise.all(bulkGetInfo.docs.map(function (doc) {\n\t          var remoteDoc = doc.ok;\n\t\n\t          if (doc.error) {\n\t            // when AUTO_COMPACTION is set, docs can be returned which look\n\t            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n\t            ok = false;\n\t          }\n\t\n\t          if (!remoteDoc || !remoteDoc._attachments) {\n\t            return remoteDoc;\n\t          }\n\t\n\t          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc).then(function (attachments) {\n\t            var filenames = Object.keys(remoteDoc._attachments);\n\t            attachments.forEach(function (attachment, i) {\n\t              var att = remoteDoc._attachments[filenames[i]];\n\t              delete att.stub;\n\t              delete att.length;\n\t              att.data = attachment;\n\t            });\n\t\n\t            return remoteDoc;\n\t          });\n\t        }));\n\t      }))\n\t\n\t      .then(function (results) {\n\t        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n\t      });\n\t    });\n\t  }\n\t\n\t  function hasAttachments(doc) {\n\t    return doc._attachments && Object.keys(doc._attachments).length > 0;\n\t  }\n\t\n\t  function hasConflicts(doc) {\n\t    return doc._conflicts && doc._conflicts.length > 0;\n\t  }\n\t\n\t  function fetchRevisionOneDocs(ids) {\n\t    // Optimization: fetch gen-1 docs and attachments in\n\t    // a single request using _all_docs\n\t    return src.allDocs({\n\t      keys: ids,\n\t      include_docs: true,\n\t      conflicts: true\n\t    }).then(function (res) {\n\t      if (state.cancelled) {\n\t        throw new Error('cancelled');\n\t      }\n\t      res.rows.forEach(function (row) {\n\t        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n\t            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n\t          // if any of these conditions apply, we need to fetch using get()\n\t          return;\n\t        }\n\t\n\t        // the doc we got back from allDocs() is sufficient\n\t        resultDocs.push(row.doc);\n\t        delete diffs[row.id];\n\t      });\n\t    });\n\t  }\n\t\n\t  function getRevisionOneDocs() {\n\t    // filter out the generation 1 docs and get them\n\t    // leaving the non-generation one docs to be got otherwise\n\t    var ids = Object.keys(diffs).filter(function (id) {\n\t      var missing = diffs[id].missing;\n\t      return missing.length === 1 && isGenOne$1(missing[0]);\n\t    });\n\t    if (ids.length > 0) {\n\t      return fetchRevisionOneDocs(ids);\n\t    }\n\t  }\n\t\n\t  function returnResult() {\n\t    return { ok:ok, docs:resultDocs };\n\t  }\n\t\n\t  return PouchPromise.resolve()\n\t    .then(getRevisionOneDocs)\n\t    .then(getAllDocs)\n\t    .then(returnResult);\n\t}\n\t\n\tvar CHECKPOINT_VERSION = 1;\n\tvar REPLICATOR = \"pouchdb\";\n\t// This is an arbitrary number to limit the\n\t// amount of replication history we save in the checkpoint.\n\t// If we save too much, the checkpoing docs will become very big,\n\t// if we save fewer, we'll run a greater risk of having to\n\t// read all the changes from 0 when checkpoint PUTs fail\n\t// CouchDB 2.0 has a more involved history pruning,\n\t// but let's go for the simple version for now.\n\tvar CHECKPOINT_HISTORY_SIZE = 5;\n\tvar LOWEST_SEQ = 0;\n\t\n\tfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n\t  return db.get(id).catch(function (err) {\n\t    if (err.status === 404) {\n\t      if (db.type() === 'http') {\n\t        explainError(\n\t          404, 'PouchDB is just checking if a remote checkpoint exists.'\n\t        );\n\t      }\n\t      return {\n\t        session_id: session,\n\t        _id: id,\n\t        history: [],\n\t        replicator: REPLICATOR,\n\t        version: CHECKPOINT_VERSION\n\t      };\n\t    }\n\t    throw err;\n\t  }).then(function (doc) {\n\t    if (returnValue.cancelled) {\n\t      return;\n\t    }\n\t\n\t    // if the checkpoint has not changed, do not update\n\t    if (doc.last_seq === checkpoint) {\n\t      return;\n\t    }\n\t\n\t    // Filter out current entry for this replication\n\t    doc.history = (doc.history || []).filter(function (item) {\n\t      return item.session_id !== session;\n\t    });\n\t\n\t    // Add the latest checkpoint to history\n\t    doc.history.unshift({\n\t      last_seq: checkpoint,\n\t      session_id: session\n\t    });\n\t\n\t    // Just take the last pieces in history, to\n\t    // avoid really big checkpoint docs.\n\t    // see comment on history size above\n\t    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\t\n\t    doc.version = CHECKPOINT_VERSION;\n\t    doc.replicator = REPLICATOR;\n\t\n\t    doc.session_id = session;\n\t    doc.last_seq = checkpoint;\n\t\n\t    return db.put(doc).catch(function (err) {\n\t      if (err.status === 409) {\n\t        // retry; someone is trying to write a checkpoint simultaneously\n\t        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n\t      }\n\t      throw err;\n\t    });\n\t  });\n\t}\n\t\n\tfunction Checkpointer(src, target, id, returnValue) {\n\t  this.src = src;\n\t  this.target = target;\n\t  this.id = id;\n\t  this.returnValue = returnValue;\n\t}\n\t\n\tCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n\t  var self = this;\n\t  return this.updateTarget(checkpoint, session).then(function () {\n\t    return self.updateSource(checkpoint, session);\n\t  });\n\t};\n\t\n\tCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n\t  return updateCheckpoint(this.target, this.id, checkpoint,\n\t    session, this.returnValue);\n\t};\n\t\n\tCheckpointer.prototype.updateSource = function (checkpoint, session) {\n\t  var self = this;\n\t  if (this.readOnlySource) {\n\t    return PouchPromise.resolve(true);\n\t  }\n\t  return updateCheckpoint(this.src, this.id, checkpoint,\n\t    session, this.returnValue)\n\t    .catch(function (err) {\n\t      if (isForbiddenError(err)) {\n\t        self.readOnlySource = true;\n\t        return true;\n\t      }\n\t      throw err;\n\t    });\n\t};\n\t\n\tvar comparisons = {\n\t  \"undefined\": function (targetDoc, sourceDoc) {\n\t    // This is the previous comparison function\n\t    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n\t      return sourceDoc.last_seq;\n\t    }\n\t    /* istanbul ignore next */\n\t    return 0;\n\t  },\n\t  \"1\": function (targetDoc, sourceDoc) {\n\t    // This is the comparison function ported from CouchDB\n\t    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n\t  }\n\t};\n\t\n\tCheckpointer.prototype.getCheckpoint = function () {\n\t  var self = this;\n\t  return self.target.get(self.id).then(function (targetDoc) {\n\t    if (self.readOnlySource) {\n\t      return PouchPromise.resolve(targetDoc.last_seq);\n\t    }\n\t\n\t    return self.src.get(self.id).then(function (sourceDoc) {\n\t      // Since we can't migrate an old version doc to a new one\n\t      // (no session id), we just go with the lowest seq in this case\n\t      /* istanbul ignore if */\n\t      if (targetDoc.version !== sourceDoc.version) {\n\t        return LOWEST_SEQ;\n\t      }\n\t\n\t      var version;\n\t      if (targetDoc.version) {\n\t        version = targetDoc.version.toString();\n\t      } else {\n\t        version = \"undefined\";\n\t      }\n\t\n\t      if (version in comparisons) {\n\t        return comparisons[version](targetDoc, sourceDoc);\n\t      }\n\t      /* istanbul ignore next */\n\t      return LOWEST_SEQ;\n\t    }, function (err) {\n\t      if (err.status === 404 && targetDoc.last_seq) {\n\t        return self.src.put({\n\t          _id: self.id,\n\t          last_seq: LOWEST_SEQ\n\t        }).then(function () {\n\t          return LOWEST_SEQ;\n\t        }, function (err) {\n\t          if (isForbiddenError(err)) {\n\t            self.readOnlySource = true;\n\t            return targetDoc.last_seq;\n\t          }\n\t          /* istanbul ignore next */\n\t          return LOWEST_SEQ;\n\t        });\n\t      }\n\t      throw err;\n\t    });\n\t  }).catch(function (err) {\n\t    if (err.status !== 404) {\n\t      throw err;\n\t    }\n\t    return LOWEST_SEQ;\n\t  });\n\t};\n\t// This checkpoint comparison is ported from CouchDBs source\n\t// they come from here:\n\t// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\t\n\tfunction compareReplicationLogs(srcDoc, tgtDoc) {\n\t  if (srcDoc.session_id === tgtDoc.session_id) {\n\t    return {\n\t      last_seq: srcDoc.last_seq,\n\t      history: srcDoc.history\n\t    };\n\t  }\n\t\n\t  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n\t}\n\t\n\tfunction compareReplicationHistory(sourceHistory, targetHistory) {\n\t  // the erlang loop via function arguments is not so easy to repeat in JS\n\t  // therefore, doing this as recursion\n\t  var S = sourceHistory[0];\n\t  var sourceRest = sourceHistory.slice(1);\n\t  var T = targetHistory[0];\n\t  var targetRest = targetHistory.slice(1);\n\t\n\t  if (!S || targetHistory.length === 0) {\n\t    return {\n\t      last_seq: LOWEST_SEQ,\n\t      history: []\n\t    };\n\t  }\n\t\n\t  var sourceId = S.session_id;\n\t  /* istanbul ignore if */\n\t  if (hasSessionId(sourceId, targetHistory)) {\n\t    return {\n\t      last_seq: S.last_seq,\n\t      history: sourceHistory\n\t    };\n\t  }\n\t\n\t  var targetId = T.session_id;\n\t  if (hasSessionId(targetId, sourceRest)) {\n\t    return {\n\t      last_seq: T.last_seq,\n\t      history: targetRest\n\t    };\n\t  }\n\t\n\t  return compareReplicationHistory(sourceRest, targetRest);\n\t}\n\t\n\tfunction hasSessionId(sessionId, history) {\n\t  var props = history[0];\n\t  var rest = history.slice(1);\n\t\n\t  if (!sessionId || history.length === 0) {\n\t    return false;\n\t  }\n\t\n\t  if (sessionId === props.session_id) {\n\t    return true;\n\t  }\n\t\n\t  return hasSessionId(sessionId, rest);\n\t}\n\t\n\tfunction isForbiddenError(err) {\n\t  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n\t}\n\t\n\tvar STARTING_BACK_OFF = 0;\n\t\n\tfunction backOff(opts, returnValue, error, callback) {\n\t  if (opts.retry === false) {\n\t    returnValue.emit('error', error);\n\t    returnValue.removeAllListeners();\n\t    return;\n\t  }\n\t  if (typeof opts.back_off_function !== 'function') {\n\t    opts.back_off_function = defaultBackOff;\n\t  }\n\t  returnValue.emit('requestError', error);\n\t  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n\t    returnValue.emit('paused', error);\n\t    returnValue.state = 'stopped';\n\t    var backOffSet = function backoffTimeSet() {\n\t      opts.current_back_off = STARTING_BACK_OFF;\n\t    };\n\t    var removeBackOffSetter = function removeBackOffTimeSet() {\n\t      returnValue.removeListener('active', backOffSet);\n\t    };\n\t    returnValue.once('paused', removeBackOffSetter);\n\t    returnValue.once('active', backOffSet);\n\t  }\n\t\n\t  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n\t  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n\t  setTimeout(callback, opts.current_back_off);\n\t}\n\t\n\tfunction sortObjectPropertiesByKey(queryParams) {\n\t  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n\t    result[key] = queryParams[key];\n\t    return result;\n\t  }, {});\n\t}\n\t\n\t// Generate a unique id particular to this replication.\n\t// Not guaranteed to align perfectly with CouchDB's rep ids.\n\tfunction generateReplicationId(src, target, opts) {\n\t  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n\t  var filterFun = opts.filter ? opts.filter.toString() : '';\n\t  var queryParams = '';\n\t  var filterViewName =  '';\n\t\n\t  if (opts.filter && opts.query_params) {\n\t    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n\t  }\n\t\n\t  if (opts.filter && opts.filter === '_view') {\n\t    filterViewName = opts.view.toString();\n\t  }\n\t\n\t  return PouchPromise.all([src.id(), target.id()]).then(function (res) {\n\t    var queryData = res[0] + res[1] + filterFun + filterViewName +\n\t      queryParams + docIds;\n\t    return new PouchPromise(function (resolve) {\n\t      binaryMd5(queryData, resolve);\n\t    });\n\t  }).then(function (md5sum) {\n\t    // can't use straight-up md5 alphabet, because\n\t    // the char '/' is interpreted as being for attachments,\n\t    // and + is also not url-safe\n\t    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n\t    return '_local/' + md5sum;\n\t  });\n\t}\n\t\n\tfunction replicate$1(src, target, opts, returnValue, result) {\n\t  var batches = [];               // list of batches to be processed\n\t  var currentBatch;               // the batch currently being processed\n\t  var pendingBatch = {\n\t    seq: 0,\n\t    changes: [],\n\t    docs: []\n\t  }; // next batch, not yet ready to be processed\n\t  var writingCheckpoint = false;  // true while checkpoint is being written\n\t  var changesCompleted = false;   // true when all changes received\n\t  var replicationCompleted = false; // true when replication has completed\n\t  var last_seq = 0;\n\t  var continuous = opts.continuous || opts.live || false;\n\t  var batch_size = opts.batch_size || 100;\n\t  var batches_limit = opts.batches_limit || 10;\n\t  var changesPending = false;     // true while src.changes is running\n\t  var doc_ids = opts.doc_ids;\n\t  var repId;\n\t  var checkpointer;\n\t  var changedDocs = [];\n\t  // Like couchdb, every replication gets a unique session id\n\t  var session = uuid();\n\t\n\t  result = result || {\n\t    ok: true,\n\t    start_time: new Date(),\n\t    docs_read: 0,\n\t    docs_written: 0,\n\t    doc_write_failures: 0,\n\t    errors: []\n\t  };\n\t\n\t  var changesOpts = {};\n\t  returnValue.ready(src, target);\n\t\n\t  function initCheckpointer() {\n\t    if (checkpointer) {\n\t      return PouchPromise.resolve();\n\t    }\n\t    return generateReplicationId(src, target, opts).then(function (res) {\n\t      repId = res;\n\t      checkpointer = new Checkpointer(src, target, repId, returnValue);\n\t    });\n\t  }\n\t\n\t  function writeDocs() {\n\t    changedDocs = [];\n\t\n\t    if (currentBatch.docs.length === 0) {\n\t      return;\n\t    }\n\t    var docs = currentBatch.docs;\n\t    var bulkOpts = {timeout: opts.timeout};\n\t    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t\n\t      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n\t      // (id -> error), and check for errors while iterating over `docs`\n\t      var errorsById = Object.create(null);\n\t      res.forEach(function (res) {\n\t        if (res.error) {\n\t          errorsById[res.id] = res;\n\t        }\n\t      });\n\t\n\t      var errorsNo = Object.keys(errorsById).length;\n\t      result.doc_write_failures += errorsNo;\n\t      result.docs_written += docs.length - errorsNo;\n\t\n\t      docs.forEach(function (doc) {\n\t        var error = errorsById[doc._id];\n\t        if (error) {\n\t          result.errors.push(error);\n\t          if (error.name === 'unauthorized' || error.name === 'forbidden') {\n\t            returnValue.emit('denied', clone(error));\n\t          } else {\n\t            throw error;\n\t          }\n\t        } else {\n\t          changedDocs.push(doc);\n\t        }\n\t      });\n\t\n\t    }, function (err) {\n\t      result.doc_write_failures += docs.length;\n\t      throw err;\n\t    });\n\t  }\n\t\n\t  function finishBatch() {\n\t    if (currentBatch.error) {\n\t      throw new Error('There was a problem getting docs.');\n\t    }\n\t    result.last_seq = last_seq = currentBatch.seq;\n\t    var outResult = clone(result);\n\t    if (changedDocs.length) {\n\t      outResult.docs = changedDocs;\n\t      returnValue.emit('change', outResult);\n\t    }\n\t    writingCheckpoint = true;\n\t    return checkpointer.writeCheckpoint(currentBatch.seq,\n\t        session).then(function () {\n\t      writingCheckpoint = false;\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t      currentBatch = undefined;\n\t      getChanges();\n\t    }).catch(function (err) {\n\t      onCheckpointError(err);\n\t      throw err;\n\t    });\n\t  }\n\t\n\t  function getDiffs() {\n\t    var diff = {};\n\t    currentBatch.changes.forEach(function (change) {\n\t      // Couchbase Sync Gateway emits these, but we can ignore them\n\t      /* istanbul ignore if */\n\t      if (change.id === \"_user/\") {\n\t        return;\n\t      }\n\t      diff[change.id] = change.changes.map(function (x) {\n\t        return x.rev;\n\t      });\n\t    });\n\t    return target.revsDiff(diff).then(function (diffs) {\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t      // currentBatch.diffs elements are deleted as the documents are written\n\t      currentBatch.diffs = diffs;\n\t    });\n\t  }\n\t\n\t  function getBatchDocs() {\n\t    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n\t      currentBatch.error = !got.ok;\n\t      got.docs.forEach(function (doc) {\n\t        delete currentBatch.diffs[doc._id];\n\t        result.docs_read++;\n\t        currentBatch.docs.push(doc);\n\t      });\n\t    });\n\t  }\n\t\n\t  function startNextBatch() {\n\t    if (returnValue.cancelled || currentBatch) {\n\t      return;\n\t    }\n\t    if (batches.length === 0) {\n\t      processPendingBatch(true);\n\t      return;\n\t    }\n\t    currentBatch = batches.shift();\n\t    getDiffs()\n\t      .then(getBatchDocs)\n\t      .then(writeDocs)\n\t      .then(finishBatch)\n\t      .then(startNextBatch)\n\t      .catch(function (err) {\n\t        abortReplication('batch processing terminated with error', err);\n\t      });\n\t  }\n\t\n\t\n\t  function processPendingBatch(immediate) {\n\t    if (pendingBatch.changes.length === 0) {\n\t      if (batches.length === 0 && !currentBatch) {\n\t        if ((continuous && changesOpts.live) || changesCompleted) {\n\t          returnValue.state = 'pending';\n\t          returnValue.emit('paused');\n\t        }\n\t        if (changesCompleted) {\n\t          completeReplication();\n\t        }\n\t      }\n\t      return;\n\t    }\n\t    if (\n\t      immediate ||\n\t      changesCompleted ||\n\t      pendingBatch.changes.length >= batch_size\n\t    ) {\n\t      batches.push(pendingBatch);\n\t      pendingBatch = {\n\t        seq: 0,\n\t        changes: [],\n\t        docs: []\n\t      };\n\t      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n\t        returnValue.state = 'active';\n\t        returnValue.emit('active');\n\t      }\n\t      startNextBatch();\n\t    }\n\t  }\n\t\n\t\n\t  function abortReplication(reason, err) {\n\t    if (replicationCompleted) {\n\t      return;\n\t    }\n\t    if (!err.message) {\n\t      err.message = reason;\n\t    }\n\t    result.ok = false;\n\t    result.status = 'aborting';\n\t    batches = [];\n\t    pendingBatch = {\n\t      seq: 0,\n\t      changes: [],\n\t      docs: []\n\t    };\n\t    completeReplication(err);\n\t  }\n\t\n\t\n\t  function completeReplication(fatalError) {\n\t    if (replicationCompleted) {\n\t      return;\n\t    }\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      result.status = 'cancelled';\n\t      if (writingCheckpoint) {\n\t        return;\n\t      }\n\t    }\n\t    result.status = result.status || 'complete';\n\t    result.end_time = new Date();\n\t    result.last_seq = last_seq;\n\t    replicationCompleted = true;\n\t\n\t    if (fatalError) {\n\t      fatalError.result = result;\n\t\n\t      if (fatalError.name === 'unauthorized' || fatalError.name === 'forbidden') {\n\t        returnValue.emit('error', fatalError);\n\t        returnValue.removeAllListeners();\n\t      } else {\n\t        backOff(opts, returnValue, fatalError, function () {\n\t          replicate$1(src, target, opts, returnValue);\n\t        });\n\t      }\n\t    } else {\n\t      returnValue.emit('complete', result);\n\t      returnValue.removeAllListeners();\n\t    }\n\t  }\n\t\n\t\n\t  function onChange(change) {\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t    var filter = filterChange(opts)(change);\n\t    if (!filter) {\n\t      return;\n\t    }\n\t    pendingBatch.seq = change.seq;\n\t    pendingBatch.changes.push(change);\n\t    processPendingBatch(batches.length === 0 && changesOpts.live);\n\t  }\n\t\n\t\n\t  function onChangesComplete(changes) {\n\t    changesPending = false;\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t\n\t    // if no results were returned then we're done,\n\t    // else fetch more\n\t    if (changes.results.length > 0) {\n\t      changesOpts.since = changes.last_seq;\n\t      getChanges();\n\t      processPendingBatch(true);\n\t    } else {\n\t\n\t      var complete = function () {\n\t        if (continuous) {\n\t          changesOpts.live = true;\n\t          getChanges();\n\t        } else {\n\t          changesCompleted = true;\n\t        }\n\t        processPendingBatch(true);\n\t      };\n\t\n\t      // update the checkpoint so we start from the right seq next time\n\t      if (!currentBatch && changes.results.length === 0) {\n\t        writingCheckpoint = true;\n\t        checkpointer.writeCheckpoint(changes.last_seq,\n\t            session).then(function () {\n\t          writingCheckpoint = false;\n\t          result.last_seq = last_seq = changes.last_seq;\n\t          complete();\n\t        })\n\t        .catch(onCheckpointError);\n\t      } else {\n\t        complete();\n\t      }\n\t    }\n\t  }\n\t\n\t\n\t  function onChangesError(err) {\n\t    changesPending = false;\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t    abortReplication('changes rejected', err);\n\t  }\n\t\n\t\n\t  function getChanges() {\n\t    if (!(\n\t      !changesPending &&\n\t      !changesCompleted &&\n\t      batches.length < batches_limit\n\t      )) {\n\t      return;\n\t    }\n\t    changesPending = true;\n\t    function abortChanges() {\n\t      changes.cancel();\n\t    }\n\t    function removeListener() {\n\t      returnValue.removeListener('cancel', abortChanges);\n\t    }\n\t\n\t    if (returnValue._changes) { // remove old changes() and listeners\n\t      returnValue.removeListener('cancel', returnValue._abortChanges);\n\t      returnValue._changes.cancel();\n\t    }\n\t    returnValue.once('cancel', abortChanges);\n\t\n\t    var changes = src.changes(changesOpts)\n\t      .on('change', onChange);\n\t    changes.then(removeListener, removeListener);\n\t    changes.then(onChangesComplete)\n\t      .catch(onChangesError);\n\t\n\t    if (opts.retry) {\n\t      // save for later so we can cancel if necessary\n\t      returnValue._changes = changes;\n\t      returnValue._abortChanges = abortChanges;\n\t    }\n\t  }\n\t\n\t\n\t  function startChanges() {\n\t    initCheckpointer().then(function () {\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        return;\n\t      }\n\t      return checkpointer.getCheckpoint().then(function (checkpoint) {\n\t        last_seq = checkpoint;\n\t        changesOpts = {\n\t          since: last_seq,\n\t          limit: batch_size,\n\t          batch_size: batch_size,\n\t          style: 'all_docs',\n\t          doc_ids: doc_ids,\n\t          return_docs: true // required so we know when we're done\n\t        };\n\t        if (opts.filter) {\n\t          if (typeof opts.filter !== 'string') {\n\t            // required for the client-side filter in onChange\n\t            changesOpts.include_docs = true;\n\t          } else { // ddoc filter\n\t            changesOpts.filter = opts.filter;\n\t          }\n\t        }\n\t        if ('heartbeat' in opts) {\n\t          changesOpts.heartbeat = opts.heartbeat;\n\t        }\n\t        if ('timeout' in opts) {\n\t          changesOpts.timeout = opts.timeout;\n\t        }\n\t        if (opts.query_params) {\n\t          changesOpts.query_params = opts.query_params;\n\t        }\n\t        if (opts.view) {\n\t          changesOpts.view = opts.view;\n\t        }\n\t        getChanges();\n\t      });\n\t    }).catch(function (err) {\n\t      abortReplication('getCheckpoint rejected with ', err);\n\t    });\n\t  }\n\t\n\t  /* istanbul ignore next */\n\t  function onCheckpointError(err) {\n\t    writingCheckpoint = false;\n\t    abortReplication('writeCheckpoint completed with error', err);\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (returnValue.cancelled) { // cancelled immediately\n\t    completeReplication();\n\t    return;\n\t  }\n\t\n\t  if (!returnValue._addedListeners) {\n\t    returnValue.once('cancel', completeReplication);\n\t\n\t    if (typeof opts.complete === 'function') {\n\t      returnValue.once('error', opts.complete);\n\t      returnValue.once('complete', function (result) {\n\t        opts.complete(null, result);\n\t      });\n\t    }\n\t    returnValue._addedListeners = true;\n\t  }\n\t\n\t  if (typeof opts.since === 'undefined') {\n\t    startChanges();\n\t  } else {\n\t    initCheckpointer().then(function () {\n\t      writingCheckpoint = true;\n\t      return checkpointer.writeCheckpoint(opts.since, session);\n\t    }).then(function () {\n\t      writingCheckpoint = false;\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        return;\n\t      }\n\t      last_seq = opts.since;\n\t      startChanges();\n\t    }).catch(onCheckpointError);\n\t  }\n\t}\n\t\n\t// We create a basic promise so the caller can cancel the replication possibly\n\t// before we have actually started listening to changes etc\n\tinherits(Replication, events.EventEmitter);\n\tfunction Replication() {\n\t  events.EventEmitter.call(this);\n\t  this.cancelled = false;\n\t  this.state = 'pending';\n\t  var self = this;\n\t  var promise = new PouchPromise(function (fulfill, reject) {\n\t    self.once('complete', fulfill);\n\t    self.once('error', reject);\n\t  });\n\t  self.then = function (resolve, reject) {\n\t    return promise.then(resolve, reject);\n\t  };\n\t  self.catch = function (reject) {\n\t    return promise.catch(reject);\n\t  };\n\t  // As we allow error handling via \"error\" event as well,\n\t  // put a stub in here so that rejecting never throws UnhandledError.\n\t  self.catch(function () {});\n\t}\n\t\n\tReplication.prototype.cancel = function () {\n\t  this.cancelled = true;\n\t  this.state = 'cancelled';\n\t  this.emit('cancel');\n\t};\n\t\n\tReplication.prototype.ready = function (src, target) {\n\t  var self = this;\n\t  if (self._readyCalled) {\n\t    return;\n\t  }\n\t  self._readyCalled = true;\n\t\n\t  function onDestroy() {\n\t    self.cancel();\n\t  }\n\t  src.once('destroyed', onDestroy);\n\t  target.once('destroyed', onDestroy);\n\t  function cleanup() {\n\t    src.removeListener('destroyed', onDestroy);\n\t    target.removeListener('destroyed', onDestroy);\n\t  }\n\t  self.once('complete', cleanup);\n\t};\n\t\n\tfunction toPouch(db, opts) {\n\t  var PouchConstructor = opts.PouchConstructor;\n\t  if (typeof db === 'string') {\n\t    return new PouchConstructor(db, opts);\n\t  } else {\n\t    return db;\n\t  }\n\t}\n\t\n\tfunction replicate(src, target, opts, callback) {\n\t\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof opts === 'undefined') {\n\t    opts = {};\n\t  }\n\t\n\t  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n\t    throw createError(BAD_REQUEST,\n\t                       \"`doc_ids` filter parameter is not a list.\");\n\t  }\n\t\n\t  opts.complete = callback;\n\t  opts = clone(opts);\n\t  opts.continuous = opts.continuous || opts.live;\n\t  opts.retry = ('retry' in opts) ? opts.retry : false;\n\t  /*jshint validthis:true */\n\t  opts.PouchConstructor = opts.PouchConstructor || this;\n\t  var replicateRet = new Replication(opts);\n\t  var srcPouch = toPouch(src, opts);\n\t  var targetPouch = toPouch(target, opts);\n\t  replicate$1(srcPouch, targetPouch, opts, replicateRet);\n\t  return replicateRet;\n\t}\n\t\n\tinherits(Sync, events.EventEmitter);\n\tfunction sync(src, target, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof opts === 'undefined') {\n\t    opts = {};\n\t  }\n\t  opts = clone(opts);\n\t  /*jshint validthis:true */\n\t  opts.PouchConstructor = opts.PouchConstructor || this;\n\t  src = toPouch(src, opts);\n\t  target = toPouch(target, opts);\n\t  return new Sync(src, target, opts, callback);\n\t}\n\t\n\tfunction Sync(src, target, opts, callback) {\n\t  var self = this;\n\t  this.canceled = false;\n\t\n\t  var optsPush = opts.push ? extend$1({}, opts, opts.push) : opts;\n\t  var optsPull = opts.pull ? extend$1({}, opts, opts.pull) : opts;\n\t\n\t  this.push = replicate(src, target, optsPush);\n\t  this.pull = replicate(target, src, optsPull);\n\t\n\t  this.pushPaused = true;\n\t  this.pullPaused = true;\n\t\n\t  function pullChange(change) {\n\t    self.emit('change', {\n\t      direction: 'pull',\n\t      change: change\n\t    });\n\t  }\n\t  function pushChange(change) {\n\t    self.emit('change', {\n\t      direction: 'push',\n\t      change: change\n\t    });\n\t  }\n\t  function pushDenied(doc) {\n\t    self.emit('denied', {\n\t      direction: 'push',\n\t      doc: doc\n\t    });\n\t  }\n\t  function pullDenied(doc) {\n\t    self.emit('denied', {\n\t      direction: 'pull',\n\t      doc: doc\n\t    });\n\t  }\n\t  function pushPaused() {\n\t    self.pushPaused = true;\n\t    /* istanbul ignore if */\n\t    if (self.pullPaused) {\n\t      self.emit('paused');\n\t    }\n\t  }\n\t  function pullPaused() {\n\t    self.pullPaused = true;\n\t    /* istanbul ignore if */\n\t    if (self.pushPaused) {\n\t      self.emit('paused');\n\t    }\n\t  }\n\t  function pushActive() {\n\t    self.pushPaused = false;\n\t    /* istanbul ignore if */\n\t    if (self.pullPaused) {\n\t      self.emit('active', {\n\t        direction: 'push'\n\t      });\n\t    }\n\t  }\n\t  function pullActive() {\n\t    self.pullPaused = false;\n\t    /* istanbul ignore if */\n\t    if (self.pushPaused) {\n\t      self.emit('active', {\n\t        direction: 'pull'\n\t      });\n\t    }\n\t  }\n\t\n\t  var removed = {};\n\t\n\t  function removeAll(type) { // type is 'push' or 'pull'\n\t    return function (event, func) {\n\t      var isChange = event === 'change' &&\n\t        (func === pullChange || func === pushChange);\n\t      var isDenied = event === 'denied' &&\n\t        (func === pullDenied || func === pushDenied);\n\t      var isPaused = event === 'paused' &&\n\t        (func === pullPaused || func === pushPaused);\n\t      var isActive = event === 'active' &&\n\t        (func === pullActive || func === pushActive);\n\t\n\t      if (isChange || isDenied || isPaused || isActive) {\n\t        if (!(event in removed)) {\n\t          removed[event] = {};\n\t        }\n\t        removed[event][type] = true;\n\t        if (Object.keys(removed[event]).length === 2) {\n\t          // both push and pull have asked to be removed\n\t          self.removeAllListeners(event);\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  if (opts.live) {\n\t    this.push.on('complete', self.pull.cancel.bind(self.pull));\n\t    this.pull.on('complete', self.push.cancel.bind(self.push));\n\t  }\n\t\n\t  this.on('newListener', function (event) {\n\t    if (event === 'change') {\n\t      self.pull.on('change', pullChange);\n\t      self.push.on('change', pushChange);\n\t    } else if (event === 'denied') {\n\t      self.pull.on('denied', pullDenied);\n\t      self.push.on('denied', pushDenied);\n\t    } else if (event === 'active') {\n\t      self.pull.on('active', pullActive);\n\t      self.push.on('active', pushActive);\n\t    } else if (event === 'paused') {\n\t      self.pull.on('paused', pullPaused);\n\t      self.push.on('paused', pushPaused);\n\t    }\n\t  });\n\t\n\t  this.on('removeListener', function (event) {\n\t    if (event === 'change') {\n\t      self.pull.removeListener('change', pullChange);\n\t      self.push.removeListener('change', pushChange);\n\t    } else if (event === 'denied') {\n\t      self.pull.removeListener('denied', pullDenied);\n\t      self.push.removeListener('denied', pushDenied);\n\t    } else if (event === 'active') {\n\t      self.pull.removeListener('active', pullActive);\n\t      self.push.removeListener('active', pushActive);\n\t    } else if (event === 'paused') {\n\t      self.pull.removeListener('paused', pullPaused);\n\t      self.push.removeListener('paused', pushPaused);\n\t    }\n\t  });\n\t\n\t  this.pull.on('removeListener', removeAll('pull'));\n\t  this.push.on('removeListener', removeAll('push'));\n\t\n\t  var promise = PouchPromise.all([\n\t    this.push,\n\t    this.pull\n\t  ]).then(function (resp) {\n\t    var out = {\n\t      push: resp[0],\n\t      pull: resp[1]\n\t    };\n\t    self.emit('complete', out);\n\t    if (callback) {\n\t      callback(null, out);\n\t    }\n\t    self.removeAllListeners();\n\t    return out;\n\t  }, function (err) {\n\t    self.cancel();\n\t    if (callback) {\n\t      // if there's a callback, then the callback can receive\n\t      // the error event\n\t      callback(err);\n\t    } else {\n\t      // if there's no callback, then we're safe to emit an error\n\t      // event, which would otherwise throw an unhandled error\n\t      // due to 'error' being a special event in EventEmitters\n\t      self.emit('error', err);\n\t    }\n\t    self.removeAllListeners();\n\t    if (callback) {\n\t      // no sense throwing if we're already emitting an 'error' event\n\t      throw err;\n\t    }\n\t  });\n\t\n\t  this.then = function (success, err) {\n\t    return promise.then(success, err);\n\t  };\n\t\n\t  this.catch = function (err) {\n\t    return promise.catch(err);\n\t  };\n\t}\n\t\n\tSync.prototype.cancel = function () {\n\t  if (!this.canceled) {\n\t    this.canceled = true;\n\t    this.push.cancel();\n\t    this.pull.cancel();\n\t  }\n\t};\n\t\n\tfunction replication(PouchDB) {\n\t  PouchDB.replicate = replicate;\n\t  PouchDB.sync = sync;\n\t\n\t  Object.defineProperty(PouchDB.prototype, 'replicate', {\n\t    get: function () {\n\t      var self = this;\n\t      return {\n\t        from: function (other, opts, callback) {\n\t          return self.constructor.replicate(other, self, opts, callback);\n\t        },\n\t        to: function (other, opts, callback) {\n\t          return self.constructor.replicate(self, other, opts, callback);\n\t        }\n\t      };\n\t    }\n\t  });\n\t\n\t  PouchDB.prototype.sync = function (dbName, opts, callback) {\n\t    return this.constructor.sync(this, dbName, opts, callback);\n\t  };\n\t}\n\t\n\tPouchDB.plugin(IDBPouch)\n\t  .plugin(WebSqlPouch)\n\t  .plugin(HttpPouch$1)\n\t  .plugin(mapreduce)\n\t  .plugin(replication);\n\t\n\t// Pull from src because pouchdb-node/pouchdb-browser themselves\n\t// are aggressively optimized and jsnext:main would normally give us this\n\t// aggressive bundle.\n\t\n\tmodule.exports = PouchDB;\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 6), (function() { return this; }())))\n\n/***/ },\n/* 21 */\n/*!***********************************!*\\\n  !*** (webpack)/buildin/module.js ***!\n  \\***********************************/\n/***/ function(module, exports) {\n\n\tmodule.exports = function(module) {\r\n\t\tif(!module.webpackPolyfill) {\r\n\t\t\tmodule.deprecate = function() {};\r\n\t\t\tmodule.paths = [];\r\n\t\t\t// module.parent = undefined by default\r\n\t\t\tmodule.children = [];\r\n\t\t\tmodule.webpackPolyfill = 1;\r\n\t\t}\r\n\t\treturn module;\r\n\t}\r\n\n\n/***/ },\n/* 22 */,\n/* 23 */,\n/* 24 */,\n/* 25 */,\n/* 26 */,\n/* 27 */,\n/* 28 */,\n/* 29 */,\n/* 30 */,\n/* 31 */,\n/* 32 */,\n/* 33 */,\n/* 34 */,\n/* 35 */,\n/* 36 */,\n/* 37 */,\n/* 38 */,\n/* 39 */,\n/* 40 */,\n/* 41 */,\n/* 42 */,\n/* 43 */,\n/* 44 */,\n/* 45 */\n/*!********************************!*\\\n  !*** ./~/lodash/lodash.min.js ***!\n  \\********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {/**\n\t * @license\n\t * lodash lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE\n\t */\n\t;(function(){function t(t,n){return t.set(n[0],n[1]),t}function n(t,n){return t.add(n),t}function r(t,n,r){switch(r.length){case 0:return t.call(n);case 1:return t.call(n,r[0]);case 2:return t.call(n,r[0],r[1]);case 3:return t.call(n,r[0],r[1],r[2])}return t.apply(n,r)}function e(t,n,r,e){for(var u=-1,i=t?t.length:0;++u<i;){var o=t[u];n(e,o,r(o),t)}return e}function u(t,n){for(var r=-1,e=t?t.length:0;++r<e&&false!==n(t[r],r,t););return t}function i(t,n){for(var r=t?t.length:0;r--&&false!==n(t[r],r,t););\n\treturn t}function o(t,n){for(var r=-1,e=t?t.length:0;++r<e;)if(!n(t[r],r,t))return false;return true}function f(t,n){for(var r=-1,e=t?t.length:0,u=0,i=[];++r<e;){var o=t[r];n(o,r,t)&&(i[u++]=o)}return i}function c(t,n){return!(!t||!t.length)&&-1<d(t,n,0)}function a(t,n,r){for(var e=-1,u=t?t.length:0;++e<u;)if(r(n,t[e]))return true;return false}function l(t,n){for(var r=-1,e=t?t.length:0,u=Array(e);++r<e;)u[r]=n(t[r],r,t);return u}function s(t,n){for(var r=-1,e=n.length,u=t.length;++r<e;)t[u+r]=n[r];return t}function h(t,n,r,e){\n\tvar u=-1,i=t?t.length:0;for(e&&i&&(r=t[++u]);++u<i;)r=n(r,t[u],u,t);return r}function p(t,n,r,e){var u=t?t.length:0;for(e&&u&&(r=t[--u]);u--;)r=n(r,t[u],u,t);return r}function _(t,n){for(var r=-1,e=t?t.length:0;++r<e;)if(n(t[r],r,t))return true;return false}function v(t,n,r){var e;return r(t,function(t,r,u){if(n(t,r,u))return e=r,false}),e}function g(t,n,r,e){var u=t.length;for(r+=e?1:-1;e?r--:++r<u;)if(n(t[r],r,t))return r;return-1}function d(t,n,r){if(n===n)t:{--r;for(var e=t.length;++r<e;)if(t[r]===n){t=r;\n\tbreak t}t=-1}else t=g(t,b,r);return t}function y(t,n,r,e){--r;for(var u=t.length;++r<u;)if(e(t[r],n))return r;return-1}function b(t){return t!==t}function x(t,n){var r=t?t.length:0;return r?k(t,n)/r:P}function j(t){return function(n){return null==n?F:n[t]}}function w(t){return function(n){return null==t?F:t[n]}}function m(t,n,r,e,u){return u(t,function(t,u,i){r=e?(e=false,t):n(r,t,u,i)}),r}function A(t,n){var r=t.length;for(t.sort(n);r--;)t[r]=t[r].c;return t}function k(t,n){for(var r,e=-1,u=t.length;++e<u;){\n\tvar i=n(t[e]);i!==F&&(r=r===F?i:r+i)}return r}function E(t,n){for(var r=-1,e=Array(t);++r<t;)e[r]=n(r);return e}function O(t,n){return l(n,function(n){return[n,t[n]]})}function S(t){return function(n){return t(n)}}function I(t,n){return l(n,function(n){return t[n]})}function R(t,n){return t.has(n)}function z(t,n){for(var r=-1,e=t.length;++r<e&&-1<d(n,t[r],0););return r}function W(t,n){for(var r=t.length;r--&&-1<d(n,t[r],0););return r}function B(t){return\"\\\\\"+Dt[t]}function L(t){var n=-1,r=Array(t.size);\n\treturn t.forEach(function(t,e){r[++n]=[e,t]}),r}function U(t,n){return function(r){return t(n(r))}}function C(t,n){for(var r=-1,e=t.length,u=0,i=[];++r<e;){var o=t[r];o!==n&&\"__lodash_placeholder__\"!==o||(t[r]=\"__lodash_placeholder__\",i[u++]=r)}return i}function M(t){var n=-1,r=Array(t.size);return t.forEach(function(t){r[++n]=t}),r}function D(t){var n=-1,r=Array(t.size);return t.forEach(function(t){r[++n]=[t,t]}),r}function T(t){if(Wt.test(t)){for(var n=Rt.lastIndex=0;Rt.test(t);)++n;t=n}else t=tn(t);\n\treturn t}function $(t){return Wt.test(t)?t.match(Rt)||[]:t.split(\"\")}var F,N=1/0,P=NaN,Z=[[\"ary\",128],[\"bind\",1],[\"bindKey\",2],[\"curry\",8],[\"curryRight\",16],[\"flip\",512],[\"partial\",32],[\"partialRight\",64],[\"rearg\",256]],q=/\\b__p\\+='';/g,V=/\\b(__p\\+=)''\\+/g,K=/(__e\\(.*?\\)|\\b__t\\))\\+'';/g,G=/&(?:amp|lt|gt|quot|#39);/g,J=/[&<>\"']/g,Y=RegExp(G.source),H=RegExp(J.source),Q=/<%-([\\s\\S]+?)%>/g,X=/<%([\\s\\S]+?)%>/g,tt=/<%=([\\s\\S]+?)%>/g,nt=/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,rt=/^\\w*$/,et=/^\\./,ut=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,it=/[\\\\^$.*+?()[\\]{}|]/g,ot=RegExp(it.source),ft=/^\\s+|\\s+$/g,ct=/^\\s+/,at=/\\s+$/,lt=/\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,st=/\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,ht=/,? & /,pt=/[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g,_t=/\\\\(\\\\)?/g,vt=/\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g,gt=/\\w*$/,dt=/^[-+]0x[0-9a-f]+$/i,yt=/^0b[01]+$/i,bt=/^\\[object .+?Constructor\\]$/,xt=/^0o[0-7]+$/i,jt=/^(?:0|[1-9]\\d*)$/,wt=/[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g,mt=/($^)/,At=/['\\n\\r\\u2028\\u2029\\\\]/g,kt=\"[\\\\ufe0e\\\\ufe0f]?(?:[\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\\\\u20d0-\\\\u20f0]|\\\\ud83c[\\\\udffb-\\\\udfff])?(?:\\\\u200d(?:[^\\\\ud800-\\\\udfff]|(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff])[\\\\ufe0e\\\\ufe0f]?(?:[\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\\\\u20d0-\\\\u20f0]|\\\\ud83c[\\\\udffb-\\\\udfff])?)*\",Et=\"(?:[\\\\u2700-\\\\u27bf]|(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff])\"+kt,Ot=\"(?:[^\\\\ud800-\\\\udfff][\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\\\\u20d0-\\\\u20f0]?|[\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\\\\u20d0-\\\\u20f0]|(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]|[\\\\ud800-\\\\udfff])\",St=RegExp(\"['\\u2019]\",\"g\"),It=RegExp(\"[\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\\\\u20d0-\\\\u20f0]\",\"g\"),Rt=RegExp(\"\\\\ud83c[\\\\udffb-\\\\udfff](?=\\\\ud83c[\\\\udffb-\\\\udfff])|\"+Ot+kt,\"g\"),zt=RegExp([\"[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]?[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]+(?:['\\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\\\xac\\\\xb1\\\\xd7\\\\xf7\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\\\\u2000-\\\\u206f \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000]|[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]|$)|(?:[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]|[^\\\\ud800-\\\\udfff\\\\xac\\\\xb1\\\\xd7\\\\xf7\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\\\\u2000-\\\\u206f \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\d+\\\\u2700-\\\\u27bfa-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xffA-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde])+(?:['\\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\\\xac\\\\xb1\\\\xd7\\\\xf7\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\\\\u2000-\\\\u206f \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000]|[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde](?:[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]|[^\\\\ud800-\\\\udfff\\\\xac\\\\xb1\\\\xd7\\\\xf7\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\\\\u2000-\\\\u206f \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\d+\\\\u2700-\\\\u27bfa-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xffA-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde])|$)|[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]?(?:[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]|[^\\\\ud800-\\\\udfff\\\\xac\\\\xb1\\\\xd7\\\\xf7\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\\\\u2000-\\\\u206f \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\d+\\\\u2700-\\\\u27bfa-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xffA-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde])+(?:['\\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]+(?:['\\u2019](?:D|LL|M|RE|S|T|VE))?|\\\\d+\",Et].join(\"|\"),\"g\"),Wt=RegExp(\"[\\\\u200d\\\\ud800-\\\\udfff\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\\\\u20d0-\\\\u20f0\\\\ufe0e\\\\ufe0f]\"),Bt=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Lt=\"Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout\".split(\" \"),Ut={};\n\tUt[\"[object Float32Array]\"]=Ut[\"[object Float64Array]\"]=Ut[\"[object Int8Array]\"]=Ut[\"[object Int16Array]\"]=Ut[\"[object Int32Array]\"]=Ut[\"[object Uint8Array]\"]=Ut[\"[object Uint8ClampedArray]\"]=Ut[\"[object Uint16Array]\"]=Ut[\"[object Uint32Array]\"]=true,Ut[\"[object Arguments]\"]=Ut[\"[object Array]\"]=Ut[\"[object ArrayBuffer]\"]=Ut[\"[object Boolean]\"]=Ut[\"[object DataView]\"]=Ut[\"[object Date]\"]=Ut[\"[object Error]\"]=Ut[\"[object Function]\"]=Ut[\"[object Map]\"]=Ut[\"[object Number]\"]=Ut[\"[object Object]\"]=Ut[\"[object RegExp]\"]=Ut[\"[object Set]\"]=Ut[\"[object String]\"]=Ut[\"[object WeakMap]\"]=false;\n\tvar Ct={};Ct[\"[object Arguments]\"]=Ct[\"[object Array]\"]=Ct[\"[object ArrayBuffer]\"]=Ct[\"[object DataView]\"]=Ct[\"[object Boolean]\"]=Ct[\"[object Date]\"]=Ct[\"[object Float32Array]\"]=Ct[\"[object Float64Array]\"]=Ct[\"[object Int8Array]\"]=Ct[\"[object Int16Array]\"]=Ct[\"[object Int32Array]\"]=Ct[\"[object Map]\"]=Ct[\"[object Number]\"]=Ct[\"[object Object]\"]=Ct[\"[object RegExp]\"]=Ct[\"[object Set]\"]=Ct[\"[object String]\"]=Ct[\"[object Symbol]\"]=Ct[\"[object Uint8Array]\"]=Ct[\"[object Uint8ClampedArray]\"]=Ct[\"[object Uint16Array]\"]=Ct[\"[object Uint32Array]\"]=true,\n\tCt[\"[object Error]\"]=Ct[\"[object Function]\"]=Ct[\"[object WeakMap]\"]=false;var Mt,Dt={\"\\\\\":\"\\\\\",\"'\":\"'\",\"\\n\":\"n\",\"\\r\":\"r\",\"\\u2028\":\"u2028\",\"\\u2029\":\"u2029\"},Tt=parseFloat,$t=parseInt,Ft=typeof global==\"object\"&&global&&global.Object===Object&&global,Nt=typeof self==\"object\"&&self&&self.Object===Object&&self,Pt=Ft||Nt||Function(\"return this\")(),Zt=typeof exports==\"object\"&&exports&&!exports.nodeType&&exports,qt=Zt&&typeof module==\"object\"&&module&&!module.nodeType&&module,Vt=qt&&qt.exports===Zt,Kt=Vt&&Ft.h;\n\tt:{try{Mt=Kt&&Kt.g(\"util\");break t}catch(t){}Mt=void 0}var Gt=Mt&&Mt.isArrayBuffer,Jt=Mt&&Mt.isDate,Yt=Mt&&Mt.isMap,Ht=Mt&&Mt.isRegExp,Qt=Mt&&Mt.isSet,Xt=Mt&&Mt.isTypedArray,tn=j(\"length\"),nn=w({\"\\xc0\":\"A\",\"\\xc1\":\"A\",\"\\xc2\":\"A\",\"\\xc3\":\"A\",\"\\xc4\":\"A\",\"\\xc5\":\"A\",\"\\xe0\":\"a\",\"\\xe1\":\"a\",\"\\xe2\":\"a\",\"\\xe3\":\"a\",\"\\xe4\":\"a\",\"\\xe5\":\"a\",\"\\xc7\":\"C\",\"\\xe7\":\"c\",\"\\xd0\":\"D\",\"\\xf0\":\"d\",\"\\xc8\":\"E\",\"\\xc9\":\"E\",\"\\xca\":\"E\",\"\\xcb\":\"E\",\"\\xe8\":\"e\",\"\\xe9\":\"e\",\"\\xea\":\"e\",\"\\xeb\":\"e\",\"\\xcc\":\"I\",\"\\xcd\":\"I\",\"\\xce\":\"I\",\"\\xcf\":\"I\",\n\t\"\\xec\":\"i\",\"\\xed\":\"i\",\"\\xee\":\"i\",\"\\xef\":\"i\",\"\\xd1\":\"N\",\"\\xf1\":\"n\",\"\\xd2\":\"O\",\"\\xd3\":\"O\",\"\\xd4\":\"O\",\"\\xd5\":\"O\",\"\\xd6\":\"O\",\"\\xd8\":\"O\",\"\\xf2\":\"o\",\"\\xf3\":\"o\",\"\\xf4\":\"o\",\"\\xf5\":\"o\",\"\\xf6\":\"o\",\"\\xf8\":\"o\",\"\\xd9\":\"U\",\"\\xda\":\"U\",\"\\xdb\":\"U\",\"\\xdc\":\"U\",\"\\xf9\":\"u\",\"\\xfa\":\"u\",\"\\xfb\":\"u\",\"\\xfc\":\"u\",\"\\xdd\":\"Y\",\"\\xfd\":\"y\",\"\\xff\":\"y\",\"\\xc6\":\"Ae\",\"\\xe6\":\"ae\",\"\\xde\":\"Th\",\"\\xfe\":\"th\",\"\\xdf\":\"ss\",\"\\u0100\":\"A\",\"\\u0102\":\"A\",\"\\u0104\":\"A\",\"\\u0101\":\"a\",\"\\u0103\":\"a\",\"\\u0105\":\"a\",\"\\u0106\":\"C\",\"\\u0108\":\"C\",\"\\u010a\":\"C\",\"\\u010c\":\"C\",\n\t\"\\u0107\":\"c\",\"\\u0109\":\"c\",\"\\u010b\":\"c\",\"\\u010d\":\"c\",\"\\u010e\":\"D\",\"\\u0110\":\"D\",\"\\u010f\":\"d\",\"\\u0111\":\"d\",\"\\u0112\":\"E\",\"\\u0114\":\"E\",\"\\u0116\":\"E\",\"\\u0118\":\"E\",\"\\u011a\":\"E\",\"\\u0113\":\"e\",\"\\u0115\":\"e\",\"\\u0117\":\"e\",\"\\u0119\":\"e\",\"\\u011b\":\"e\",\"\\u011c\":\"G\",\"\\u011e\":\"G\",\"\\u0120\":\"G\",\"\\u0122\":\"G\",\"\\u011d\":\"g\",\"\\u011f\":\"g\",\"\\u0121\":\"g\",\"\\u0123\":\"g\",\"\\u0124\":\"H\",\"\\u0126\":\"H\",\"\\u0125\":\"h\",\"\\u0127\":\"h\",\"\\u0128\":\"I\",\"\\u012a\":\"I\",\"\\u012c\":\"I\",\"\\u012e\":\"I\",\"\\u0130\":\"I\",\"\\u0129\":\"i\",\"\\u012b\":\"i\",\"\\u012d\":\"i\",\"\\u012f\":\"i\",\n\t\"\\u0131\":\"i\",\"\\u0134\":\"J\",\"\\u0135\":\"j\",\"\\u0136\":\"K\",\"\\u0137\":\"k\",\"\\u0138\":\"k\",\"\\u0139\":\"L\",\"\\u013b\":\"L\",\"\\u013d\":\"L\",\"\\u013f\":\"L\",\"\\u0141\":\"L\",\"\\u013a\":\"l\",\"\\u013c\":\"l\",\"\\u013e\":\"l\",\"\\u0140\":\"l\",\"\\u0142\":\"l\",\"\\u0143\":\"N\",\"\\u0145\":\"N\",\"\\u0147\":\"N\",\"\\u014a\":\"N\",\"\\u0144\":\"n\",\"\\u0146\":\"n\",\"\\u0148\":\"n\",\"\\u014b\":\"n\",\"\\u014c\":\"O\",\"\\u014e\":\"O\",\"\\u0150\":\"O\",\"\\u014d\":\"o\",\"\\u014f\":\"o\",\"\\u0151\":\"o\",\"\\u0154\":\"R\",\"\\u0156\":\"R\",\"\\u0158\":\"R\",\"\\u0155\":\"r\",\"\\u0157\":\"r\",\"\\u0159\":\"r\",\"\\u015a\":\"S\",\"\\u015c\":\"S\",\"\\u015e\":\"S\",\n\t\"\\u0160\":\"S\",\"\\u015b\":\"s\",\"\\u015d\":\"s\",\"\\u015f\":\"s\",\"\\u0161\":\"s\",\"\\u0162\":\"T\",\"\\u0164\":\"T\",\"\\u0166\":\"T\",\"\\u0163\":\"t\",\"\\u0165\":\"t\",\"\\u0167\":\"t\",\"\\u0168\":\"U\",\"\\u016a\":\"U\",\"\\u016c\":\"U\",\"\\u016e\":\"U\",\"\\u0170\":\"U\",\"\\u0172\":\"U\",\"\\u0169\":\"u\",\"\\u016b\":\"u\",\"\\u016d\":\"u\",\"\\u016f\":\"u\",\"\\u0171\":\"u\",\"\\u0173\":\"u\",\"\\u0174\":\"W\",\"\\u0175\":\"w\",\"\\u0176\":\"Y\",\"\\u0177\":\"y\",\"\\u0178\":\"Y\",\"\\u0179\":\"Z\",\"\\u017b\":\"Z\",\"\\u017d\":\"Z\",\"\\u017a\":\"z\",\"\\u017c\":\"z\",\"\\u017e\":\"z\",\"\\u0132\":\"IJ\",\"\\u0133\":\"ij\",\"\\u0152\":\"Oe\",\"\\u0153\":\"oe\",\"\\u0149\":\"'n\",\n\t\"\\u017f\":\"s\"}),rn=w({\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#39;\"}),en=w({\"&amp;\":\"&\",\"&lt;\":\"<\",\"&gt;\":\">\",\"&quot;\":'\"',\"&#39;\":\"'\"}),un=function w(kt){function Et(t){return fi.call(t)}function Ot(t){if(vu(t)&&!nf(t)&&!(t instanceof Dt)){if(t instanceof Mt)return t;if(ui.call(t,\"__wrapped__\"))return De(t)}return new Mt(t)}function Rt(){}function Mt(t,n){this.__wrapped__=t,this.__actions__=[],this.__chain__=!!n,this.__index__=0,this.__values__=F}function Dt(t){this.__wrapped__=t,this.__actions__=[],\n\tthis.__dir__=1,this.__filtered__=false,this.__iteratees__=[],this.__takeCount__=4294967295,this.__views__=[]}function Ft(t){var n=-1,r=t?t.length:0;for(this.clear();++n<r;){var e=t[n];this.set(e[0],e[1])}}function Nt(t){var n=-1,r=t?t.length:0;for(this.clear();++n<r;){var e=t[n];this.set(e[0],e[1])}}function Zt(t){var n=-1,r=t?t.length:0;for(this.clear();++n<r;){var e=t[n];this.set(e[0],e[1])}}function qt(t){var n=-1,r=t?t.length:0;for(this.__data__=new Zt;++n<r;)this.add(t[n])}function Kt(t){this.size=(this.__data__=new Nt(t)).size;\n\t}function tn(t,n){var r,e=nf(t),u=!e&&tf(t),i=!e&&!u&&ef(t),o=!e&&!u&&!i&&af(t),u=(e=e||u||i||o)?E(t.length,Hu):[],f=u.length;for(r in t)!n&&!ui.call(t,r)||e&&(\"length\"==r||i&&(\"offset\"==r||\"parent\"==r)||o&&(\"buffer\"==r||\"byteLength\"==r||\"byteOffset\"==r)||me(r,f))||u.push(r);return u}function on(t){var n=t.length;return n?t[cr(0,n-1)]:F}function fn(t,n){return Le(Cr(t),dn(n,0,t.length))}function cn(t){return Le(Cr(t))}function an(t,n,r,e){return t===F||fu(t,ti[r])&&!ui.call(e,r)?n:t}function ln(t,n,r){\n\t(r===F||fu(t[n],r))&&(r!==F||n in t)||vn(t,n,r)}function sn(t,n,r){var e=t[n];ui.call(t,n)&&fu(e,r)&&(r!==F||n in t)||vn(t,n,r)}function hn(t,n){for(var r=t.length;r--;)if(fu(t[r][0],n))return r;return-1}function pn(t,n,r,e){return to(t,function(t,u,i){n(e,t,r(t),i)}),e}function _n(t,n){return t&&Mr(n,Iu(n),t)}function vn(t,n,r){\"__proto__\"==n&&xi?xi(t,n,{configurable:true,enumerable:true,value:r,writable:true}):t[n]=r}function gn(t,n){for(var r=-1,e=null==t,u=n.length,i=Zu(u);++r<u;)i[r]=e?F:Ou(t,n[r]);\n\treturn i}function dn(t,n,r){return t===t&&(r!==F&&(t=t<=r?t:r),n!==F&&(t=t>=n?t:n)),t}function yn(t,n,r,e,i,o,f){var c;if(e&&(c=o?e(t,i,o,f):e(t)),c!==F)return c;if(!_u(t))return t;if(i=nf(t)){if(c=be(t),!n)return Cr(t,c)}else{var a=Et(t),l=\"[object Function]\"==a||\"[object GeneratorFunction]\"==a;if(ef(t))return Rr(t,n);if(\"[object Object]\"==a||\"[object Arguments]\"==a||l&&!o){if(c=xe(l?{}:t),!n)return Dr(t,_n(c,t))}else{if(!Ct[a])return o?t:{};c=je(t,a,yn,n)}}if(f||(f=new Kt),o=f.get(t))return o;f.set(t,c);\n\tvar s=i?F:(r?se:Iu)(t);return u(s||t,function(u,i){s&&(i=u,u=t[i]),sn(c,i,yn(u,n,r,e,i,t,f))}),c}function bn(t){var n=Iu(t);return function(r){return xn(r,t,n)}}function xn(t,n,r){var e=r.length;if(null==t)return!e;for(t=Ju(t);e--;){var u=r[e],i=n[u],o=t[u];if(o===F&&!(u in t)||!i(o))return false}return true}function jn(t,n,r){if(typeof t!=\"function\")throw new Qu(\"Expected a function\");return po(function(){t.apply(F,r)},n)}function wn(t,n,r,e){var u=-1,i=c,o=true,f=t.length,s=[],h=n.length;if(!f)return s;r&&(n=l(n,S(r))),\n\te?(i=a,o=false):200<=n.length&&(i=R,o=false,n=new qt(n));t:for(;++u<f;){var p=t[u],_=r?r(p):p,p=e||0!==p?p:0;if(o&&_===_){for(var v=h;v--;)if(n[v]===_)continue t;s.push(p)}else i(n,_,e)||s.push(p)}return s}function mn(t,n){var r=true;return to(t,function(t,e,u){return r=!!n(t,e,u)}),r}function An(t,n,r){for(var e=-1,u=t.length;++e<u;){var i=t[e],o=n(i);if(null!=o&&(f===F?o===o&&!bu(o):r(o,f)))var f=o,c=i}return c}function kn(t,n){var r=[];return to(t,function(t,e,u){n(t,e,u)&&r.push(t)}),r}function En(t,n,r,e,u){\n\tvar i=-1,o=t.length;for(r||(r=we),u||(u=[]);++i<o;){var f=t[i];0<n&&r(f)?1<n?En(f,n-1,r,e,u):s(u,f):e||(u[u.length]=f)}return u}function On(t,n){return t&&ro(t,n,Iu)}function Sn(t,n){return t&&eo(t,n,Iu)}function In(t,n){return f(n,function(n){return su(t[n])})}function Rn(t,n){n=ke(n,t)?[n]:Sr(n);for(var r=0,e=n.length;null!=t&&r<e;)t=t[Ue(n[r++])];return r&&r==e?t:F}function zn(t,n,r){return n=n(t),nf(t)?n:s(n,r(t))}function Wn(t,n){return t>n}function Bn(t,n){return null!=t&&ui.call(t,n)}function Ln(t,n){\n\treturn null!=t&&n in Ju(t)}function Un(t,n,r){for(var e=r?a:c,u=t[0].length,i=t.length,o=i,f=Zu(i),s=1/0,h=[];o--;){var p=t[o];o&&n&&(p=l(p,S(n))),s=Wi(p.length,s),f[o]=!r&&(n||120<=u&&120<=p.length)?new qt(o&&p):F}var p=t[0],_=-1,v=f[0];t:for(;++_<u&&h.length<s;){var g=p[_],d=n?n(g):g,g=r||0!==g?g:0;if(v?!R(v,d):!e(h,d,r)){for(o=i;--o;){var y=f[o];if(y?!R(y,d):!e(t[o],d,r))continue t}v&&v.push(d),h.push(g)}}return h}function Cn(t,n,r){var e={};return On(t,function(t,u,i){n(e,r(t),u,i)}),e}function Mn(t,n,e){\n\treturn ke(n,t)||(n=Sr(n),t=ze(t,n),n=Pe(n)),n=null==t?t:t[Ue(n)],null==n?F:r(n,t,e)}function Dn(t){return vu(t)&&\"[object Arguments]\"==fi.call(t)}function Tn(t){return vu(t)&&\"[object ArrayBuffer]\"==fi.call(t)}function $n(t){return vu(t)&&\"[object Date]\"==fi.call(t)}function Fn(t,n,r,e,u){if(t===n)n=true;else if(null==t||null==n||!_u(t)&&!vu(n))n=t!==t&&n!==n;else t:{var i=nf(t),o=nf(n),f=\"[object Array]\",c=\"[object Array]\";i||(f=Et(t),f=\"[object Arguments]\"==f?\"[object Object]\":f),o||(c=Et(n),c=\"[object Arguments]\"==c?\"[object Object]\":c);\n\tvar a=\"[object Object]\"==f,o=\"[object Object]\"==c;if((c=f==c)&&ef(t)){if(!ef(n)){n=false;break t}i=true,a=false}if(c&&!a)u||(u=new Kt),n=i||af(t)?ce(t,n,Fn,r,e,u):ae(t,n,f,Fn,r,e,u);else{if(!(2&e)&&(i=a&&ui.call(t,\"__wrapped__\"),f=o&&ui.call(n,\"__wrapped__\"),i||f)){t=i?t.value():t,n=f?n.value():n,u||(u=new Kt),n=Fn(t,n,r,e,u);break t}if(c)n:if(u||(u=new Kt),i=2&e,f=Iu(t),o=f.length,c=Iu(n).length,o==c||i){for(a=o;a--;){var l=f[a];if(!(i?l in n:ui.call(n,l))){n=false;break n}}if((c=u.get(t))&&u.get(n))n=c==n;else{\n\tc=true,u.set(t,n),u.set(n,t);for(var s=i;++a<o;){var l=f[a],h=t[l],p=n[l];if(r)var _=i?r(p,h,l,n,t,u):r(h,p,l,t,n,u);if(_===F?h!==p&&!Fn(h,p,r,e,u):!_){c=false;break}s||(s=\"constructor\"==l)}c&&!s&&(r=t.constructor,e=n.constructor,r!=e&&\"constructor\"in t&&\"constructor\"in n&&!(typeof r==\"function\"&&r instanceof r&&typeof e==\"function\"&&e instanceof e)&&(c=false)),u.delete(t),u.delete(n),n=c}}else n=false;else n=false}}return n}function Nn(t){return vu(t)&&\"[object Map]\"==Et(t)}function Pn(t,n,r,e){var u=r.length,i=u,o=!e;\n\tif(null==t)return!i;for(t=Ju(t);u--;){var f=r[u];if(o&&f[2]?f[1]!==t[f[0]]:!(f[0]in t))return false}for(;++u<i;){var f=r[u],c=f[0],a=t[c],l=f[1];if(o&&f[2]){if(a===F&&!(c in t))return false}else{if(f=new Kt,e)var s=e(a,l,c,t,n,f);if(s===F?!Fn(l,a,e,3,f):!s)return false}}return true}function Zn(t){return!(!_u(t)||ri&&ri in t)&&(su(t)?ai:bt).test(Ce(t))}function qn(t){return _u(t)&&\"[object RegExp]\"==fi.call(t)}function Vn(t){return vu(t)&&\"[object Set]\"==Et(t)}function Kn(t){return vu(t)&&pu(t.length)&&!!Ut[fi.call(t)];\n\t}function Gn(t){return typeof t==\"function\"?t:null==t?Mu:typeof t==\"object\"?nf(t)?Xn(t[0],t[1]):Qn(t):Fu(t)}function Jn(t){if(!Oe(t))return Ri(t);var n,r=[];for(n in Ju(t))ui.call(t,n)&&\"constructor\"!=n&&r.push(n);return r}function Yn(t,n){return t<n}function Hn(t,n){var r=-1,e=cu(t)?Zu(t.length):[];return to(t,function(t,u,i){e[++r]=n(t,u,i)}),e}function Qn(t){var n=ge(t);return 1==n.length&&n[0][2]?Se(n[0][0],n[0][1]):function(r){return r===t||Pn(r,t,n)}}function Xn(t,n){return ke(t)&&n===n&&!_u(n)?Se(Ue(t),n):function(r){\n\tvar e=Ou(r,t);return e===F&&e===n?Su(r,t):Fn(n,e,F,3)}}function tr(t,n,r,e,u){t!==n&&ro(n,function(i,o){if(_u(i)){u||(u=new Kt);var f=u,c=t[o],a=n[o],l=f.get(a);if(l)ln(t,o,l);else{var l=e?e(c,a,o+\"\",t,n,f):F,s=l===F;if(s){var h=nf(a),p=!h&&ef(a),_=!h&&!p&&af(a),l=a;h||p||_?nf(c)?l=c:au(c)?l=Cr(c):p?(s=false,l=Rr(a,true)):_?(s=false,l=Wr(a,true)):l=[]:du(a)||tf(a)?(l=c,tf(c)?l=ku(c):(!_u(c)||r&&su(c))&&(l=xe(a))):s=false}s&&(f.set(a,l),tr(l,a,r,e,f),f.delete(a)),ln(t,o,l)}}else f=e?e(t[o],i,o+\"\",t,n,u):F,f===F&&(f=i),\n\tln(t,o,f)},Ru)}function nr(t,n){var r=t.length;if(r)return n+=0>n?r:0,me(n,r)?t[n]:F}function rr(t,n,r){var e=-1;return n=l(n.length?n:[Mu],S(_e())),t=Hn(t,function(t){return{a:l(n,function(n){return n(t)}),b:++e,c:t}}),A(t,function(t,n){var e;t:{e=-1;for(var u=t.a,i=n.a,o=u.length,f=r.length;++e<o;){var c=Br(u[e],i[e]);if(c){e=e>=f?c:c*(\"desc\"==r[e]?-1:1);break t}}e=t.b-n.b}return e})}function er(t,n){return t=Ju(t),ur(t,n,function(n,r){return r in t})}function ur(t,n,r){for(var e=-1,u=n.length,i={};++e<u;){\n\tvar o=n[e],f=t[o];r(f,o)&&vn(i,o,f)}return i}function ir(t){return function(n){return Rn(n,t)}}function or(t,n,r,e){var u=e?y:d,i=-1,o=n.length,f=t;for(t===n&&(n=Cr(n)),r&&(f=l(t,S(r)));++i<o;)for(var c=0,a=n[i],a=r?r(a):a;-1<(c=u(f,a,c,e));)f!==t&&yi.call(f,c,1),yi.call(t,c,1);return t}function fr(t,n){for(var r=t?n.length:0,e=r-1;r--;){var u=n[r];if(r==e||u!==i){var i=u;if(me(u))yi.call(t,u,1);else if(ke(u,t))delete t[Ue(u)];else{var u=Sr(u),o=ze(t,u);null!=o&&delete o[Ue(Pe(u))]}}}}function cr(t,n){\n\treturn t+ki(Ui()*(n-t+1))}function ar(t,n){var r=\"\";if(!t||1>n||9007199254740991<n)return r;do n%2&&(r+=t),(n=ki(n/2))&&(t+=t);while(n);return r}function lr(t,n){return _o(Re(t,n,Mu),t+\"\")}function sr(t){return on(Wu(t))}function hr(t,n){var r=Wu(t);return Le(r,dn(n,0,r.length))}function pr(t,n,r,e){if(!_u(t))return t;n=ke(n,t)?[n]:Sr(n);for(var u=-1,i=n.length,o=i-1,f=t;null!=f&&++u<i;){var c=Ue(n[u]),a=r;if(u!=o){var l=f[c],a=e?e(l,c,f):F;a===F&&(a=_u(l)?l:me(n[u+1])?[]:{})}sn(f,c,a),f=f[c]}return t;\n\t}function _r(t){return Le(Wu(t))}function vr(t,n,r){var e=-1,u=t.length;for(0>n&&(n=-n>u?0:u+n),r=r>u?u:r,0>r&&(r+=u),u=n>r?0:r-n>>>0,n>>>=0,r=Zu(u);++e<u;)r[e]=t[e+n];return r}function gr(t,n){var r;return to(t,function(t,e,u){return r=n(t,e,u),!r}),!!r}function dr(t,n,r){var e=0,u=t?t.length:e;if(typeof n==\"number\"&&n===n&&2147483647>=u){for(;e<u;){var i=e+u>>>1,o=t[i];null!==o&&!bu(o)&&(r?o<=n:o<n)?e=i+1:u=i}return u}return yr(t,n,Mu,r)}function yr(t,n,r,e){n=r(n);for(var u=0,i=t?t.length:0,o=n!==n,f=null===n,c=bu(n),a=n===F;u<i;){\n\tvar l=ki((u+i)/2),s=r(t[l]),h=s!==F,p=null===s,_=s===s,v=bu(s);(o?e||_:a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):p||v?0:e?s<=n:s<n)?u=l+1:i=l}return Wi(i,4294967294)}function br(t,n){for(var r=-1,e=t.length,u=0,i=[];++r<e;){var o=t[r],f=n?n(o):o;if(!r||!fu(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function xr(t){return typeof t==\"number\"?t:bu(t)?P:+t}function jr(t){if(typeof t==\"string\")return t;if(nf(t))return l(t,jr)+\"\";if(bu(t))return Qi?Qi.call(t):\"\";var n=t+\"\";return\"0\"==n&&1/t==-N?\"-0\":n;\n\t}function wr(t,n,r){var e=-1,u=c,i=t.length,o=true,f=[],l=f;if(r)o=false,u=a;else if(200<=i){if(u=n?null:fo(t))return M(u);o=false,u=R,l=new qt}else l=n?[]:f;t:for(;++e<i;){var s=t[e],h=n?n(s):s,s=r||0!==s?s:0;if(o&&h===h){for(var p=l.length;p--;)if(l[p]===h)continue t;n&&l.push(h),f.push(s)}else u(l,h,r)||(l!==f&&l.push(h),f.push(s))}return f}function mr(t,n,r,e){for(var u=t.length,i=e?u:-1;(e?i--:++i<u)&&n(t[i],i,t););return r?vr(t,e?0:i,e?i+1:u):vr(t,e?i+1:0,e?u:i)}function Ar(t,n){var r=t;return r instanceof Dt&&(r=r.value()),\n\th(n,function(t,n){return n.func.apply(n.thisArg,s([t],n.args))},r)}function kr(t,n,r){for(var e=-1,u=t.length;++e<u;)var i=i?s(wn(i,t[e],n,r),wn(t[e],i,n,r)):t[e];return i&&i.length?wr(i,n,r):[]}function Er(t,n,r){for(var e=-1,u=t.length,i=n.length,o={};++e<u;)r(o,t[e],e<i?n[e]:F);return o}function Or(t){return au(t)?t:[]}function Sr(t){return nf(t)?t:vo(t)}function Ir(t,n,r){var e=t.length;return r=r===F?e:r,!n&&r>=e?t:vr(t,n,r)}function Rr(t,n){if(n)return t.slice();var r=t.length,r=pi?pi(r):new t.constructor(r);\n\treturn t.copy(r),r}function zr(t){var n=new t.constructor(t.byteLength);return new hi(n).set(new hi(t)),n}function Wr(t,n){return new t.constructor(n?zr(t.buffer):t.buffer,t.byteOffset,t.length)}function Br(t,n){if(t!==n){var r=t!==F,e=null===t,u=t===t,i=bu(t),o=n!==F,f=null===n,c=n===n,a=bu(n);if(!f&&!a&&!i&&t>n||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&t<n||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Lr(t,n,r,e){var u=-1,i=t.length,o=r.length,f=-1,c=n.length,a=zi(i-o,0),l=Zu(c+a);\n\tfor(e=!e;++f<c;)l[f]=n[f];for(;++u<o;)(e||u<i)&&(l[r[u]]=t[u]);for(;a--;)l[f++]=t[u++];return l}function Ur(t,n,r,e){var u=-1,i=t.length,o=-1,f=r.length,c=-1,a=n.length,l=zi(i-f,0),s=Zu(l+a);for(e=!e;++u<l;)s[u]=t[u];for(l=u;++c<a;)s[l+c]=n[c];for(;++o<f;)(e||u<i)&&(s[l+r[o]]=t[u++]);return s}function Cr(t,n){var r=-1,e=t.length;for(n||(n=Zu(e));++r<e;)n[r]=t[r];return n}function Mr(t,n,r,e){var u=!r;r||(r={});for(var i=-1,o=n.length;++i<o;){var f=n[i],c=e?e(r[f],t[f],f,r,t):F;c===F&&(c=t[f]),u?vn(r,f,c):sn(r,f,c);\n\t}return r}function Dr(t,n){return Mr(t,ao(t),n)}function Tr(t,n){return function(r,u){var i=nf(r)?e:pn,o=n?n():{};return i(r,t,_e(u,2),o)}}function $r(t){return lr(function(n,r){var e=-1,u=r.length,i=1<u?r[u-1]:F,o=2<u?r[2]:F,i=3<t.length&&typeof i==\"function\"?(u--,i):F;for(o&&Ae(r[0],r[1],o)&&(i=3>u?F:i,u=1),n=Ju(n);++e<u;)(o=r[e])&&t(n,o,e,i);return n})}function Fr(t,n){return function(r,e){if(null==r)return r;if(!cu(r))return t(r,e);for(var u=r.length,i=n?u:-1,o=Ju(r);(n?i--:++i<u)&&false!==e(o[i],i,o););\n\treturn r}}function Nr(t){return function(n,r,e){var u=-1,i=Ju(n);e=e(n);for(var o=e.length;o--;){var f=e[t?o:++u];if(false===r(i[f],f,i))break}return n}}function Pr(t,n,r){function e(){return(this&&this!==Pt&&this instanceof e?i:t).apply(u?r:this,arguments)}var u=1&n,i=Vr(t);return e}function Zr(t){return function(n){n=Eu(n);var r=Wt.test(n)?$(n):F,e=r?r[0]:n.charAt(0);return n=r?Ir(r,1).join(\"\"):n.slice(1),e[t]()+n}}function qr(t){return function(n){return h(Uu(Lu(n).replace(St,\"\")),t,\"\")}}function Vr(t){\n\treturn function(){var n=arguments;switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3]);case 5:return new t(n[0],n[1],n[2],n[3],n[4]);case 6:return new t(n[0],n[1],n[2],n[3],n[4],n[5]);case 7:return new t(n[0],n[1],n[2],n[3],n[4],n[5],n[6])}var r=Xi(t.prototype),n=t.apply(r,n);return _u(n)?n:r}}function Kr(t,n,e){function u(){for(var o=arguments.length,f=Zu(o),c=o,a=pe(u);c--;)f[c]=arguments[c];\n\treturn c=3>o&&f[0]!==a&&f[o-1]!==a?[]:C(f,a),o-=c.length,o<e?ue(t,n,Yr,u.placeholder,F,f,c,F,F,e-o):r(this&&this!==Pt&&this instanceof u?i:t,this,f)}var i=Vr(t);return u}function Gr(t){return function(n,r,e){var u=Ju(n);if(!cu(n)){var i=_e(r,3);n=Iu(n),r=function(t){return i(u[t],t,u)}}return r=t(n,r,e),-1<r?u[i?n[r]:r]:F}}function Jr(t){return le(function(n){var r=n.length,e=r,u=Mt.prototype.thru;for(t&&n.reverse();e--;){var i=n[e];if(typeof i!=\"function\")throw new Qu(\"Expected a function\");if(u&&!o&&\"wrapper\"==he(i))var o=new Mt([],true);\n\t}for(e=o?e:r;++e<r;)var i=n[e],u=he(i),f=\"wrapper\"==u?co(i):F,o=f&&Ee(f[0])&&424==f[1]&&!f[4].length&&1==f[9]?o[he(f[0])].apply(o,f[3]):1==i.length&&Ee(i)?o[u]():o.thru(i);return function(){var t=arguments,e=t[0];if(o&&1==t.length&&nf(e)&&200<=e.length)return o.plant(e).value();for(var u=0,t=r?n[u].apply(this,t):e;++u<r;)t=n[u].call(this,t);return t}})}function Yr(t,n,r,e,u,i,o,f,c,a){function l(){for(var d=arguments.length,y=Zu(d),b=d;b--;)y[b]=arguments[b];if(_){var x,j=pe(l),b=y.length;for(x=0;b--;)y[b]===j&&++x;\n\t}if(e&&(y=Lr(y,e,u,_)),i&&(y=Ur(y,i,o,_)),d-=x,_&&d<a)return j=C(y,j),ue(t,n,Yr,l.placeholder,r,y,j,f,c,a-d);if(j=h?r:this,b=p?j[t]:t,d=y.length,f){x=y.length;for(var w=Wi(f.length,x),m=Cr(y);w--;){var A=f[w];y[w]=me(A,x)?m[A]:F}}else v&&1<d&&y.reverse();return s&&c<d&&(y.length=c),this&&this!==Pt&&this instanceof l&&(b=g||Vr(b)),b.apply(j,y)}var s=128&n,h=1&n,p=2&n,_=24&n,v=512&n,g=p?F:Vr(t);return l}function Hr(t,n){return function(r,e){return Cn(r,t,n(e))}}function Qr(t,n){return function(r,e){\n\tvar u;if(r===F&&e===F)return n;if(r!==F&&(u=r),e!==F){if(u===F)return e;typeof r==\"string\"||typeof e==\"string\"?(r=jr(r),e=jr(e)):(r=xr(r),e=xr(e)),u=t(r,e)}return u}}function Xr(t){return le(function(n){return n=l(n,S(_e())),lr(function(e){var u=this;return t(n,function(t){return r(t,u,e)})})})}function te(t,n){n=n===F?\" \":jr(n);var r=n.length;return 2>r?r?ar(n,t):n:(r=ar(n,Ai(t/T(n))),Wt.test(n)?Ir($(r),0,t).join(\"\"):r.slice(0,t))}function ne(t,n,e,u){function i(){for(var n=-1,c=arguments.length,a=-1,l=u.length,s=Zu(l+c),h=this&&this!==Pt&&this instanceof i?f:t;++a<l;)s[a]=u[a];\n\tfor(;c--;)s[a++]=arguments[++n];return r(h,o?e:this,s)}var o=1&n,f=Vr(t);return i}function re(t){return function(n,r,e){e&&typeof e!=\"number\"&&Ae(n,r,e)&&(r=e=F),n=ju(n),r===F?(r=n,n=0):r=ju(r),e=e===F?n<r?1:-1:ju(e);var u=-1;r=zi(Ai((r-n)/(e||1)),0);for(var i=Zu(r);r--;)i[t?r:++u]=n,n+=e;return i}}function ee(t){return function(n,r){return typeof n==\"string\"&&typeof r==\"string\"||(n=Au(n),r=Au(r)),t(n,r)}}function ue(t,n,r,e,u,i,o,f,c,a){var l=8&n,s=l?o:F;o=l?F:o;var h=l?i:F;return i=l?F:i,n=(n|(l?32:64))&~(l?64:32),\n\t4&n||(n&=-4),u=[t,n,u,h,s,i,o,f,c,a],r=r.apply(F,u),Ee(t)&&ho(r,u),r.placeholder=e,We(r,t,n)}function ie(t){var n=Gu[t];return function(t,r){if(t=Au(t),r=Wi(wu(r),292)){var e=(Eu(t)+\"e\").split(\"e\"),e=n(e[0]+\"e\"+(+e[1]+r)),e=(Eu(e)+\"e\").split(\"e\");return+(e[0]+\"e\"+(+e[1]-r))}return n(t)}}function oe(t){return function(n){var r=Et(n);return\"[object Map]\"==r?L(n):\"[object Set]\"==r?D(n):O(n,t(n))}}function fe(t,n,r,e,u,i,o,f){var c=2&n;if(!c&&typeof t!=\"function\")throw new Qu(\"Expected a function\");var a=e?e.length:0;\n\tif(a||(n&=-97,e=u=F),o=o===F?o:zi(wu(o),0),f=f===F?f:wu(f),a-=u?u.length:0,64&n){var l=e,s=u;e=u=F}var h=c?F:co(t);return i=[t,n,r,e,u,l,s,i,o,f],h&&(r=i[1],t=h[1],n=r|t,e=128==t&&8==r||128==t&&256==r&&i[7].length<=h[8]||384==t&&h[7].length<=h[8]&&8==r,131>n||e)&&(1&t&&(i[2]=h[2],n|=1&r?0:4),(r=h[3])&&(e=i[3],i[3]=e?Lr(e,r,h[4]):r,i[4]=e?C(i[3],\"__lodash_placeholder__\"):h[4]),(r=h[5])&&(e=i[5],i[5]=e?Ur(e,r,h[6]):r,i[6]=e?C(i[5],\"__lodash_placeholder__\"):h[6]),(r=h[7])&&(i[7]=r),128&t&&(i[8]=null==i[8]?h[8]:Wi(i[8],h[8])),\n\tnull==i[9]&&(i[9]=h[9]),i[0]=h[0],i[1]=n),t=i[0],n=i[1],r=i[2],e=i[3],u=i[4],f=i[9]=null==i[9]?c?0:t.length:zi(i[9]-a,0),!f&&24&n&&(n&=-25),We((h?uo:ho)(n&&1!=n?8==n||16==n?Kr(t,n,f):32!=n&&33!=n||u.length?Yr.apply(F,i):ne(t,n,r,e):Pr(t,n,r),i),t,n)}function ce(t,n,r,e,u,i){var o=2&u,f=t.length,c=n.length;if(f!=c&&!(o&&c>f))return false;if((c=i.get(t))&&i.get(n))return c==n;var c=-1,a=true,l=1&u?new qt:F;for(i.set(t,n),i.set(n,t);++c<f;){var s=t[c],h=n[c];if(e)var p=o?e(h,s,c,n,t,i):e(s,h,c,t,n,i);if(p!==F){\n\tif(p)continue;a=false;break}if(l){if(!_(n,function(t,n){if(!R(l,n)&&(s===t||r(s,t,e,u,i)))return l.push(n)})){a=false;break}}else if(s!==h&&!r(s,h,e,u,i)){a=false;break}}return i.delete(t),i.delete(n),a}function ae(t,n,r,e,u,i,o){switch(r){case\"[object DataView]\":if(t.byteLength!=n.byteLength||t.byteOffset!=n.byteOffset)break;t=t.buffer,n=n.buffer;case\"[object ArrayBuffer]\":if(t.byteLength!=n.byteLength||!e(new hi(t),new hi(n)))break;return true;case\"[object Boolean]\":case\"[object Date]\":case\"[object Number]\":\n\treturn fu(+t,+n);case\"[object Error]\":return t.name==n.name&&t.message==n.message;case\"[object RegExp]\":case\"[object String]\":return t==n+\"\";case\"[object Map]\":var f=L;case\"[object Set]\":if(f||(f=M),t.size!=n.size&&!(2&i))break;return(r=o.get(t))?r==n:(i|=1,o.set(t,n),n=ce(f(t),f(n),e,u,i,o),o.delete(t),n);case\"[object Symbol]\":if(Hi)return Hi.call(t)==Hi.call(n)}return false}function le(t){return _o(Re(t,F,Fe),t+\"\")}function se(t){return zn(t,Iu,ao)}function he(t){for(var n=t.name+\"\",r=Zi[n],e=ui.call(Zi,n)?r.length:0;e--;){\n\tvar u=r[e],i=u.func;if(null==i||i==t)return u.name}return n}function pe(t){return(ui.call(Ot,\"placeholder\")?Ot:t).placeholder}function _e(){var t=Ot.iteratee||Du,t=t===Du?Gn:t;return arguments.length?t(arguments[0],arguments[1]):t}function ve(t,n){var r=t.__data__,e=typeof n;return(\"string\"==e||\"number\"==e||\"symbol\"==e||\"boolean\"==e?\"__proto__\"!==n:null===n)?r[typeof n==\"string\"?\"string\":\"hash\"]:r.map}function ge(t){for(var n=Iu(t),r=n.length;r--;){var e=n[r],u=t[e];n[r]=[e,u,u===u&&!_u(u)]}return n;\n\t}function de(t,n){var r=null==t?F:t[n];return Zn(r)?r:F}function ye(t,n,r){n=ke(n,t)?[n]:Sr(n);for(var e=-1,u=n.length,i=false;++e<u;){var o=Ue(n[e]);if(!(i=null!=t&&r(t,o)))break;t=t[o]}return i||++e!=u?i:(u=t?t.length:0,!!u&&pu(u)&&me(o,u)&&(nf(t)||tf(t)))}function be(t){var n=t.length,r=t.constructor(n);return n&&\"string\"==typeof t[0]&&ui.call(t,\"index\")&&(r.index=t.index,r.input=t.input),r}function xe(t){return typeof t.constructor!=\"function\"||Oe(t)?{}:Xi(_i(t))}function je(r,e,u,i){var o=r.constructor;\n\tswitch(e){case\"[object ArrayBuffer]\":return zr(r);case\"[object Boolean]\":case\"[object Date]\":return new o(+r);case\"[object DataView]\":return e=i?zr(r.buffer):r.buffer,new r.constructor(e,r.byteOffset,r.byteLength);case\"[object Float32Array]\":case\"[object Float64Array]\":case\"[object Int8Array]\":case\"[object Int16Array]\":case\"[object Int32Array]\":case\"[object Uint8Array]\":case\"[object Uint8ClampedArray]\":case\"[object Uint16Array]\":case\"[object Uint32Array]\":return Wr(r,i);case\"[object Map]\":return e=i?u(L(r),true):L(r),\n\th(e,t,new r.constructor);case\"[object Number]\":case\"[object String]\":return new o(r);case\"[object RegExp]\":return e=new r.constructor(r.source,gt.exec(r)),e.lastIndex=r.lastIndex,e;case\"[object Set]\":return e=i?u(M(r),true):M(r),h(e,n,new r.constructor);case\"[object Symbol]\":return Hi?Ju(Hi.call(r)):{}}}function we(t){return nf(t)||tf(t)||!!(bi&&t&&t[bi])}function me(t,n){return n=null==n?9007199254740991:n,!!n&&(typeof t==\"number\"||jt.test(t))&&-1<t&&0==t%1&&t<n}function Ae(t,n,r){if(!_u(r))return false;\n\tvar e=typeof n;return!!(\"number\"==e?cu(r)&&me(n,r.length):\"string\"==e&&n in r)&&fu(r[n],t)}function ke(t,n){if(nf(t))return false;var r=typeof t;return!(\"number\"!=r&&\"symbol\"!=r&&\"boolean\"!=r&&null!=t&&!bu(t))||(rt.test(t)||!nt.test(t)||null!=n&&t in Ju(n))}function Ee(t){var n=he(t),r=Ot[n];return typeof r==\"function\"&&n in Dt.prototype&&(t===r||(n=co(r),!!n&&t===n[0]))}function Oe(t){var n=t&&t.constructor;return t===(typeof n==\"function\"&&n.prototype||ti)}function Se(t,n){return function(r){return null!=r&&(r[t]===n&&(n!==F||t in Ju(r)));\n\t}}function Ie(t,n,r,e,u,i){return _u(t)&&_u(n)&&(i.set(n,t),tr(t,n,F,Ie,i),i.delete(n)),t}function Re(t,n,e){return n=zi(n===F?t.length-1:n,0),function(){for(var u=arguments,i=-1,o=zi(u.length-n,0),f=Zu(o);++i<o;)f[i]=u[n+i];for(i=-1,o=Zu(n+1);++i<n;)o[i]=u[i];return o[n]=e(f),r(t,this,o)}}function ze(t,n){return 1==n.length?t:Rn(t,vr(n,0,-1))}function We(t,n,r){var e=n+\"\";n=_o;var u,i=Me;return u=(u=e.match(st))?u[1].split(ht):[],r=i(u,r),(i=r.length)&&(u=i-1,r[u]=(1<i?\"& \":\"\")+r[u],r=r.join(2<i?\", \":\" \"),\n\te=e.replace(lt,\"{\\n/* [wrapped with \"+r+\"] */\\n\")),n(t,e)}function Be(t){var n=0,r=0;return function(){var e=Bi(),u=16-(e-r);if(r=e,0<u){if(500<=++n)return arguments[0]}else n=0;return t.apply(F,arguments)}}function Le(t,n){var r=-1,e=t.length,u=e-1;for(n=n===F?e:n;++r<n;){var e=cr(r,u),i=t[e];t[e]=t[r],t[r]=i}return t.length=n,t}function Ue(t){if(typeof t==\"string\"||bu(t))return t;var n=t+\"\";return\"0\"==n&&1/t==-N?\"-0\":n}function Ce(t){if(null!=t){try{return ei.call(t)}catch(t){}return t+\"\"}return\"\";\n\t}function Me(t,n){return u(Z,function(r){var e=\"_.\"+r[0];n&r[1]&&!c(t,e)&&t.push(e)}),t.sort()}function De(t){if(t instanceof Dt)return t.clone();var n=new Mt(t.__wrapped__,t.__chain__);return n.__actions__=Cr(t.__actions__),n.__index__=t.__index__,n.__values__=t.__values__,n}function Te(t,n,r){var e=t?t.length:0;return e?(r=null==r?0:wu(r),0>r&&(r=zi(e+r,0)),g(t,_e(n,3),r)):-1}function $e(t,n,r){var e=t?t.length:0;if(!e)return-1;var u=e-1;return r!==F&&(u=wu(r),u=0>r?zi(e+u,0):Wi(u,e-1)),g(t,_e(n,3),u,true);\n\t}function Fe(t){return t&&t.length?En(t,1):[]}function Ne(t){return t&&t.length?t[0]:F}function Pe(t){var n=t?t.length:0;return n?t[n-1]:F}function Ze(t,n){return t&&t.length&&n&&n.length?or(t,n):t}function qe(t){return t?Ci.call(t):t}function Ve(t){if(!t||!t.length)return[];var n=0;return t=f(t,function(t){if(au(t))return n=zi(t.length,n),true}),E(n,function(n){return l(t,j(n))})}function Ke(t,n){if(!t||!t.length)return[];var e=Ve(t);return null==n?e:l(e,function(t){return r(n,F,t)})}function Ge(t){\n\treturn t=Ot(t),t.__chain__=true,t}function Je(t,n){return n(t)}function Ye(){return this}function He(t,n){return(nf(t)?u:to)(t,_e(n,3))}function Qe(t,n){return(nf(t)?i:no)(t,_e(n,3))}function Xe(t,n){return(nf(t)?l:Hn)(t,_e(n,3))}function tu(t,n,r){return n=r?F:n,n=t&&null==n?t.length:n,fe(t,128,F,F,F,F,n)}function nu(t,n){var r;if(typeof n!=\"function\")throw new Qu(\"Expected a function\");return t=wu(t),function(){return 0<--t&&(r=n.apply(this,arguments)),1>=t&&(n=F),r}}function ru(t,n,r){return n=r?F:n,\n\tt=fe(t,8,F,F,F,F,F,n),t.placeholder=ru.placeholder,t}function eu(t,n,r){return n=r?F:n,t=fe(t,16,F,F,F,F,F,n),t.placeholder=eu.placeholder,t}function uu(t,n,r){function e(n){var r=c,e=a;return c=a=F,_=n,s=t.apply(e,r)}function u(t){var r=t-p;return t-=_,p===F||r>=n||0>r||g&&t>=l}function i(){var t=Po();if(u(t))return o(t);var r,e=po;r=t-_,t=n-(t-p),r=g?Wi(t,l-r):t,h=e(i,r)}function o(t){return h=F,d&&c?e(t):(c=a=F,s)}function f(){var t=Po(),r=u(t);if(c=arguments,a=this,p=t,r){if(h===F)return _=t=p,\n\th=po(i,n),v?e(t):s;if(g)return h=po(i,n),e(p)}return h===F&&(h=po(i,n)),s}var c,a,l,s,h,p,_=0,v=false,g=false,d=true;if(typeof t!=\"function\")throw new Qu(\"Expected a function\");return n=Au(n)||0,_u(r)&&(v=!!r.leading,l=(g=\"maxWait\"in r)?zi(Au(r.maxWait)||0,n):l,d=\"trailing\"in r?!!r.trailing:d),f.cancel=function(){h!==F&&oo(h),_=0,c=p=a=h=F},f.flush=function(){return h===F?s:o(Po())},f}function iu(t,n){function r(){var e=arguments,u=n?n.apply(this,e):e[0],i=r.cache;return i.has(u)?i.get(u):(e=t.apply(this,e),\n\tr.cache=i.set(u,e)||i,e)}if(typeof t!=\"function\"||n&&typeof n!=\"function\")throw new Qu(\"Expected a function\");return r.cache=new(iu.Cache||Zt),r}function ou(t){if(typeof t!=\"function\")throw new Qu(\"Expected a function\");return function(){var n=arguments;switch(n.length){case 0:return!t.call(this);case 1:return!t.call(this,n[0]);case 2:return!t.call(this,n[0],n[1]);case 3:return!t.call(this,n[0],n[1],n[2])}return!t.apply(this,n)}}function fu(t,n){return t===n||t!==t&&n!==n}function cu(t){return null!=t&&pu(t.length)&&!su(t);\n\t}function au(t){return vu(t)&&cu(t)}function lu(t){return!!vu(t)&&(\"[object Error]\"==fi.call(t)||typeof t.message==\"string\"&&typeof t.name==\"string\")}function su(t){return t=_u(t)?fi.call(t):\"\",\"[object Function]\"==t||\"[object GeneratorFunction]\"==t||\"[object Proxy]\"==t}function hu(t){return typeof t==\"number\"&&t==wu(t)}function pu(t){return typeof t==\"number\"&&-1<t&&0==t%1&&9007199254740991>=t}function _u(t){var n=typeof t;return null!=t&&(\"object\"==n||\"function\"==n)}function vu(t){return null!=t&&typeof t==\"object\";\n\t}function gu(t){return typeof t==\"number\"||vu(t)&&\"[object Number]\"==fi.call(t)}function du(t){return!(!vu(t)||\"[object Object]\"!=fi.call(t))&&(t=_i(t),null===t||(t=ui.call(t,\"constructor\")&&t.constructor,typeof t==\"function\"&&t instanceof t&&ei.call(t)==oi))}function yu(t){return typeof t==\"string\"||!nf(t)&&vu(t)&&\"[object String]\"==fi.call(t)}function bu(t){return typeof t==\"symbol\"||vu(t)&&\"[object Symbol]\"==fi.call(t)}function xu(t){if(!t)return[];if(cu(t))return yu(t)?$(t):Cr(t);if(vi&&t[vi]){t=t[vi]();\n\tfor(var n,r=[];!(n=t.next()).done;)r.push(n.value);return r}return n=Et(t),(\"[object Map]\"==n?L:\"[object Set]\"==n?M:Wu)(t)}function ju(t){return t?(t=Au(t),t===N||t===-N?1.7976931348623157e308*(0>t?-1:1):t===t?t:0):0===t?t:0}function wu(t){t=ju(t);var n=t%1;return t===t?n?t-n:t:0}function mu(t){return t?dn(wu(t),0,4294967295):0}function Au(t){if(typeof t==\"number\")return t;if(bu(t))return P;if(_u(t)&&(t=typeof t.valueOf==\"function\"?t.valueOf():t,t=_u(t)?t+\"\":t),typeof t!=\"string\")return 0===t?t:+t;\n\tt=t.replace(ft,\"\");var n=yt.test(t);return n||xt.test(t)?$t(t.slice(2),n?2:8):dt.test(t)?P:+t}function ku(t){return Mr(t,Ru(t))}function Eu(t){return null==t?\"\":jr(t)}function Ou(t,n,r){return t=null==t?F:Rn(t,n),t===F?r:t}function Su(t,n){return null!=t&&ye(t,n,Ln)}function Iu(t){return cu(t)?tn(t):Jn(t)}function Ru(t){if(cu(t))t=tn(t,true);else if(_u(t)){var n,r=Oe(t),e=[];for(n in t)(\"constructor\"!=n||!r&&ui.call(t,n))&&e.push(n);t=e}else{if(n=[],null!=t)for(r in Ju(t))n.push(r);t=n}return t}function zu(t,n){\n\treturn null==t?{}:ur(t,zn(t,Ru,lo),_e(n))}function Wu(t){return t?I(t,Iu(t)):[]}function Bu(t){return Uf(Eu(t).toLowerCase())}function Lu(t){return(t=Eu(t))&&t.replace(wt,nn).replace(It,\"\")}function Uu(t,n,r){return t=Eu(t),n=r?F:n,n===F?Bt.test(t)?t.match(zt)||[]:t.match(pt)||[]:t.match(n)||[]}function Cu(t){return function(){return t}}function Mu(t){return t}function Du(t){return Gn(typeof t==\"function\"?t:yn(t,true))}function Tu(t,n,r){var e=Iu(n),i=In(n,e);null!=r||_u(n)&&(i.length||!e.length)||(r=n,\n\tn=t,t=this,i=In(n,Iu(n)));var o=!(_u(r)&&\"chain\"in r&&!r.chain),f=su(t);return u(i,function(r){var e=n[r];t[r]=e,f&&(t.prototype[r]=function(){var n=this.__chain__;if(o||n){var r=t(this.__wrapped__);return(r.__actions__=Cr(this.__actions__)).push({func:e,args:arguments,thisArg:t}),r.__chain__=n,r}return e.apply(t,s([this.value()],arguments))})}),t}function $u(){}function Fu(t){return ke(t)?j(Ue(t)):ir(t)}function Nu(){return[]}function Pu(){return false}kt=kt?un.defaults(Pt.Object(),kt,un.pick(Pt,Lt)):Pt;\n\tvar Zu=kt.Array,qu=kt.Date,Vu=kt.Error,Ku=kt.Function,Gu=kt.Math,Ju=kt.Object,Yu=kt.RegExp,Hu=kt.String,Qu=kt.TypeError,Xu=Zu.prototype,ti=Ju.prototype,ni=kt[\"__core-js_shared__\"],ri=function(){var t=/[^.]+$/.exec(ni&&ni.keys&&ni.keys.IE_PROTO||\"\");return t?\"Symbol(src)_1.\"+t:\"\"}(),ei=Ku.prototype.toString,ui=ti.hasOwnProperty,ii=0,oi=ei.call(Ju),fi=ti.toString,ci=Pt._,ai=Yu(\"^\"+ei.call(ui).replace(it,\"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,\"$1.*?\")+\"$\"),li=Vt?kt.Buffer:F,si=kt.Symbol,hi=kt.Uint8Array,pi=li?li.f:F,_i=U(Ju.getPrototypeOf,Ju),vi=si?si.iterator:F,gi=Ju.create,di=ti.propertyIsEnumerable,yi=Xu.splice,bi=si?si.isConcatSpreadable:F,xi=function(){\n\ttry{var t=de(Ju,\"defineProperty\");return t({},\"\",{}),t}catch(t){}}(),ji=kt.clearTimeout!==Pt.clearTimeout&&kt.clearTimeout,wi=qu&&qu.now!==Pt.Date.now&&qu.now,mi=kt.setTimeout!==Pt.setTimeout&&kt.setTimeout,Ai=Gu.ceil,ki=Gu.floor,Ei=Ju.getOwnPropertySymbols,Oi=li?li.isBuffer:F,Si=kt.isFinite,Ii=Xu.join,Ri=U(Ju.keys,Ju),zi=Gu.max,Wi=Gu.min,Bi=qu.now,Li=kt.parseInt,Ui=Gu.random,Ci=Xu.reverse,Mi=de(kt,\"DataView\"),Di=de(kt,\"Map\"),Ti=de(kt,\"Promise\"),$i=de(kt,\"Set\"),Fi=de(kt,\"WeakMap\"),Ni=de(Ju,\"create\"),Pi=Fi&&new Fi,Zi={},qi=Ce(Mi),Vi=Ce(Di),Ki=Ce(Ti),Gi=Ce($i),Ji=Ce(Fi),Yi=si?si.prototype:F,Hi=Yi?Yi.valueOf:F,Qi=Yi?Yi.toString:F,Xi=function(){\n\tfunction t(){}return function(n){return _u(n)?gi?gi(n):(t.prototype=n,n=new t,t.prototype=F,n):{}}}();Ot.templateSettings={escape:Q,evaluate:X,interpolate:tt,variable:\"\",imports:{_:Ot}},Ot.prototype=Rt.prototype,Ot.prototype.constructor=Ot,Mt.prototype=Xi(Rt.prototype),Mt.prototype.constructor=Mt,Dt.prototype=Xi(Rt.prototype),Dt.prototype.constructor=Dt,Ft.prototype.clear=function(){this.__data__=Ni?Ni(null):{},this.size=0},Ft.prototype.delete=function(t){return t=this.has(t)&&delete this.__data__[t],\n\tthis.size-=t?1:0,t},Ft.prototype.get=function(t){var n=this.__data__;return Ni?(t=n[t],\"__lodash_hash_undefined__\"===t?F:t):ui.call(n,t)?n[t]:F},Ft.prototype.has=function(t){var n=this.__data__;return Ni?n[t]!==F:ui.call(n,t)},Ft.prototype.set=function(t,n){var r=this.__data__;return this.size+=this.has(t)?0:1,r[t]=Ni&&n===F?\"__lodash_hash_undefined__\":n,this},Nt.prototype.clear=function(){this.__data__=[],this.size=0},Nt.prototype.delete=function(t){var n=this.__data__;return t=hn(n,t),!(0>t)&&(t==n.length-1?n.pop():yi.call(n,t,1),\n\t--this.size,true)},Nt.prototype.get=function(t){var n=this.__data__;return t=hn(n,t),0>t?F:n[t][1]},Nt.prototype.has=function(t){return-1<hn(this.__data__,t)},Nt.prototype.set=function(t,n){var r=this.__data__,e=hn(r,t);return 0>e?(++this.size,r.push([t,n])):r[e][1]=n,this},Zt.prototype.clear=function(){this.size=0,this.__data__={hash:new Ft,map:new(Di||Nt),string:new Ft}},Zt.prototype.delete=function(t){return t=ve(this,t).delete(t),this.size-=t?1:0,t},Zt.prototype.get=function(t){return ve(this,t).get(t);\n\t},Zt.prototype.has=function(t){return ve(this,t).has(t)},Zt.prototype.set=function(t,n){var r=ve(this,t),e=r.size;return r.set(t,n),this.size+=r.size==e?0:1,this},qt.prototype.add=qt.prototype.push=function(t){return this.__data__.set(t,\"__lodash_hash_undefined__\"),this},qt.prototype.has=function(t){return this.__data__.has(t)},Kt.prototype.clear=function(){this.__data__=new Nt,this.size=0},Kt.prototype.delete=function(t){var n=this.__data__;return t=n.delete(t),this.size=n.size,t},Kt.prototype.get=function(t){\n\treturn this.__data__.get(t)},Kt.prototype.has=function(t){return this.__data__.has(t)},Kt.prototype.set=function(t,n){var r=this.__data__;if(r instanceof Nt){var e=r.__data__;if(!Di||199>e.length)return e.push([t,n]),this.size=++r.size,this;r=this.__data__=new Zt(e)}return r.set(t,n),this.size=r.size,this};var to=Fr(On),no=Fr(Sn,true),ro=Nr(),eo=Nr(true),uo=Pi?function(t,n){return Pi.set(t,n),t}:Mu,io=xi?function(t,n){return xi(t,\"toString\",{configurable:true,enumerable:false,value:Cu(n),writable:true})}:Mu,oo=ji||function(t){\n\treturn Pt.clearTimeout(t)},fo=$i&&1/M(new $i([,-0]))[1]==N?function(t){return new $i(t)}:$u,co=Pi?function(t){return Pi.get(t)}:$u,ao=Ei?U(Ei,Ju):Nu,lo=Ei?function(t){for(var n=[];t;)s(n,ao(t)),t=_i(t);return n}:Nu;(Mi&&\"[object DataView]\"!=Et(new Mi(new ArrayBuffer(1)))||Di&&\"[object Map]\"!=Et(new Di)||Ti&&\"[object Promise]\"!=Et(Ti.resolve())||$i&&\"[object Set]\"!=Et(new $i)||Fi&&\"[object WeakMap]\"!=Et(new Fi))&&(Et=function(t){var n=fi.call(t);if(t=(t=\"[object Object]\"==n?t.constructor:F)?Ce(t):F)switch(t){\n\tcase qi:return\"[object DataView]\";case Vi:return\"[object Map]\";case Ki:return\"[object Promise]\";case Gi:return\"[object Set]\";case Ji:return\"[object WeakMap]\"}return n});var so=ni?su:Pu,ho=Be(uo),po=mi||function(t,n){return Pt.setTimeout(t,n)},_o=Be(io),vo=function(t){t=iu(t,function(t){return 500===n.size&&n.clear(),t});var n=t.cache;return t}(function(t){t=Eu(t);var n=[];return et.test(t)&&n.push(\"\"),t.replace(ut,function(t,r,e,u){n.push(e?u.replace(_t,\"$1\"):r||t)}),n}),go=lr(function(t,n){return au(t)?wn(t,En(n,1,au,true)):[];\n\t}),yo=lr(function(t,n){var r=Pe(n);return au(r)&&(r=F),au(t)?wn(t,En(n,1,au,true),_e(r,2)):[]}),bo=lr(function(t,n){var r=Pe(n);return au(r)&&(r=F),au(t)?wn(t,En(n,1,au,true),F,r):[]}),xo=lr(function(t){var n=l(t,Or);return n.length&&n[0]===t[0]?Un(n):[]}),jo=lr(function(t){var n=Pe(t),r=l(t,Or);return n===Pe(r)?n=F:r.pop(),r.length&&r[0]===t[0]?Un(r,_e(n,2)):[]}),wo=lr(function(t){var n=Pe(t),r=l(t,Or);return n===Pe(r)?n=F:r.pop(),r.length&&r[0]===t[0]?Un(r,F,n):[]}),mo=lr(Ze),Ao=le(function(t,n){var r=t?t.length:0,e=gn(t,n);\n\treturn fr(t,l(n,function(t){return me(t,r)?+t:t}).sort(Br)),e}),ko=lr(function(t){return wr(En(t,1,au,true))}),Eo=lr(function(t){var n=Pe(t);return au(n)&&(n=F),wr(En(t,1,au,true),_e(n,2))}),Oo=lr(function(t){var n=Pe(t);return au(n)&&(n=F),wr(En(t,1,au,true),F,n)}),So=lr(function(t,n){return au(t)?wn(t,n):[]}),Io=lr(function(t){return kr(f(t,au))}),Ro=lr(function(t){var n=Pe(t);return au(n)&&(n=F),kr(f(t,au),_e(n,2))}),zo=lr(function(t){var n=Pe(t);return au(n)&&(n=F),kr(f(t,au),F,n)}),Wo=lr(Ve),Bo=lr(function(t){\n\tvar n=t.length,n=1<n?t[n-1]:F,n=typeof n==\"function\"?(t.pop(),n):F;return Ke(t,n)}),Lo=le(function(t){function n(n){return gn(n,t)}var r=t.length,e=r?t[0]:0,u=this.__wrapped__;return!(1<r||this.__actions__.length)&&u instanceof Dt&&me(e)?(u=u.slice(e,+e+(r?1:0)),u.__actions__.push({func:Je,args:[n],thisArg:F}),new Mt(u,this.__chain__).thru(function(t){return r&&!t.length&&t.push(F),t})):this.thru(n)}),Uo=Tr(function(t,n,r){ui.call(t,r)?++t[r]:vn(t,r,1)}),Co=Gr(Te),Mo=Gr($e),Do=Tr(function(t,n,r){\n\tui.call(t,r)?t[r].push(n):vn(t,r,[n])}),To=lr(function(t,n,e){var u=-1,i=typeof n==\"function\",o=ke(n),f=cu(t)?Zu(t.length):[];return to(t,function(t){var c=i?n:o&&null!=t?t[n]:F;f[++u]=c?r(c,t,e):Mn(t,n,e)}),f}),$o=Tr(function(t,n,r){vn(t,r,n)}),Fo=Tr(function(t,n,r){t[r?0:1].push(n)},function(){return[[],[]]}),No=lr(function(t,n){if(null==t)return[];var r=n.length;return 1<r&&Ae(t,n[0],n[1])?n=[]:2<r&&Ae(n[0],n[1],n[2])&&(n=[n[0]]),rr(t,En(n,1),[])}),Po=wi||function(){return Pt.Date.now()},Zo=lr(function(t,n,r){\n\tvar e=1;if(r.length)var u=C(r,pe(Zo)),e=32|e;return fe(t,e,n,r,u)}),qo=lr(function(t,n,r){var e=3;if(r.length)var u=C(r,pe(qo)),e=32|e;return fe(n,e,t,r,u)}),Vo=lr(function(t,n){return jn(t,1,n)}),Ko=lr(function(t,n,r){return jn(t,Au(n)||0,r)});iu.Cache=Zt;var Go=lr(function(t,n){n=1==n.length&&nf(n[0])?l(n[0],S(_e())):l(En(n,1),S(_e()));var e=n.length;return lr(function(u){for(var i=-1,o=Wi(u.length,e);++i<o;)u[i]=n[i].call(this,u[i]);return r(t,this,u)})}),Jo=lr(function(t,n){return fe(t,32,F,n,C(n,pe(Jo)));\n\t}),Yo=lr(function(t,n){return fe(t,64,F,n,C(n,pe(Yo)))}),Ho=le(function(t,n){return fe(t,256,F,F,F,n)}),Qo=ee(Wn),Xo=ee(function(t,n){return t>=n}),tf=Dn(function(){return arguments}())?Dn:function(t){return vu(t)&&ui.call(t,\"callee\")&&!di.call(t,\"callee\")},nf=Zu.isArray,rf=Gt?S(Gt):Tn,ef=Oi||Pu,uf=Jt?S(Jt):$n,of=Yt?S(Yt):Nn,ff=Ht?S(Ht):qn,cf=Qt?S(Qt):Vn,af=Xt?S(Xt):Kn,lf=ee(Yn),sf=ee(function(t,n){return t<=n}),hf=$r(function(t,n){if(Oe(n)||cu(n))Mr(n,Iu(n),t);else for(var r in n)ui.call(n,r)&&sn(t,r,n[r]);\n\t}),pf=$r(function(t,n){Mr(n,Ru(n),t)}),_f=$r(function(t,n,r,e){Mr(n,Ru(n),t,e)}),vf=$r(function(t,n,r,e){Mr(n,Iu(n),t,e)}),gf=le(gn),df=lr(function(t){return t.push(F,an),r(_f,F,t)}),yf=lr(function(t){return t.push(F,Ie),r(mf,F,t)}),bf=Hr(function(t,n,r){t[n]=r},Cu(Mu)),xf=Hr(function(t,n,r){ui.call(t,n)?t[n].push(r):t[n]=[r]},_e),jf=lr(Mn),wf=$r(function(t,n,r){tr(t,n,r)}),mf=$r(function(t,n,r,e){tr(t,n,r,e)}),Af=le(function(t,n){return null==t?{}:(n=l(n,Ue),er(t,wn(zn(t,Ru,lo),n)))}),kf=le(function(t,n){\n\treturn null==t?{}:er(t,l(n,Ue))}),Ef=oe(Iu),Of=oe(Ru),Sf=qr(function(t,n,r){return n=n.toLowerCase(),t+(r?Bu(n):n)}),If=qr(function(t,n,r){return t+(r?\"-\":\"\")+n.toLowerCase()}),Rf=qr(function(t,n,r){return t+(r?\" \":\"\")+n.toLowerCase()}),zf=Zr(\"toLowerCase\"),Wf=qr(function(t,n,r){return t+(r?\"_\":\"\")+n.toLowerCase()}),Bf=qr(function(t,n,r){return t+(r?\" \":\"\")+Uf(n)}),Lf=qr(function(t,n,r){return t+(r?\" \":\"\")+n.toUpperCase()}),Uf=Zr(\"toUpperCase\"),Cf=lr(function(t,n){try{return r(t,F,n)}catch(t){return lu(t)?t:new Vu(t);\n\t}}),Mf=le(function(t,n){return u(n,function(n){n=Ue(n),vn(t,n,Zo(t[n],t))}),t}),Df=Jr(),Tf=Jr(true),$f=lr(function(t,n){return function(r){return Mn(r,t,n)}}),Ff=lr(function(t,n){return function(r){return Mn(t,r,n)}}),Nf=Xr(l),Pf=Xr(o),Zf=Xr(_),qf=re(),Vf=re(true),Kf=Qr(function(t,n){return t+n},0),Gf=ie(\"ceil\"),Jf=Qr(function(t,n){return t/n},1),Yf=ie(\"floor\"),Hf=Qr(function(t,n){return t*n},1),Qf=ie(\"round\"),Xf=Qr(function(t,n){return t-n},0);return Ot.after=function(t,n){if(typeof n!=\"function\")throw new Qu(\"Expected a function\");\n\treturn t=wu(t),function(){if(1>--t)return n.apply(this,arguments)}},Ot.ary=tu,Ot.assign=hf,Ot.assignIn=pf,Ot.assignInWith=_f,Ot.assignWith=vf,Ot.at=gf,Ot.before=nu,Ot.bind=Zo,Ot.bindAll=Mf,Ot.bindKey=qo,Ot.castArray=function(){if(!arguments.length)return[];var t=arguments[0];return nf(t)?t:[t]},Ot.chain=Ge,Ot.chunk=function(t,n,r){if(n=(r?Ae(t,n,r):n===F)?1:zi(wu(n),0),r=t?t.length:0,!r||1>n)return[];for(var e=0,u=0,i=Zu(Ai(r/n));e<r;)i[u++]=vr(t,e,e+=n);return i},Ot.compact=function(t){for(var n=-1,r=t?t.length:0,e=0,u=[];++n<r;){\n\tvar i=t[n];i&&(u[e++]=i)}return u},Ot.concat=function(){var t=arguments.length;if(!t)return[];for(var n=Zu(t-1),r=arguments[0];t--;)n[t-1]=arguments[t];return s(nf(r)?Cr(r):[r],En(n,1))},Ot.cond=function(t){var n=t?t.length:0,e=_e();return t=n?l(t,function(t){if(\"function\"!=typeof t[1])throw new Qu(\"Expected a function\");return[e(t[0]),t[1]]}):[],lr(function(e){for(var u=-1;++u<n;){var i=t[u];if(r(i[0],this,e))return r(i[1],this,e)}})},Ot.conforms=function(t){return bn(yn(t,true))},Ot.constant=Cu,Ot.countBy=Uo,\n\tOt.create=function(t,n){var r=Xi(t);return n?_n(r,n):r},Ot.curry=ru,Ot.curryRight=eu,Ot.debounce=uu,Ot.defaults=df,Ot.defaultsDeep=yf,Ot.defer=Vo,Ot.delay=Ko,Ot.difference=go,Ot.differenceBy=yo,Ot.differenceWith=bo,Ot.drop=function(t,n,r){var e=t?t.length:0;return e?(n=r||n===F?1:wu(n),vr(t,0>n?0:n,e)):[]},Ot.dropRight=function(t,n,r){var e=t?t.length:0;return e?(n=r||n===F?1:wu(n),n=e-n,vr(t,0,0>n?0:n)):[]},Ot.dropRightWhile=function(t,n){return t&&t.length?mr(t,_e(n,3),true,true):[]},Ot.dropWhile=function(t,n){\n\treturn t&&t.length?mr(t,_e(n,3),true):[]},Ot.fill=function(t,n,r,e){var u=t?t.length:0;if(!u)return[];for(r&&typeof r!=\"number\"&&Ae(t,n,r)&&(r=0,e=u),u=t.length,r=wu(r),0>r&&(r=-r>u?0:u+r),e=e===F||e>u?u:wu(e),0>e&&(e+=u),e=r>e?0:mu(e);r<e;)t[r++]=n;return t},Ot.filter=function(t,n){return(nf(t)?f:kn)(t,_e(n,3))},Ot.flatMap=function(t,n){return En(Xe(t,n),1)},Ot.flatMapDeep=function(t,n){return En(Xe(t,n),N)},Ot.flatMapDepth=function(t,n,r){return r=r===F?1:wu(r),En(Xe(t,n),r)},Ot.flatten=Fe,Ot.flattenDeep=function(t){\n\treturn t&&t.length?En(t,N):[]},Ot.flattenDepth=function(t,n){return t&&t.length?(n=n===F?1:wu(n),En(t,n)):[]},Ot.flip=function(t){return fe(t,512)},Ot.flow=Df,Ot.flowRight=Tf,Ot.fromPairs=function(t){for(var n=-1,r=t?t.length:0,e={};++n<r;){var u=t[n];e[u[0]]=u[1]}return e},Ot.functions=function(t){return null==t?[]:In(t,Iu(t))},Ot.functionsIn=function(t){return null==t?[]:In(t,Ru(t))},Ot.groupBy=Do,Ot.initial=function(t){return t&&t.length?vr(t,0,-1):[]},Ot.intersection=xo,Ot.intersectionBy=jo,Ot.intersectionWith=wo,\n\tOt.invert=bf,Ot.invertBy=xf,Ot.invokeMap=To,Ot.iteratee=Du,Ot.keyBy=$o,Ot.keys=Iu,Ot.keysIn=Ru,Ot.map=Xe,Ot.mapKeys=function(t,n){var r={};return n=_e(n,3),On(t,function(t,e,u){vn(r,n(t,e,u),t)}),r},Ot.mapValues=function(t,n){var r={};return n=_e(n,3),On(t,function(t,e,u){vn(r,e,n(t,e,u))}),r},Ot.matches=function(t){return Qn(yn(t,true))},Ot.matchesProperty=function(t,n){return Xn(t,yn(n,true))},Ot.memoize=iu,Ot.merge=wf,Ot.mergeWith=mf,Ot.method=$f,Ot.methodOf=Ff,Ot.mixin=Tu,Ot.negate=ou,Ot.nthArg=function(t){\n\treturn t=wu(t),lr(function(n){return nr(n,t)})},Ot.omit=Af,Ot.omitBy=function(t,n){return zu(t,ou(_e(n)))},Ot.once=function(t){return nu(2,t)},Ot.orderBy=function(t,n,r,e){return null==t?[]:(nf(n)||(n=null==n?[]:[n]),r=e?F:r,nf(r)||(r=null==r?[]:[r]),rr(t,n,r))},Ot.over=Nf,Ot.overArgs=Go,Ot.overEvery=Pf,Ot.overSome=Zf,Ot.partial=Jo,Ot.partialRight=Yo,Ot.partition=Fo,Ot.pick=kf,Ot.pickBy=zu,Ot.property=Fu,Ot.propertyOf=function(t){return function(n){return null==t?F:Rn(t,n)}},Ot.pull=mo,Ot.pullAll=Ze,\n\tOt.pullAllBy=function(t,n,r){return t&&t.length&&n&&n.length?or(t,n,_e(r,2)):t},Ot.pullAllWith=function(t,n,r){return t&&t.length&&n&&n.length?or(t,n,F,r):t},Ot.pullAt=Ao,Ot.range=qf,Ot.rangeRight=Vf,Ot.rearg=Ho,Ot.reject=function(t,n){return(nf(t)?f:kn)(t,ou(_e(n,3)))},Ot.remove=function(t,n){var r=[];if(!t||!t.length)return r;var e=-1,u=[],i=t.length;for(n=_e(n,3);++e<i;){var o=t[e];n(o,e,t)&&(r.push(o),u.push(e))}return fr(t,u),r},Ot.rest=function(t,n){if(typeof t!=\"function\")throw new Qu(\"Expected a function\");\n\treturn n=n===F?n:wu(n),lr(t,n)},Ot.reverse=qe,Ot.sampleSize=function(t,n,r){return n=(r?Ae(t,n,r):n===F)?1:wu(n),(nf(t)?fn:hr)(t,n)},Ot.set=function(t,n,r){return null==t?t:pr(t,n,r)},Ot.setWith=function(t,n,r,e){return e=typeof e==\"function\"?e:F,null==t?t:pr(t,n,r,e)},Ot.shuffle=function(t){return(nf(t)?cn:_r)(t)},Ot.slice=function(t,n,r){var e=t?t.length:0;return e?(r&&typeof r!=\"number\"&&Ae(t,n,r)?(n=0,r=e):(n=null==n?0:wu(n),r=r===F?e:wu(r)),vr(t,n,r)):[]},Ot.sortBy=No,Ot.sortedUniq=function(t){\n\treturn t&&t.length?br(t):[]},Ot.sortedUniqBy=function(t,n){return t&&t.length?br(t,_e(n,2)):[]},Ot.split=function(t,n,r){return r&&typeof r!=\"number\"&&Ae(t,n,r)&&(n=r=F),r=r===F?4294967295:r>>>0,r?(t=Eu(t))&&(typeof n==\"string\"||null!=n&&!ff(n))&&(n=jr(n),!n&&Wt.test(t))?Ir($(t),0,r):t.split(n,r):[]},Ot.spread=function(t,n){if(typeof t!=\"function\")throw new Qu(\"Expected a function\");return n=n===F?0:zi(wu(n),0),lr(function(e){var u=e[n];return e=Ir(e,0,n),u&&s(e,u),r(t,this,e)})},Ot.tail=function(t){\n\tvar n=t?t.length:0;return n?vr(t,1,n):[]},Ot.take=function(t,n,r){return t&&t.length?(n=r||n===F?1:wu(n),vr(t,0,0>n?0:n)):[]},Ot.takeRight=function(t,n,r){var e=t?t.length:0;return e?(n=r||n===F?1:wu(n),n=e-n,vr(t,0>n?0:n,e)):[]},Ot.takeRightWhile=function(t,n){return t&&t.length?mr(t,_e(n,3),false,true):[]},Ot.takeWhile=function(t,n){return t&&t.length?mr(t,_e(n,3)):[]},Ot.tap=function(t,n){return n(t),t},Ot.throttle=function(t,n,r){var e=true,u=true;if(typeof t!=\"function\")throw new Qu(\"Expected a function\");\n\treturn _u(r)&&(e=\"leading\"in r?!!r.leading:e,u=\"trailing\"in r?!!r.trailing:u),uu(t,n,{leading:e,maxWait:n,trailing:u})},Ot.thru=Je,Ot.toArray=xu,Ot.toPairs=Ef,Ot.toPairsIn=Of,Ot.toPath=function(t){return nf(t)?l(t,Ue):bu(t)?[t]:Cr(vo(t))},Ot.toPlainObject=ku,Ot.transform=function(t,n,r){var e=nf(t),i=e||ef(t)||af(t);if(n=_e(n,4),null==r){var o=t&&t.constructor;r=i?e?new o:[]:_u(t)&&su(o)?Xi(_i(t)):{}}return(i?u:On)(t,function(t,e,u){return n(r,t,e,u)}),r},Ot.unary=function(t){return tu(t,1)},Ot.union=ko,\n\tOt.unionBy=Eo,Ot.unionWith=Oo,Ot.uniq=function(t){return t&&t.length?wr(t):[]},Ot.uniqBy=function(t,n){return t&&t.length?wr(t,_e(n,2)):[]},Ot.uniqWith=function(t,n){return t&&t.length?wr(t,F,n):[]},Ot.unset=function(t,n){var r;if(null==t)r=true;else{r=t;var e=n,e=ke(e,r)?[e]:Sr(e);r=ze(r,e),e=Ue(Pe(e)),r=!(null!=r&&ui.call(r,e))||delete r[e]}return r},Ot.unzip=Ve,Ot.unzipWith=Ke,Ot.update=function(t,n,r){return null==t?t:pr(t,n,(typeof r==\"function\"?r:Mu)(Rn(t,n)),void 0)},Ot.updateWith=function(t,n,r,e){\n\treturn e=typeof e==\"function\"?e:F,null!=t&&(t=pr(t,n,(typeof r==\"function\"?r:Mu)(Rn(t,n)),e)),t},Ot.values=Wu,Ot.valuesIn=function(t){return null==t?[]:I(t,Ru(t))},Ot.without=So,Ot.words=Uu,Ot.wrap=function(t,n){return n=null==n?Mu:n,Jo(n,t)},Ot.xor=Io,Ot.xorBy=Ro,Ot.xorWith=zo,Ot.zip=Wo,Ot.zipObject=function(t,n){return Er(t||[],n||[],sn)},Ot.zipObjectDeep=function(t,n){return Er(t||[],n||[],pr)},Ot.zipWith=Bo,Ot.entries=Ef,Ot.entriesIn=Of,Ot.extend=pf,Ot.extendWith=_f,Tu(Ot,Ot),Ot.add=Kf,Ot.attempt=Cf,\n\tOt.camelCase=Sf,Ot.capitalize=Bu,Ot.ceil=Gf,Ot.clamp=function(t,n,r){return r===F&&(r=n,n=F),r!==F&&(r=Au(r),r=r===r?r:0),n!==F&&(n=Au(n),n=n===n?n:0),dn(Au(t),n,r)},Ot.clone=function(t){return yn(t,false,true)},Ot.cloneDeep=function(t){return yn(t,true,true)},Ot.cloneDeepWith=function(t,n){return yn(t,true,true,n)},Ot.cloneWith=function(t,n){return yn(t,false,true,n)},Ot.conformsTo=function(t,n){return null==n||xn(t,n,Iu(n))},Ot.deburr=Lu,Ot.defaultTo=function(t,n){return null==t||t!==t?n:t},Ot.divide=Jf,Ot.endsWith=function(t,n,r){\n\tt=Eu(t),n=jr(n);var e=t.length,e=r=r===F?e:dn(wu(r),0,e);return r-=n.length,0<=r&&t.slice(r,e)==n},Ot.eq=fu,Ot.escape=function(t){return(t=Eu(t))&&H.test(t)?t.replace(J,rn):t},Ot.escapeRegExp=function(t){return(t=Eu(t))&&ot.test(t)?t.replace(it,\"\\\\$&\"):t},Ot.every=function(t,n,r){var e=nf(t)?o:mn;return r&&Ae(t,n,r)&&(n=F),e(t,_e(n,3))},Ot.find=Co,Ot.findIndex=Te,Ot.findKey=function(t,n){return v(t,_e(n,3),On)},Ot.findLast=Mo,Ot.findLastIndex=$e,Ot.findLastKey=function(t,n){return v(t,_e(n,3),Sn);\n\t},Ot.floor=Yf,Ot.forEach=He,Ot.forEachRight=Qe,Ot.forIn=function(t,n){return null==t?t:ro(t,_e(n,3),Ru)},Ot.forInRight=function(t,n){return null==t?t:eo(t,_e(n,3),Ru)},Ot.forOwn=function(t,n){return t&&On(t,_e(n,3))},Ot.forOwnRight=function(t,n){return t&&Sn(t,_e(n,3))},Ot.get=Ou,Ot.gt=Qo,Ot.gte=Xo,Ot.has=function(t,n){return null!=t&&ye(t,n,Bn)},Ot.hasIn=Su,Ot.head=Ne,Ot.identity=Mu,Ot.includes=function(t,n,r,e){return t=cu(t)?t:Wu(t),r=r&&!e?wu(r):0,e=t.length,0>r&&(r=zi(e+r,0)),yu(t)?r<=e&&-1<t.indexOf(n,r):!!e&&-1<d(t,n,r);\n\t},Ot.indexOf=function(t,n,r){var e=t?t.length:0;return e?(r=null==r?0:wu(r),0>r&&(r=zi(e+r,0)),d(t,n,r)):-1},Ot.inRange=function(t,n,r){return n=ju(n),r===F?(r=n,n=0):r=ju(r),t=Au(t),t>=Wi(n,r)&&t<zi(n,r)},Ot.invoke=jf,Ot.isArguments=tf,Ot.isArray=nf,Ot.isArrayBuffer=rf,Ot.isArrayLike=cu,Ot.isArrayLikeObject=au,Ot.isBoolean=function(t){return true===t||false===t||vu(t)&&\"[object Boolean]\"==fi.call(t)},Ot.isBuffer=ef,Ot.isDate=uf,Ot.isElement=function(t){return null!=t&&1===t.nodeType&&vu(t)&&!du(t)},Ot.isEmpty=function(t){\n\tif(cu(t)&&(nf(t)||typeof t==\"string\"||typeof t.splice==\"function\"||ef(t)||af(t)||tf(t)))return!t.length;var n=Et(t);if(\"[object Map]\"==n||\"[object Set]\"==n)return!t.size;if(Oe(t))return!Jn(t).length;for(var r in t)if(ui.call(t,r))return false;return true},Ot.isEqual=function(t,n){return Fn(t,n)},Ot.isEqualWith=function(t,n,r){var e=(r=typeof r==\"function\"?r:F)?r(t,n):F;return e===F?Fn(t,n,r):!!e},Ot.isError=lu,Ot.isFinite=function(t){return typeof t==\"number\"&&Si(t)},Ot.isFunction=su,Ot.isInteger=hu,Ot.isLength=pu,\n\tOt.isMap=of,Ot.isMatch=function(t,n){return t===n||Pn(t,n,ge(n))},Ot.isMatchWith=function(t,n,r){return r=typeof r==\"function\"?r:F,Pn(t,n,ge(n),r)},Ot.isNaN=function(t){return gu(t)&&t!=+t},Ot.isNative=function(t){if(so(t))throw new Vu(\"Unsupported core-js use. Try https://github.com/es-shims.\");return Zn(t)},Ot.isNil=function(t){return null==t},Ot.isNull=function(t){return null===t},Ot.isNumber=gu,Ot.isObject=_u,Ot.isObjectLike=vu,Ot.isPlainObject=du,Ot.isRegExp=ff,Ot.isSafeInteger=function(t){return hu(t)&&-9007199254740991<=t&&9007199254740991>=t;\n\t},Ot.isSet=cf,Ot.isString=yu,Ot.isSymbol=bu,Ot.isTypedArray=af,Ot.isUndefined=function(t){return t===F},Ot.isWeakMap=function(t){return vu(t)&&\"[object WeakMap]\"==Et(t)},Ot.isWeakSet=function(t){return vu(t)&&\"[object WeakSet]\"==fi.call(t)},Ot.join=function(t,n){return t?Ii.call(t,n):\"\"},Ot.kebabCase=If,Ot.last=Pe,Ot.lastIndexOf=function(t,n,r){var e=t?t.length:0;if(!e)return-1;var u=e;if(r!==F&&(u=wu(r),u=0>u?zi(e+u,0):Wi(u,e-1)),n===n){for(r=u+1;r--&&t[r]!==n;);t=r}else t=g(t,b,u,true);return t},\n\tOt.lowerCase=Rf,Ot.lowerFirst=zf,Ot.lt=lf,Ot.lte=sf,Ot.max=function(t){return t&&t.length?An(t,Mu,Wn):F},Ot.maxBy=function(t,n){return t&&t.length?An(t,_e(n,2),Wn):F},Ot.mean=function(t){return x(t,Mu)},Ot.meanBy=function(t,n){return x(t,_e(n,2))},Ot.min=function(t){return t&&t.length?An(t,Mu,Yn):F},Ot.minBy=function(t,n){return t&&t.length?An(t,_e(n,2),Yn):F},Ot.stubArray=Nu,Ot.stubFalse=Pu,Ot.stubObject=function(){return{}},Ot.stubString=function(){return\"\"},Ot.stubTrue=function(){return true},Ot.multiply=Hf,\n\tOt.nth=function(t,n){return t&&t.length?nr(t,wu(n)):F},Ot.noConflict=function(){return Pt._===this&&(Pt._=ci),this},Ot.noop=$u,Ot.now=Po,Ot.pad=function(t,n,r){t=Eu(t);var e=(n=wu(n))?T(t):0;return!n||e>=n?t:(n=(n-e)/2,te(ki(n),r)+t+te(Ai(n),r))},Ot.padEnd=function(t,n,r){t=Eu(t);var e=(n=wu(n))?T(t):0;return n&&e<n?t+te(n-e,r):t},Ot.padStart=function(t,n,r){t=Eu(t);var e=(n=wu(n))?T(t):0;return n&&e<n?te(n-e,r)+t:t},Ot.parseInt=function(t,n,r){return r||null==n?n=0:n&&(n=+n),Li(Eu(t).replace(ct,\"\"),n||0);\n\t},Ot.random=function(t,n,r){if(r&&typeof r!=\"boolean\"&&Ae(t,n,r)&&(n=r=F),r===F&&(typeof n==\"boolean\"?(r=n,n=F):typeof t==\"boolean\"&&(r=t,t=F)),t===F&&n===F?(t=0,n=1):(t=ju(t),n===F?(n=t,t=0):n=ju(n)),t>n){var e=t;t=n,n=e}return r||t%1||n%1?(r=Ui(),Wi(t+r*(n-t+Tt(\"1e-\"+((r+\"\").length-1))),n)):cr(t,n)},Ot.reduce=function(t,n,r){var e=nf(t)?h:m,u=3>arguments.length;return e(t,_e(n,4),r,u,to)},Ot.reduceRight=function(t,n,r){var e=nf(t)?p:m,u=3>arguments.length;return e(t,_e(n,4),r,u,no)},Ot.repeat=function(t,n,r){\n\treturn n=(r?Ae(t,n,r):n===F)?1:wu(n),ar(Eu(t),n)},Ot.replace=function(){var t=arguments,n=Eu(t[0]);return 3>t.length?n:n.replace(t[1],t[2])},Ot.result=function(t,n,r){n=ke(n,t)?[n]:Sr(n);var e=-1,u=n.length;for(u||(t=F,u=1);++e<u;){var i=null==t?F:t[Ue(n[e])];i===F&&(e=u,i=r),t=su(i)?i.call(t):i}return t},Ot.round=Qf,Ot.runInContext=w,Ot.sample=function(t){return(nf(t)?on:sr)(t)},Ot.size=function(t){if(null==t)return 0;if(cu(t))return yu(t)?T(t):t.length;var n=Et(t);return\"[object Map]\"==n||\"[object Set]\"==n?t.size:Jn(t).length;\n\t},Ot.snakeCase=Wf,Ot.some=function(t,n,r){var e=nf(t)?_:gr;return r&&Ae(t,n,r)&&(n=F),e(t,_e(n,3))},Ot.sortedIndex=function(t,n){return dr(t,n)},Ot.sortedIndexBy=function(t,n,r){return yr(t,n,_e(r,2))},Ot.sortedIndexOf=function(t,n){var r=t?t.length:0;if(r){var e=dr(t,n);if(e<r&&fu(t[e],n))return e}return-1},Ot.sortedLastIndex=function(t,n){return dr(t,n,true)},Ot.sortedLastIndexBy=function(t,n,r){return yr(t,n,_e(r,2),true)},Ot.sortedLastIndexOf=function(t,n){if(t&&t.length){var r=dr(t,n,true)-1;if(fu(t[r],n))return r;\n\t}return-1},Ot.startCase=Bf,Ot.startsWith=function(t,n,r){return t=Eu(t),r=dn(wu(r),0,t.length),n=jr(n),t.slice(r,r+n.length)==n},Ot.subtract=Xf,Ot.sum=function(t){return t&&t.length?k(t,Mu):0},Ot.sumBy=function(t,n){return t&&t.length?k(t,_e(n,2)):0},Ot.template=function(t,n,r){var e=Ot.templateSettings;r&&Ae(t,n,r)&&(n=F),t=Eu(t),n=_f({},n,e,an),r=_f({},n.imports,e.imports,an);var u,i,o=Iu(r),f=I(r,o),c=0;r=n.interpolate||mt;var a=\"__p+='\";r=Yu((n.escape||mt).source+\"|\"+r.source+\"|\"+(r===tt?vt:mt).source+\"|\"+(n.evaluate||mt).source+\"|$\",\"g\");\n\tvar l=\"sourceURL\"in n?\"//# sourceURL=\"+n.sourceURL+\"\\n\":\"\";if(t.replace(r,function(n,r,e,o,f,l){return e||(e=o),a+=t.slice(c,l).replace(At,B),r&&(u=true,a+=\"'+__e(\"+r+\")+'\"),f&&(i=true,a+=\"';\"+f+\";\\n__p+='\"),e&&(a+=\"'+((__t=(\"+e+\"))==null?'':__t)+'\"),c=l+n.length,n}),a+=\"';\",(n=n.variable)||(a=\"with(obj){\"+a+\"}\"),a=(i?a.replace(q,\"\"):a).replace(V,\"$1\").replace(K,\"$1;\"),a=\"function(\"+(n||\"obj\")+\"){\"+(n?\"\":\"obj||(obj={});\")+\"var __t,__p=''\"+(u?\",__e=_.escape\":\"\")+(i?\",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}\":\";\")+a+\"return __p}\",\n\tn=Cf(function(){return Ku(o,l+\"return \"+a).apply(F,f)}),n.source=a,lu(n))throw n;return n},Ot.times=function(t,n){if(t=wu(t),1>t||9007199254740991<t)return[];var r=4294967295,e=Wi(t,4294967295);for(n=_e(n),t-=4294967295,e=E(e,n);++r<t;)n(r);return e},Ot.toFinite=ju,Ot.toInteger=wu,Ot.toLength=mu,Ot.toLower=function(t){return Eu(t).toLowerCase()},Ot.toNumber=Au,Ot.toSafeInteger=function(t){return dn(wu(t),-9007199254740991,9007199254740991)},Ot.toString=Eu,Ot.toUpper=function(t){return Eu(t).toUpperCase();\n\t},Ot.trim=function(t,n,r){return(t=Eu(t))&&(r||n===F)?t.replace(ft,\"\"):t&&(n=jr(n))?(t=$(t),r=$(n),n=z(t,r),r=W(t,r)+1,Ir(t,n,r).join(\"\")):t},Ot.trimEnd=function(t,n,r){return(t=Eu(t))&&(r||n===F)?t.replace(at,\"\"):t&&(n=jr(n))?(t=$(t),n=W(t,$(n))+1,Ir(t,0,n).join(\"\")):t},Ot.trimStart=function(t,n,r){return(t=Eu(t))&&(r||n===F)?t.replace(ct,\"\"):t&&(n=jr(n))?(t=$(t),n=z(t,$(n)),Ir(t,n).join(\"\")):t},Ot.truncate=function(t,n){var r=30,e=\"...\";if(_u(n))var u=\"separator\"in n?n.separator:u,r=\"length\"in n?wu(n.length):r,e=\"omission\"in n?jr(n.omission):e;\n\tt=Eu(t);var i=t.length;if(Wt.test(t))var o=$(t),i=o.length;if(r>=i)return t;if(i=r-T(e),1>i)return e;if(r=o?Ir(o,0,i).join(\"\"):t.slice(0,i),u===F)return r+e;if(o&&(i+=r.length-i),ff(u)){if(t.slice(i).search(u)){var f=r;for(u.global||(u=Yu(u.source,Eu(gt.exec(u))+\"g\")),u.lastIndex=0;o=u.exec(f);)var c=o.index;r=r.slice(0,c===F?i:c)}}else t.indexOf(jr(u),i)!=i&&(u=r.lastIndexOf(u),-1<u&&(r=r.slice(0,u)));return r+e},Ot.unescape=function(t){return(t=Eu(t))&&Y.test(t)?t.replace(G,en):t},Ot.uniqueId=function(t){\n\tvar n=++ii;return Eu(t)+n},Ot.upperCase=Lf,Ot.upperFirst=Uf,Ot.each=He,Ot.eachRight=Qe,Ot.first=Ne,Tu(Ot,function(){var t={};return On(Ot,function(n,r){ui.call(Ot.prototype,r)||(t[r]=n)}),t}(),{chain:false}),Ot.VERSION=\"4.16.4\",u(\"bind bindKey curry curryRight partial partialRight\".split(\" \"),function(t){Ot[t].placeholder=Ot}),u([\"drop\",\"take\"],function(t,n){Dt.prototype[t]=function(r){var e=this.__filtered__;if(e&&!n)return new Dt(this);r=r===F?1:zi(wu(r),0);var u=this.clone();return e?u.__takeCount__=Wi(r,u.__takeCount__):u.__views__.push({\n\tsize:Wi(r,4294967295),type:t+(0>u.__dir__?\"Right\":\"\")}),u},Dt.prototype[t+\"Right\"]=function(n){return this.reverse()[t](n).reverse()}}),u([\"filter\",\"map\",\"takeWhile\"],function(t,n){var r=n+1,e=1==r||3==r;Dt.prototype[t]=function(t){var n=this.clone();return n.__iteratees__.push({iteratee:_e(t,3),type:r}),n.__filtered__=n.__filtered__||e,n}}),u([\"head\",\"last\"],function(t,n){var r=\"take\"+(n?\"Right\":\"\");Dt.prototype[t]=function(){return this[r](1).value()[0]}}),u([\"initial\",\"tail\"],function(t,n){var r=\"drop\"+(n?\"\":\"Right\");\n\tDt.prototype[t]=function(){return this.__filtered__?new Dt(this):this[r](1)}}),Dt.prototype.compact=function(){return this.filter(Mu)},Dt.prototype.find=function(t){return this.filter(t).head()},Dt.prototype.findLast=function(t){return this.reverse().find(t)},Dt.prototype.invokeMap=lr(function(t,n){return typeof t==\"function\"?new Dt(this):this.map(function(r){return Mn(r,t,n)})}),Dt.prototype.reject=function(t){return this.filter(ou(_e(t)))},Dt.prototype.slice=function(t,n){t=wu(t);var r=this;return r.__filtered__&&(0<t||0>n)?new Dt(r):(0>t?r=r.takeRight(-t):t&&(r=r.drop(t)),\n\tn!==F&&(n=wu(n),r=0>n?r.dropRight(-n):r.take(n-t)),r)},Dt.prototype.takeRightWhile=function(t){return this.reverse().takeWhile(t).reverse()},Dt.prototype.toArray=function(){return this.take(4294967295)},On(Dt.prototype,function(t,n){var r=/^(?:filter|find|map|reject)|While$/.test(n),e=/^(?:head|last)$/.test(n),u=Ot[e?\"take\"+(\"last\"==n?\"Right\":\"\"):n],i=e||/^find/.test(n);u&&(Ot.prototype[n]=function(){function n(t){return t=u.apply(Ot,s([t],f)),e&&h?t[0]:t}var o=this.__wrapped__,f=e?[1]:arguments,c=o instanceof Dt,a=f[0],l=c||nf(o);\n\tl&&r&&typeof a==\"function\"&&1!=a.length&&(c=l=false);var h=this.__chain__,p=!!this.__actions__.length,a=i&&!h,c=c&&!p;return!i&&l?(o=c?o:new Dt(this),o=t.apply(o,f),o.__actions__.push({func:Je,args:[n],thisArg:F}),new Mt(o,h)):a&&c?t.apply(this,f):(o=this.thru(n),a?e?o.value()[0]:o.value():o)})}),u(\"pop push shift sort splice unshift\".split(\" \"),function(t){var n=Xu[t],r=/^(?:push|sort|unshift)$/.test(t)?\"tap\":\"thru\",e=/^(?:pop|shift)$/.test(t);Ot.prototype[t]=function(){var t=arguments;if(e&&!this.__chain__){\n\tvar u=this.value();return n.apply(nf(u)?u:[],t)}return this[r](function(r){return n.apply(nf(r)?r:[],t)})}}),On(Dt.prototype,function(t,n){var r=Ot[n];if(r){var e=r.name+\"\";(Zi[e]||(Zi[e]=[])).push({name:n,func:r})}}),Zi[Yr(F,2).name]=[{name:\"wrapper\",func:F}],Dt.prototype.clone=function(){var t=new Dt(this.__wrapped__);return t.__actions__=Cr(this.__actions__),t.__dir__=this.__dir__,t.__filtered__=this.__filtered__,t.__iteratees__=Cr(this.__iteratees__),t.__takeCount__=this.__takeCount__,t.__views__=Cr(this.__views__),\n\tt},Dt.prototype.reverse=function(){if(this.__filtered__){var t=new Dt(this);t.__dir__=-1,t.__filtered__=true}else t=this.clone(),t.__dir__*=-1;return t},Dt.prototype.value=function(){var t,n=this.__wrapped__.value(),r=this.__dir__,e=nf(n),u=0>r,i=e?n.length:0;t=i;for(var o=this.__views__,f=0,c=-1,a=o.length;++c<a;){var l=o[c],s=l.size;switch(l.type){case\"drop\":f+=s;break;case\"dropRight\":t-=s;break;case\"take\":t=Wi(t,f+s);break;case\"takeRight\":f=zi(f,t-s)}}if(t={start:f,end:t},o=t.start,f=t.end,t=f-o,\n\tu=u?f:o-1,o=this.__iteratees__,f=o.length,c=0,a=Wi(t,this.__takeCount__),!e||200>i||i==t&&a==t)return Ar(n,this.__actions__);e=[];t:for(;t--&&c<a;){for(u+=r,i=-1,l=n[u];++i<f;){var h=o[i],s=h.type,h=(0,h.iteratee)(l);if(2==s)l=h;else if(!h){if(1==s)continue t;break t}}e[c++]=l}return e},Ot.prototype.at=Lo,Ot.prototype.chain=function(){return Ge(this)},Ot.prototype.commit=function(){return new Mt(this.value(),this.__chain__)},Ot.prototype.next=function(){this.__values__===F&&(this.__values__=xu(this.value()));\n\tvar t=this.__index__>=this.__values__.length;return{done:t,value:t?F:this.__values__[this.__index__++]}},Ot.prototype.plant=function(t){for(var n,r=this;r instanceof Rt;){var e=De(r);e.__index__=0,e.__values__=F,n?u.__wrapped__=e:n=e;var u=e,r=r.__wrapped__}return u.__wrapped__=t,n},Ot.prototype.reverse=function(){var t=this.__wrapped__;return t instanceof Dt?(this.__actions__.length&&(t=new Dt(this)),t=t.reverse(),t.__actions__.push({func:Je,args:[qe],thisArg:F}),new Mt(t,this.__chain__)):this.thru(qe);\n\t},Ot.prototype.toJSON=Ot.prototype.valueOf=Ot.prototype.value=function(){return Ar(this.__wrapped__,this.__actions__)},Ot.prototype.first=Ot.prototype.head,vi&&(Ot.prototype[vi]=Ye),Ot}(); true?(Pt._=un, !(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return un}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))):qt?((qt.exports=un)._=un,Zt._=un):Pt._=un}).call(this);\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./../webpack/buildin/module.js */ 21)(module)))\n\n/***/ },\n/* 46 */\n/*!**********************************************************!*\\\n  !*** ./~/mousetrap-global-bind/mousetrap-global-bind.js ***!\n  \\**********************************************************/\n/***/ function(module, exports) {\n\n\t/**\r\n\t * adds a bindGlobal method to Mousetrap that allows you to\r\n\t * bind specific keyboard shortcuts that will still work\r\n\t * inside a text input field\r\n\t *\r\n\t * usage:\r\n\t * Mousetrap.bindGlobal('ctrl+s', _saveChanges);\r\n\t */\r\n\t/* global Mousetrap:true */\r\n\t(function(Mousetrap) {\r\n\t    var _globalCallbacks = {};\r\n\t    var _originalStopCallback = Mousetrap.prototype.stopCallback;\r\n\t\r\n\t    Mousetrap.prototype.stopCallback = function(e, element, combo, sequence) {\r\n\t        var self = this;\r\n\t\r\n\t        if (self.paused) {\r\n\t            return true;\r\n\t        }\r\n\t\r\n\t        if (_globalCallbacks[combo] || _globalCallbacks[sequence]) {\r\n\t            return false;\r\n\t        }\r\n\t\r\n\t        return _originalStopCallback.call(self, e, element, combo);\r\n\t    };\r\n\t\r\n\t    Mousetrap.prototype.bindGlobal = function(keys, callback, action) {\r\n\t        var self = this;\r\n\t        self.bind(keys, callback, action);\r\n\t\r\n\t        if (keys instanceof Array) {\r\n\t            for (var i = 0; i < keys.length; i++) {\r\n\t                _globalCallbacks[keys[i]] = true;\r\n\t            }\r\n\t            return;\r\n\t        }\r\n\t\r\n\t        _globalCallbacks[keys] = true;\r\n\t    };\r\n\t\t\r\n\t\tMousetrap.prototype.unbindGlobal = function(keys, action) {\r\n\t\t\tvar self = this;\r\n\t\t\tself.unbind(keys, action);\r\n\t\r\n\t\t\tif (keys instanceof Array) {\r\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\t\t\t_globalCallbacks[keys[i]] = false;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\r\n\t\t\t_globalCallbacks[keys] = false;\r\n\t\t};\r\n\t\r\n\t    Mousetrap.init();\r\n\t}) (Mousetrap);\r\n\n\n/***/ },\n/* 47 */\n/*!**********************************!*\\\n  !*** ./~/mousetrap/mousetrap.js ***!\n  \\**********************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */\n\t/**\n\t * Copyright 2016 Craig Campbell\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t *\n\t * Mousetrap is a simple keyboard shortcut library for Javascript with\n\t * no external dependencies\n\t *\n\t * @version 1.6.0\n\t * @url craig.is/killing/mice\n\t */\n\t(function(window, document, undefined) {\n\t\n\t    // Check if mousetrap is used inside browser, if not, return\n\t    if (!window) {\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * mapping of special keycodes to their corresponding keys\n\t     *\n\t     * everything in this dictionary cannot use keypress events\n\t     * so it has to be here to map to the correct keycodes for\n\t     * keyup/keydown events\n\t     *\n\t     * @type {Object}\n\t     */\n\t    var _MAP = {\n\t        8: 'backspace',\n\t        9: 'tab',\n\t        13: 'enter',\n\t        16: 'shift',\n\t        17: 'ctrl',\n\t        18: 'alt',\n\t        20: 'capslock',\n\t        27: 'esc',\n\t        32: 'space',\n\t        33: 'pageup',\n\t        34: 'pagedown',\n\t        35: 'end',\n\t        36: 'home',\n\t        37: 'left',\n\t        38: 'up',\n\t        39: 'right',\n\t        40: 'down',\n\t        45: 'ins',\n\t        46: 'del',\n\t        91: 'meta',\n\t        93: 'meta',\n\t        224: 'meta'\n\t    };\n\t\n\t    /**\n\t     * mapping for special characters so they can support\n\t     *\n\t     * this dictionary is only used incase you want to bind a\n\t     * keyup or keydown event to one of these keys\n\t     *\n\t     * @type {Object}\n\t     */\n\t    var _KEYCODE_MAP = {\n\t        106: '*',\n\t        107: '+',\n\t        109: '-',\n\t        110: '.',\n\t        111 : '/',\n\t        186: ';',\n\t        187: '=',\n\t        188: ',',\n\t        189: '-',\n\t        190: '.',\n\t        191: '/',\n\t        192: '`',\n\t        219: '[',\n\t        220: '\\\\',\n\t        221: ']',\n\t        222: '\\''\n\t    };\n\t\n\t    /**\n\t     * this is a mapping of keys that require shift on a US keypad\n\t     * back to the non shift equivelents\n\t     *\n\t     * this is so you can use keyup events with these keys\n\t     *\n\t     * note that this will only work reliably on US keyboards\n\t     *\n\t     * @type {Object}\n\t     */\n\t    var _SHIFT_MAP = {\n\t        '~': '`',\n\t        '!': '1',\n\t        '@': '2',\n\t        '#': '3',\n\t        '$': '4',\n\t        '%': '5',\n\t        '^': '6',\n\t        '&': '7',\n\t        '*': '8',\n\t        '(': '9',\n\t        ')': '0',\n\t        '_': '-',\n\t        '+': '=',\n\t        ':': ';',\n\t        '\\\"': '\\'',\n\t        '<': ',',\n\t        '>': '.',\n\t        '?': '/',\n\t        '|': '\\\\'\n\t    };\n\t\n\t    /**\n\t     * this is a list of special strings you can use to map\n\t     * to modifier keys when you specify your keyboard shortcuts\n\t     *\n\t     * @type {Object}\n\t     */\n\t    var _SPECIAL_ALIASES = {\n\t        'option': 'alt',\n\t        'command': 'meta',\n\t        'return': 'enter',\n\t        'escape': 'esc',\n\t        'plus': '+',\n\t        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n\t    };\n\t\n\t    /**\n\t     * variable to store the flipped version of _MAP from above\n\t     * needed to check if we should use keypress or not when no action\n\t     * is specified\n\t     *\n\t     * @type {Object|undefined}\n\t     */\n\t    var _REVERSE_MAP;\n\t\n\t    /**\n\t     * loop through the f keys, f1 to f19 and add them to the map\n\t     * programatically\n\t     */\n\t    for (var i = 1; i < 20; ++i) {\n\t        _MAP[111 + i] = 'f' + i;\n\t    }\n\t\n\t    /**\n\t     * loop through to map numbers on the numeric keypad\n\t     */\n\t    for (i = 0; i <= 9; ++i) {\n\t        _MAP[i + 96] = i;\n\t    }\n\t\n\t    /**\n\t     * cross browser add event method\n\t     *\n\t     * @param {Element|HTMLDocument} object\n\t     * @param {string} type\n\t     * @param {Function} callback\n\t     * @returns void\n\t     */\n\t    function _addEvent(object, type, callback) {\n\t        if (object.addEventListener) {\n\t            object.addEventListener(type, callback, false);\n\t            return;\n\t        }\n\t\n\t        object.attachEvent('on' + type, callback);\n\t    }\n\t\n\t    /**\n\t     * takes the event and returns the key character\n\t     *\n\t     * @param {Event} e\n\t     * @return {string}\n\t     */\n\t    function _characterFromEvent(e) {\n\t\n\t        // for keypress events we should return the character as is\n\t        if (e.type == 'keypress') {\n\t            var character = String.fromCharCode(e.which);\n\t\n\t            // if the shift key is not pressed then it is safe to assume\n\t            // that we want the character to be lowercase.  this means if\n\t            // you accidentally have caps lock on then your key bindings\n\t            // will continue to work\n\t            //\n\t            // the only side effect that might not be desired is if you\n\t            // bind something like 'A' cause you want to trigger an\n\t            // event when capital A is pressed caps lock will no longer\n\t            // trigger the event.  shift+a will though.\n\t            if (!e.shiftKey) {\n\t                character = character.toLowerCase();\n\t            }\n\t\n\t            return character;\n\t        }\n\t\n\t        // for non keypress events the special maps are needed\n\t        if (_MAP[e.which]) {\n\t            return _MAP[e.which];\n\t        }\n\t\n\t        if (_KEYCODE_MAP[e.which]) {\n\t            return _KEYCODE_MAP[e.which];\n\t        }\n\t\n\t        // if it is not in the special map\n\t\n\t        // with keydown and keyup events the character seems to always\n\t        // come in as an uppercase character whether you are pressing shift\n\t        // or not.  we should make sure it is always lowercase for comparisons\n\t        return String.fromCharCode(e.which).toLowerCase();\n\t    }\n\t\n\t    /**\n\t     * checks if two arrays are equal\n\t     *\n\t     * @param {Array} modifiers1\n\t     * @param {Array} modifiers2\n\t     * @returns {boolean}\n\t     */\n\t    function _modifiersMatch(modifiers1, modifiers2) {\n\t        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n\t    }\n\t\n\t    /**\n\t     * takes a key event and figures out what the modifiers are\n\t     *\n\t     * @param {Event} e\n\t     * @returns {Array}\n\t     */\n\t    function _eventModifiers(e) {\n\t        var modifiers = [];\n\t\n\t        if (e.shiftKey) {\n\t            modifiers.push('shift');\n\t        }\n\t\n\t        if (e.altKey) {\n\t            modifiers.push('alt');\n\t        }\n\t\n\t        if (e.ctrlKey) {\n\t            modifiers.push('ctrl');\n\t        }\n\t\n\t        if (e.metaKey) {\n\t            modifiers.push('meta');\n\t        }\n\t\n\t        return modifiers;\n\t    }\n\t\n\t    /**\n\t     * prevents default for this event\n\t     *\n\t     * @param {Event} e\n\t     * @returns void\n\t     */\n\t    function _preventDefault(e) {\n\t        if (e.preventDefault) {\n\t            e.preventDefault();\n\t            return;\n\t        }\n\t\n\t        e.returnValue = false;\n\t    }\n\t\n\t    /**\n\t     * stops propogation for this event\n\t     *\n\t     * @param {Event} e\n\t     * @returns void\n\t     */\n\t    function _stopPropagation(e) {\n\t        if (e.stopPropagation) {\n\t            e.stopPropagation();\n\t            return;\n\t        }\n\t\n\t        e.cancelBubble = true;\n\t    }\n\t\n\t    /**\n\t     * determines if the keycode specified is a modifier key or not\n\t     *\n\t     * @param {string} key\n\t     * @returns {boolean}\n\t     */\n\t    function _isModifier(key) {\n\t        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n\t    }\n\t\n\t    /**\n\t     * reverses the map lookup so that we can look for specific keys\n\t     * to see what can and can't use keypress\n\t     *\n\t     * @return {Object}\n\t     */\n\t    function _getReverseMap() {\n\t        if (!_REVERSE_MAP) {\n\t            _REVERSE_MAP = {};\n\t            for (var key in _MAP) {\n\t\n\t                // pull out the numeric keypad from here cause keypress should\n\t                // be able to detect the keys from the character\n\t                if (key > 95 && key < 112) {\n\t                    continue;\n\t                }\n\t\n\t                if (_MAP.hasOwnProperty(key)) {\n\t                    _REVERSE_MAP[_MAP[key]] = key;\n\t                }\n\t            }\n\t        }\n\t        return _REVERSE_MAP;\n\t    }\n\t\n\t    /**\n\t     * picks the best action based on the key combination\n\t     *\n\t     * @param {string} key - character for key\n\t     * @param {Array} modifiers\n\t     * @param {string=} action passed in\n\t     */\n\t    function _pickBestAction(key, modifiers, action) {\n\t\n\t        // if no action was picked in we should try to pick the one\n\t        // that we think would work best for this key\n\t        if (!action) {\n\t            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n\t        }\n\t\n\t        // modifier keys don't work as expected with keypress,\n\t        // switch to keydown\n\t        if (action == 'keypress' && modifiers.length) {\n\t            action = 'keydown';\n\t        }\n\t\n\t        return action;\n\t    }\n\t\n\t    /**\n\t     * Converts from a string key combination to an array\n\t     *\n\t     * @param  {string} combination like \"command+shift+l\"\n\t     * @return {Array}\n\t     */\n\t    function _keysFromString(combination) {\n\t        if (combination === '+') {\n\t            return ['+'];\n\t        }\n\t\n\t        combination = combination.replace(/\\+{2}/g, '+plus');\n\t        return combination.split('+');\n\t    }\n\t\n\t    /**\n\t     * Gets info for a specific key combination\n\t     *\n\t     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n\t     * @param  {string=} action\n\t     * @returns {Object}\n\t     */\n\t    function _getKeyInfo(combination, action) {\n\t        var keys;\n\t        var key;\n\t        var i;\n\t        var modifiers = [];\n\t\n\t        // take the keys from this pattern and figure out what the actual\n\t        // pattern is all about\n\t        keys = _keysFromString(combination);\n\t\n\t        for (i = 0; i < keys.length; ++i) {\n\t            key = keys[i];\n\t\n\t            // normalize key names\n\t            if (_SPECIAL_ALIASES[key]) {\n\t                key = _SPECIAL_ALIASES[key];\n\t            }\n\t\n\t            // if this is not a keypress event then we should\n\t            // be smart about using shift keys\n\t            // this will only work for US keyboards however\n\t            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n\t                key = _SHIFT_MAP[key];\n\t                modifiers.push('shift');\n\t            }\n\t\n\t            // if this key is a modifier then add it to the list of modifiers\n\t            if (_isModifier(key)) {\n\t                modifiers.push(key);\n\t            }\n\t        }\n\t\n\t        // depending on what the key combination is\n\t        // we will try to pick the best event for it\n\t        action = _pickBestAction(key, modifiers, action);\n\t\n\t        return {\n\t            key: key,\n\t            modifiers: modifiers,\n\t            action: action\n\t        };\n\t    }\n\t\n\t    function _belongsTo(element, ancestor) {\n\t        if (element === null || element === document) {\n\t            return false;\n\t        }\n\t\n\t        if (element === ancestor) {\n\t            return true;\n\t        }\n\t\n\t        return _belongsTo(element.parentNode, ancestor);\n\t    }\n\t\n\t    function Mousetrap(targetElement) {\n\t        var self = this;\n\t\n\t        targetElement = targetElement || document;\n\t\n\t        if (!(self instanceof Mousetrap)) {\n\t            return new Mousetrap(targetElement);\n\t        }\n\t\n\t        /**\n\t         * element to attach key events to\n\t         *\n\t         * @type {Element}\n\t         */\n\t        self.target = targetElement;\n\t\n\t        /**\n\t         * a list of all the callbacks setup via Mousetrap.bind()\n\t         *\n\t         * @type {Object}\n\t         */\n\t        self._callbacks = {};\n\t\n\t        /**\n\t         * direct map of string combinations to callbacks used for trigger()\n\t         *\n\t         * @type {Object}\n\t         */\n\t        self._directMap = {};\n\t\n\t        /**\n\t         * keeps track of what level each sequence is at since multiple\n\t         * sequences can start out with the same sequence\n\t         *\n\t         * @type {Object}\n\t         */\n\t        var _sequenceLevels = {};\n\t\n\t        /**\n\t         * variable to store the setTimeout call\n\t         *\n\t         * @type {null|number}\n\t         */\n\t        var _resetTimer;\n\t\n\t        /**\n\t         * temporary state where we will ignore the next keyup\n\t         *\n\t         * @type {boolean|string}\n\t         */\n\t        var _ignoreNextKeyup = false;\n\t\n\t        /**\n\t         * temporary state where we will ignore the next keypress\n\t         *\n\t         * @type {boolean}\n\t         */\n\t        var _ignoreNextKeypress = false;\n\t\n\t        /**\n\t         * are we currently inside of a sequence?\n\t         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n\t         *\n\t         * @type {boolean|string}\n\t         */\n\t        var _nextExpectedAction = false;\n\t\n\t        /**\n\t         * resets all sequence counters except for the ones passed in\n\t         *\n\t         * @param {Object} doNotReset\n\t         * @returns void\n\t         */\n\t        function _resetSequences(doNotReset) {\n\t            doNotReset = doNotReset || {};\n\t\n\t            var activeSequences = false,\n\t                key;\n\t\n\t            for (key in _sequenceLevels) {\n\t                if (doNotReset[key]) {\n\t                    activeSequences = true;\n\t                    continue;\n\t                }\n\t                _sequenceLevels[key] = 0;\n\t            }\n\t\n\t            if (!activeSequences) {\n\t                _nextExpectedAction = false;\n\t            }\n\t        }\n\t\n\t        /**\n\t         * finds all callbacks that match based on the keycode, modifiers,\n\t         * and action\n\t         *\n\t         * @param {string} character\n\t         * @param {Array} modifiers\n\t         * @param {Event|Object} e\n\t         * @param {string=} sequenceName - name of the sequence we are looking for\n\t         * @param {string=} combination\n\t         * @param {number=} level\n\t         * @returns {Array}\n\t         */\n\t        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n\t            var i;\n\t            var callback;\n\t            var matches = [];\n\t            var action = e.type;\n\t\n\t            // if there are no events related to this keycode\n\t            if (!self._callbacks[character]) {\n\t                return [];\n\t            }\n\t\n\t            // if a modifier key is coming up on its own we should allow it\n\t            if (action == 'keyup' && _isModifier(character)) {\n\t                modifiers = [character];\n\t            }\n\t\n\t            // loop through all callbacks for the key that was pressed\n\t            // and see if any of them match\n\t            for (i = 0; i < self._callbacks[character].length; ++i) {\n\t                callback = self._callbacks[character][i];\n\t\n\t                // if a sequence name is not specified, but this is a sequence at\n\t                // the wrong level then move onto the next match\n\t                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n\t                    continue;\n\t                }\n\t\n\t                // if the action we are looking for doesn't match the action we got\n\t                // then we should keep going\n\t                if (action != callback.action) {\n\t                    continue;\n\t                }\n\t\n\t                // if this is a keypress event and the meta key and control key\n\t                // are not pressed that means that we need to only look at the\n\t                // character, otherwise check the modifiers as well\n\t                //\n\t                // chrome will not fire a keypress if meta or control is down\n\t                // safari will fire a keypress if meta or meta+shift is down\n\t                // firefox will fire a keypress if meta or control is down\n\t                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\t\n\t                    // when you bind a combination or sequence a second time it\n\t                    // should overwrite the first one.  if a sequenceName or\n\t                    // combination is specified in this call it does just that\n\t                    //\n\t                    // @todo make deleting its own method?\n\t                    var deleteCombo = !sequenceName && callback.combo == combination;\n\t                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n\t                    if (deleteCombo || deleteSequence) {\n\t                        self._callbacks[character].splice(i, 1);\n\t                    }\n\t\n\t                    matches.push(callback);\n\t                }\n\t            }\n\t\n\t            return matches;\n\t        }\n\t\n\t        /**\n\t         * actually calls the callback function\n\t         *\n\t         * if your callback function returns false this will use the jquery\n\t         * convention - prevent default and stop propogation on the event\n\t         *\n\t         * @param {Function} callback\n\t         * @param {Event} e\n\t         * @returns void\n\t         */\n\t        function _fireCallback(callback, e, combo, sequence) {\n\t\n\t            // if this event should not happen stop here\n\t            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n\t                return;\n\t            }\n\t\n\t            if (callback(e, combo) === false) {\n\t                _preventDefault(e);\n\t                _stopPropagation(e);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * handles a character key event\n\t         *\n\t         * @param {string} character\n\t         * @param {Array} modifiers\n\t         * @param {Event} e\n\t         * @returns void\n\t         */\n\t        self._handleKey = function(character, modifiers, e) {\n\t            var callbacks = _getMatches(character, modifiers, e);\n\t            var i;\n\t            var doNotReset = {};\n\t            var maxLevel = 0;\n\t            var processedSequenceCallback = false;\n\t\n\t            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n\t            for (i = 0; i < callbacks.length; ++i) {\n\t                if (callbacks[i].seq) {\n\t                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n\t                }\n\t            }\n\t\n\t            // loop through matching callbacks for this key event\n\t            for (i = 0; i < callbacks.length; ++i) {\n\t\n\t                // fire for all sequence callbacks\n\t                // this is because if for example you have multiple sequences\n\t                // bound such as \"g i\" and \"g t\" they both need to fire the\n\t                // callback for matching g cause otherwise you can only ever\n\t                // match the first one\n\t                if (callbacks[i].seq) {\n\t\n\t                    // only fire callbacks for the maxLevel to prevent\n\t                    // subsequences from also firing\n\t                    //\n\t                    // for example 'a option b' should not cause 'option b' to fire\n\t                    // even though 'option b' is part of the other sequence\n\t                    //\n\t                    // any sequences that do not match here will be discarded\n\t                    // below by the _resetSequences call\n\t                    if (callbacks[i].level != maxLevel) {\n\t                        continue;\n\t                    }\n\t\n\t                    processedSequenceCallback = true;\n\t\n\t                    // keep a list of which sequences were matches for later\n\t                    doNotReset[callbacks[i].seq] = 1;\n\t                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n\t                    continue;\n\t                }\n\t\n\t                // if there were no sequence matches but we are still here\n\t                // that means this is a regular match so we should fire that\n\t                if (!processedSequenceCallback) {\n\t                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n\t                }\n\t            }\n\t\n\t            // if the key you pressed matches the type of sequence without\n\t            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n\t            // reset all sequences that were not matched by this event\n\t            //\n\t            // this is so, for example, if you have the sequence \"h a t\" and you\n\t            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n\t            // cause the sequence to reset\n\t            //\n\t            // modifier keys are ignored because you can have a sequence\n\t            // that contains modifiers such as \"enter ctrl+space\" and in most\n\t            // cases the modifier key will be pressed before the next key\n\t            //\n\t            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n\t            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n\t            //\n\t            // the \"keydown\" is expected when there is a modifier, but the\n\t            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n\t            // after and that causes the sequence to reset\n\t            //\n\t            // we ignore keypresses in a sequence that directly follow a keydown\n\t            // for the same character\n\t            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n\t            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n\t                _resetSequences(doNotReset);\n\t            }\n\t\n\t            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n\t        };\n\t\n\t        /**\n\t         * handles a keydown event\n\t         *\n\t         * @param {Event} e\n\t         * @returns void\n\t         */\n\t        function _handleKeyEvent(e) {\n\t\n\t            // normalize e.which for key events\n\t            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n\t            if (typeof e.which !== 'number') {\n\t                e.which = e.keyCode;\n\t            }\n\t\n\t            var character = _characterFromEvent(e);\n\t\n\t            // no character found then stop\n\t            if (!character) {\n\t                return;\n\t            }\n\t\n\t            // need to use === for the character check because the character can be 0\n\t            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n\t                _ignoreNextKeyup = false;\n\t                return;\n\t            }\n\t\n\t            self.handleKey(character, _eventModifiers(e), e);\n\t        }\n\t\n\t        /**\n\t         * called to set a 1 second timeout on the specified sequence\n\t         *\n\t         * this is so after each key press in the sequence you have 1 second\n\t         * to press the next key before you have to start over\n\t         *\n\t         * @returns void\n\t         */\n\t        function _resetSequenceTimer() {\n\t            clearTimeout(_resetTimer);\n\t            _resetTimer = setTimeout(_resetSequences, 1000);\n\t        }\n\t\n\t        /**\n\t         * binds a key sequence to an event\n\t         *\n\t         * @param {string} combo - combo specified in bind call\n\t         * @param {Array} keys\n\t         * @param {Function} callback\n\t         * @param {string=} action\n\t         * @returns void\n\t         */\n\t        function _bindSequence(combo, keys, callback, action) {\n\t\n\t            // start off by adding a sequence level record for this combination\n\t            // and setting the level to 0\n\t            _sequenceLevels[combo] = 0;\n\t\n\t            /**\n\t             * callback to increase the sequence level for this sequence and reset\n\t             * all other sequences that were active\n\t             *\n\t             * @param {string} nextAction\n\t             * @returns {Function}\n\t             */\n\t            function _increaseSequence(nextAction) {\n\t                return function() {\n\t                    _nextExpectedAction = nextAction;\n\t                    ++_sequenceLevels[combo];\n\t                    _resetSequenceTimer();\n\t                };\n\t            }\n\t\n\t            /**\n\t             * wraps the specified callback inside of another function in order\n\t             * to reset all sequence counters as soon as this sequence is done\n\t             *\n\t             * @param {Event} e\n\t             * @returns void\n\t             */\n\t            function _callbackAndReset(e) {\n\t                _fireCallback(callback, e, combo);\n\t\n\t                // we should ignore the next key up if the action is key down\n\t                // or keypress.  this is so if you finish a sequence and\n\t                // release the key the final key will not trigger a keyup\n\t                if (action !== 'keyup') {\n\t                    _ignoreNextKeyup = _characterFromEvent(e);\n\t                }\n\t\n\t                // weird race condition if a sequence ends with the key\n\t                // another sequence begins with\n\t                setTimeout(_resetSequences, 10);\n\t            }\n\t\n\t            // loop through keys one at a time and bind the appropriate callback\n\t            // function.  for any key leading up to the final one it should\n\t            // increase the sequence. after the final, it should reset all sequences\n\t            //\n\t            // if an action is specified in the original bind call then that will\n\t            // be used throughout.  otherwise we will pass the action that the\n\t            // next key in the sequence should match.  this allows a sequence\n\t            // to mix and match keypress and keydown events depending on which\n\t            // ones are better suited to the key provided\n\t            for (var i = 0; i < keys.length; ++i) {\n\t                var isFinal = i + 1 === keys.length;\n\t                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n\t                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * binds a single keyboard combination\n\t         *\n\t         * @param {string} combination\n\t         * @param {Function} callback\n\t         * @param {string=} action\n\t         * @param {string=} sequenceName - name of sequence if part of sequence\n\t         * @param {number=} level - what part of the sequence the command is\n\t         * @returns void\n\t         */\n\t        function _bindSingle(combination, callback, action, sequenceName, level) {\n\t\n\t            // store a direct mapped reference for use with Mousetrap.trigger\n\t            self._directMap[combination + ':' + action] = callback;\n\t\n\t            // make sure multiple spaces in a row become a single space\n\t            combination = combination.replace(/\\s+/g, ' ');\n\t\n\t            var sequence = combination.split(' ');\n\t            var info;\n\t\n\t            // if this pattern is a sequence of keys then run through this method\n\t            // to reprocess each pattern one key at a time\n\t            if (sequence.length > 1) {\n\t                _bindSequence(combination, sequence, callback, action);\n\t                return;\n\t            }\n\t\n\t            info = _getKeyInfo(combination, action);\n\t\n\t            // make sure to initialize array if this is the first time\n\t            // a callback is added for this key\n\t            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\t\n\t            // remove an existing match if there is one\n\t            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\t\n\t            // add this call back to the array\n\t            // if it is a sequence put it at the beginning\n\t            // if not put it at the end\n\t            //\n\t            // this is important because the way these are processed expects\n\t            // the sequence ones to come first\n\t            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n\t                callback: callback,\n\t                modifiers: info.modifiers,\n\t                action: info.action,\n\t                seq: sequenceName,\n\t                level: level,\n\t                combo: combination\n\t            });\n\t        }\n\t\n\t        /**\n\t         * binds multiple combinations to the same callback\n\t         *\n\t         * @param {Array} combinations\n\t         * @param {Function} callback\n\t         * @param {string|undefined} action\n\t         * @returns void\n\t         */\n\t        self._bindMultiple = function(combinations, callback, action) {\n\t            for (var i = 0; i < combinations.length; ++i) {\n\t                _bindSingle(combinations[i], callback, action);\n\t            }\n\t        };\n\t\n\t        // start!\n\t        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n\t        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n\t        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n\t    }\n\t\n\t    /**\n\t     * binds an event to mousetrap\n\t     *\n\t     * can be a single key, a combination of keys separated with +,\n\t     * an array of keys, or a sequence of keys separated by spaces\n\t     *\n\t     * be sure to list the modifier keys first to make sure that the\n\t     * correct key ends up getting bound (the last key in the pattern)\n\t     *\n\t     * @param {string|Array} keys\n\t     * @param {Function} callback\n\t     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n\t     * @returns void\n\t     */\n\t    Mousetrap.prototype.bind = function(keys, callback, action) {\n\t        var self = this;\n\t        keys = keys instanceof Array ? keys : [keys];\n\t        self._bindMultiple.call(self, keys, callback, action);\n\t        return self;\n\t    };\n\t\n\t    /**\n\t     * unbinds an event to mousetrap\n\t     *\n\t     * the unbinding sets the callback function of the specified key combo\n\t     * to an empty function and deletes the corresponding key in the\n\t     * _directMap dict.\n\t     *\n\t     * TODO: actually remove this from the _callbacks dictionary instead\n\t     * of binding an empty function\n\t     *\n\t     * the keycombo+action has to be exactly the same as\n\t     * it was defined in the bind method\n\t     *\n\t     * @param {string|Array} keys\n\t     * @param {string} action\n\t     * @returns void\n\t     */\n\t    Mousetrap.prototype.unbind = function(keys, action) {\n\t        var self = this;\n\t        return self.bind.call(self, keys, function() {}, action);\n\t    };\n\t\n\t    /**\n\t     * triggers an event that has already been bound\n\t     *\n\t     * @param {string} keys\n\t     * @param {string=} action\n\t     * @returns void\n\t     */\n\t    Mousetrap.prototype.trigger = function(keys, action) {\n\t        var self = this;\n\t        if (self._directMap[keys + ':' + action]) {\n\t            self._directMap[keys + ':' + action]({}, keys);\n\t        }\n\t        return self;\n\t    };\n\t\n\t    /**\n\t     * resets the library back to its initial state.  this is useful\n\t     * if you want to clear out the current keyboard shortcuts and bind\n\t     * new ones - for example if you switch to another page\n\t     *\n\t     * @returns void\n\t     */\n\t    Mousetrap.prototype.reset = function() {\n\t        var self = this;\n\t        self._callbacks = {};\n\t        self._directMap = {};\n\t        return self;\n\t    };\n\t\n\t    /**\n\t     * should we stop this event before firing off callbacks\n\t     *\n\t     * @param {Event} e\n\t     * @param {Element} element\n\t     * @return {boolean}\n\t     */\n\t    Mousetrap.prototype.stopCallback = function(e, element) {\n\t        var self = this;\n\t\n\t        // if the element has the class \"mousetrap\" then no need to stop\n\t        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n\t            return false;\n\t        }\n\t\n\t        if (_belongsTo(element, self.target)) {\n\t            return false;\n\t        }\n\t\n\t        // stop for input, select, and textarea\n\t        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n\t    };\n\t\n\t    /**\n\t     * exposes _handleKey publicly so it can be overwritten by extensions\n\t     */\n\t    Mousetrap.prototype.handleKey = function() {\n\t        var self = this;\n\t        return self._handleKey.apply(self, arguments);\n\t    };\n\t\n\t    /**\n\t     * allow custom key mappings\n\t     */\n\t    Mousetrap.addKeycodes = function(object) {\n\t        for (var key in object) {\n\t            if (object.hasOwnProperty(key)) {\n\t                _MAP[key] = object[key];\n\t            }\n\t        }\n\t        _REVERSE_MAP = null;\n\t    };\n\t\n\t    /**\n\t     * Init the global mousetrap functions\n\t     *\n\t     * This method is needed to allow the global mousetrap functions to work\n\t     * now that mousetrap is a constructor function.\n\t     */\n\t    Mousetrap.init = function() {\n\t        var documentMousetrap = Mousetrap(document);\n\t        for (var method in documentMousetrap) {\n\t            if (method.charAt(0) !== '_') {\n\t                Mousetrap[method] = (function(method) {\n\t                    return function() {\n\t                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n\t                    };\n\t                } (method));\n\t            }\n\t        }\n\t    };\n\t\n\t    Mousetrap.init();\n\t\n\t    // expose mousetrap to the global object\n\t    window.Mousetrap = Mousetrap;\n\t\n\t    // expose as a common js module\n\t    if (typeof module !== 'undefined' && module.exports) {\n\t        module.exports = Mousetrap;\n\t    }\n\t\n\t    // expose mousetrap as an AMD module\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t            return Mousetrap;\n\t        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n\n\n/***/ },\n/* 48 */\n/*!**************************************************************!*\\\n  !*** ./~/pouchdb-find/lib/abstract-mapreduce/create-view.js ***!\n  \\**************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar upsert = __webpack_require__(/*! ./upsert */ 11);\n\tvar utils = __webpack_require__(/*! ./utils */ 9);\n\tvar Promise = utils.Promise;\n\t\n\tfunction stringify(input) {\n\t  if (!input) {\n\t    return 'undefined'; // backwards compat for empty reduce\n\t  }\n\t  // for backwards compat with mapreduce, functions/strings are stringified\n\t  // as-is. everything else is JSON-stringified.\n\t  switch (typeof input) {\n\t    case 'function':\n\t      // e.g. a mapreduce map\n\t      return input.toString();\n\t    case 'string':\n\t      // e.g. a mapreduce built-in _reduce function\n\t      return input.toString();\n\t    default:\n\t      // e.g. a JSON object in the case of mango queries\n\t      return JSON.stringify(input);\n\t  }\n\t}\n\t\n\tmodule.exports = function (opts) {\n\t  var sourceDB = opts.db;\n\t  var viewName = opts.viewName;\n\t  var mapFun = opts.map;\n\t  var reduceFun = opts.reduce;\n\t  var temporary = opts.temporary;\n\t  var pluginName = opts.pluginName;\n\t\n\t  // the \"undefined\" part is for backwards compatibility\n\t  var viewSignature = stringify(mapFun) + stringify(reduceFun) +\n\t    'undefined';\n\t\n\t  if (!temporary && sourceDB._cachedViews) {\n\t    var cachedView = sourceDB._cachedViews[viewSignature];\n\t    if (cachedView) {\n\t      return Promise.resolve(cachedView);\n\t    }\n\t  }\n\t\n\t  return sourceDB.info().then(function (info) {\n\t\n\t    var depDbName = info.db_name + '-mrview-' +\n\t      (temporary ? 'temp' : utils.MD5(viewSignature));\n\t\n\t    // save the view name in the source PouchDB so it can be cleaned up if necessary\n\t    // (e.g. when the _design doc is deleted, remove all associated view data)\n\t    function diffFunction(doc) {\n\t      doc.views = doc.views || {};\n\t      var fullViewName = viewName;\n\t      if (fullViewName.indexOf('/') === -1) {\n\t        fullViewName = viewName + '/' + viewName;\n\t      }\n\t      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n\t      /* istanbul ignore if */\n\t      if (depDbs[depDbName]) {\n\t        return; // no update necessary\n\t      }\n\t      depDbs[depDbName] = true;\n\t      return doc;\n\t    }\n\t    return upsert(sourceDB, '_local/' + pluginName, diffFunction).then(function () {\n\t      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n\t        var db = res.db;\n\t        db.auto_compaction = true;\n\t        var view = {\n\t          name: depDbName,\n\t          db: db, \n\t          sourceDB: sourceDB,\n\t          adapter: sourceDB.adapter,\n\t          mapFun: mapFun,\n\t          reduceFun: reduceFun\n\t        };\n\t        return view.db.get('_local/lastSeq').catch(function (err) {\n\t          /* istanbul ignore if */\n\t          if (err.status !== 404) {\n\t            throw err;\n\t          }\n\t        }).then(function (lastSeqDoc) {\n\t          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n\t          if (!temporary) {\n\t            sourceDB._cachedViews = sourceDB._cachedViews || {};\n\t            sourceDB._cachedViews[viewSignature] = view;\n\t            view.db.on('destroyed', function () {\n\t              delete sourceDB._cachedViews[viewSignature];\n\t            });\n\t          }\n\t          return view;\n\t        });\n\t      });\n\t    });\n\t  });\n\t};\n\n\n/***/ },\n/* 49 */\n/*!********************************************************!*\\\n  !*** ./~/pouchdb-find/lib/abstract-mapreduce/index.js ***!\n  \\********************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar pouchCollate = __webpack_require__(/*! pouchdb-collate */ 7);\n\tvar TaskQueue = __webpack_require__(/*! ./taskqueue */ 50);\n\tvar collate = pouchCollate.collate;\n\tvar toIndexableString = pouchCollate.toIndexableString;\n\tvar normalizeKey = pouchCollate.normalizeKey;\n\tvar createView = __webpack_require__(/*! ./create-view */ 48);\n\tvar log;\n\t/* istanbul ignore else */\n\tif ((typeof console !== 'undefined') && (typeof console.log === 'function')) {\n\t  log = Function.prototype.bind.call(console.log, console);\n\t} else {\n\t  log = function () {};\n\t}\n\tvar utils = __webpack_require__(/*! ./utils */ 9);\n\tvar Promise = utils.Promise;\n\tvar persistentQueues = {};\n\tvar tempViewQueue = new TaskQueue();\n\tvar CHANGES_BATCH_SIZE = 50;\n\t\n\tfunction QueryParseError(message) {\n\t  this.status = 400;\n\t  this.name = 'query_parse_error';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, QueryParseError);\n\t  } catch (e) {}\n\t}\n\t\n\tutils.inherits(QueryParseError, Error);\n\t\n\tfunction NotFoundError(message) {\n\t  this.status = 404;\n\t  this.name = 'not_found';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, NotFoundError);\n\t  } catch (e) {}\n\t}\n\t\n\tutils.inherits(NotFoundError, Error);\n\t\n\tfunction parseViewName(name) {\n\t  // can be either 'ddocname/viewname' or just 'viewname'\n\t  // (where the ddoc name is the same)\n\t  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n\t}\n\t\n\tfunction isGenOne(changes) {\n\t  // only return true if the current change is 1-\n\t  // and there are no other leafs\n\t  return changes.length === 1 && /^1-/.test(changes[0].rev);\n\t}\n\t\n\tfunction sortByKeyThenValue(x, y) {\n\t  var keyCompare = collate(x.key, y.key);\n\t  return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n\t}\n\t\n\tfunction sliceResults(results, limit, skip) {\n\t  skip = skip || 0;\n\t  if (typeof limit === 'number') {\n\t    return results.slice(skip, limit + skip);\n\t  } else if (skip > 0) {\n\t    return results.slice(skip);\n\t  }\n\t  return results;\n\t}\n\t\n\tfunction rowToDocId(row) {\n\t  var val = row.value;\n\t  // Users can explicitly specify a joined doc _id, or it\n\t  // defaults to the doc _id that emitted the key/value.\n\t  var docId = (val && typeof val === 'object' && val._id) || row.id;\n\t  return docId;\n\t}\n\t\n\tfunction emitError(db, e) {\n\t  try {\n\t    db.emit('error', e);\n\t  } catch (err) {\n\t    console.error(\n\t      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n\t      'You can debug this error by doing:\\n' +\n\t      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n\t      'Please double-check your map/reduce function.');\n\t    console.error(e);\n\t  }\n\t}\n\t\n\tfunction tryCode(db, fun, args) {\n\t  // emit an event if there was an error thrown by a map/reduce function.\n\t  // putting try/catches in a single function also avoids deoptimizations.\n\t  try {\n\t    return {\n\t      output : fun.apply(null, args)\n\t    };\n\t  } catch (e) {\n\t    emitError(db, e);\n\t    return {error: e};\n\t  }\n\t}\n\t\n\tfunction checkQueryParseError(options, fun) {\n\t  var startkeyName = options.descending ? 'endkey' : 'startkey';\n\t  var endkeyName = options.descending ? 'startkey' : 'endkey';\n\t\n\t  if (typeof options[startkeyName] !== 'undefined' &&\n\t    typeof options[endkeyName] !== 'undefined' &&\n\t    collate(options[startkeyName], options[endkeyName]) > 0) {\n\t    throw new QueryParseError('No rows can match your key range, reverse your ' +\n\t    'start_key and end_key or set {descending : true}');\n\t  } else if (fun.reduce && options.reduce !== false) {\n\t    if (options.include_docs) {\n\t      throw new QueryParseError('{include_docs:true} is invalid for reduce');\n\t    } else if (options.keys && options.keys.length > 1 &&\n\t      !options.group && !options.group_level) {\n\t      throw new QueryParseError('Multi-key fetches for reduce views must use {group: true}');\n\t    }\n\t  }\n\t  if (options.group_level) {\n\t    if (typeof options.group_level !== 'number') {\n\t      throw new QueryParseError('Invalid value for integer: \"' + options.group_level + '\"');\n\t    }\n\t    if (options.group_level < 0) {\n\t      throw new QueryParseError('Invalid value for positive integer: ' +\n\t      '\"' + options.group_level + '\"');\n\t    }\n\t  }\n\t}\n\t\n\tfunction defaultsTo(value) {\n\t  return function (reason) {\n\t    /* istanbul ignore else */\n\t    if (reason.status === 404) {\n\t      return value;\n\t    } else {\n\t      throw reason;\n\t    }\n\t  };\n\t}\n\t\n\tfunction createIndexer(def) {\n\t\n\t  var pluginName = def.name;\n\t  var mapper = def.mapper;\n\t  var reducer = def.reducer;\n\t  var ddocValidator = def.ddocValidator;\n\t\n\t\n\t  // returns a promise for a list of docs to update, based on the input docId.\n\t  // the order doesn't matter, because post-3.2.0, bulkDocs\n\t  // is an atomic operation in all three adapters.\n\t  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n\t    var metaDocId = '_local/doc_' + docId;\n\t    var defaultMetaDoc = {_id: metaDocId, keys: []};\n\t    var docData = docIdsToChangesAndEmits[docId];\n\t    var indexableKeysToKeyValues = docData.indexableKeysToKeyValues;\n\t    var changes = docData.changes;\n\t\n\t    function getMetaDoc() {\n\t      if (isGenOne(changes)) {\n\t        // generation 1, so we can safely assume initial state\n\t        // for performance reasons (avoids unnecessary GETs)\n\t        return Promise.resolve(defaultMetaDoc);\n\t      }\n\t      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n\t    }\n\t\n\t    function getKeyValueDocs(metaDoc) {\n\t      if (!metaDoc.keys.length) {\n\t        // no keys, no need for a lookup\n\t        return Promise.resolve({rows: []});\n\t      }\n\t      return view.db.allDocs({\n\t        keys: metaDoc.keys,\n\t        include_docs: true\n\t      });\n\t    }\n\t\n\t    function processKvDocs(metaDoc, kvDocsRes) {\n\t      var kvDocs = [];\n\t      var oldKeysMap = {};\n\t\n\t      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n\t        var row = kvDocsRes.rows[i];\n\t        var doc = row.doc;\n\t        if (!doc) { // deleted\n\t          continue;\n\t        }\n\t        kvDocs.push(doc);\n\t        oldKeysMap[doc._id] = true;\n\t        doc._deleted = !indexableKeysToKeyValues[doc._id];\n\t        if (!doc._deleted) {\n\t          var keyValue = indexableKeysToKeyValues[doc._id];\n\t          if ('value' in keyValue) {\n\t            doc.value = keyValue.value;\n\t          }\n\t        }\n\t      }\n\t\n\t      var newKeys = Object.keys(indexableKeysToKeyValues);\n\t      newKeys.forEach(function (key) {\n\t        if (!oldKeysMap[key]) {\n\t          // new doc\n\t          var kvDoc = {\n\t            _id: key\n\t          };\n\t          var keyValue = indexableKeysToKeyValues[key];\n\t          if ('value' in keyValue) {\n\t            kvDoc.value = keyValue.value;\n\t          }\n\t          kvDocs.push(kvDoc);\n\t        }\n\t      });\n\t      metaDoc.keys = utils.uniq(newKeys.concat(metaDoc.keys));\n\t      kvDocs.push(metaDoc);\n\t\n\t      return kvDocs;\n\t    }\n\t\n\t    return getMetaDoc().then(function (metaDoc) {\n\t      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n\t        return processKvDocs(metaDoc, kvDocsRes);\n\t      });\n\t    });\n\t  }\n\t\n\t  // updates all emitted key/value docs and metaDocs in the mrview database\n\t  // for the given batch of documents from the source database\n\t  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n\t    var seqDocId = '_local/lastSeq';\n\t    return view.db.get(seqDocId)\n\t    .catch(defaultsTo({_id: seqDocId, seq: 0}))\n\t    .then(function (lastSeqDoc) {\n\t      var docIds = Object.keys(docIdsToChangesAndEmits);\n\t      return Promise.all(docIds.map(function (docId) {\n\t        return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n\t      })).then(function (listOfDocsToPersist) {\n\t        var docsToPersist = utils.flatten(listOfDocsToPersist);\n\t        lastSeqDoc.seq = seq;\n\t        docsToPersist.push(lastSeqDoc);\n\t        // write all docs in a single operation, update the seq once\n\t        return view.db.bulkDocs({docs : docsToPersist});\n\t      });\n\t    });\n\t  }\n\t\n\t  function getQueue(view) {\n\t    var viewName = typeof view === 'string' ? view : view.name;\n\t    var queue = persistentQueues[viewName];\n\t    if (!queue) {\n\t      queue = persistentQueues[viewName] = new TaskQueue();\n\t    }\n\t    return queue;\n\t  }\n\t\n\t  function updateView(view) {\n\t    return utils.sequentialize(getQueue(view), function () {\n\t      return updateViewInQueue(view);\n\t    })();\n\t  }\n\t\n\t  function updateViewInQueue(view) {\n\t    // bind the emit function once\n\t    var mapResults;\n\t    var doc;\n\t\n\t    function emit(key, value) {\n\t      var output = {id: doc._id, key: normalizeKey(key)};\n\t      // Don't explicitly store the value unless it's defined and non-null.\n\t      // This saves on storage space, because often people don't use it.\n\t      if (typeof value !== 'undefined' && value !== null) {\n\t        output.value = normalizeKey(value);\n\t      }\n\t      mapResults.push(output);\n\t    }\n\t\n\t    var mapFun = mapper(view.mapFun, emit);\n\t\n\t    var currentSeq = view.seq || 0;\n\t\n\t    function processChange(docIdsToChangesAndEmits, seq) {\n\t      return function () {\n\t        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n\t      };\n\t    }\n\t\n\t    var queue = new TaskQueue();\n\t\n\t    return new Promise(function (resolve, reject) {\n\t\n\t      function complete() {\n\t        queue.finish().then(function () {\n\t          view.seq = currentSeq;\n\t          resolve();\n\t        });\n\t      }\n\t\n\t      function processNextBatch() {\n\t        view.sourceDB.changes({\n\t          conflicts: true,\n\t          include_docs: true,\n\t          style: 'all_docs',\n\t          since: currentSeq,\n\t          limit: CHANGES_BATCH_SIZE\n\t        }).on('complete', function (response) {\n\t          var results = response.results;\n\t          if (!results.length) {\n\t            return complete();\n\t          }\n\t          var docIdsToChangesAndEmits = {};\n\t          for (var i = 0, l = results.length; i < l; i++) {\n\t            var change = results[i];\n\t            if (change.doc._id[0] !== '_') {\n\t              mapResults = [];\n\t              doc = change.doc;\n\t\n\t              if (!doc._deleted) {\n\t                tryCode(view.sourceDB, mapFun, [doc]);\n\t              }\n\t              mapResults.sort(sortByKeyThenValue);\n\t\n\t              var indexableKeysToKeyValues = {};\n\t              var lastKey;\n\t              for (var j = 0, jl = mapResults.length; j < jl; j++) {\n\t                var obj = mapResults[j];\n\t                var complexKey = [obj.key, obj.id];\n\t                if (collate(obj.key, lastKey) === 0) {\n\t                  complexKey.push(j); // dup key+id, so make it unique\n\t                }\n\t                var indexableKey = toIndexableString(complexKey);\n\t                indexableKeysToKeyValues[indexableKey] = obj;\n\t                lastKey = obj.key;\n\t              }\n\t              docIdsToChangesAndEmits[change.doc._id] = {\n\t                indexableKeysToKeyValues: indexableKeysToKeyValues,\n\t                changes: change.changes\n\t              };\n\t            }\n\t            currentSeq = change.seq;\n\t          }\n\t          queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\t          if (results.length < CHANGES_BATCH_SIZE) {\n\t            return complete();\n\t          }\n\t          return processNextBatch();\n\t        }).on('error', onError);\n\t        /* istanbul ignore next */\n\t        function onError(err) {\n\t          reject(err);\n\t        }\n\t      }\n\t\n\t      processNextBatch();\n\t    });\n\t  }\n\t\n\t  function reduceView(view, results, options) {\n\t    if (options.group_level === 0) {\n\t      delete options.group_level;\n\t    }\n\t\n\t    var shouldGroup = options.group || options.group_level;\n\t\n\t    var reduceFun = reducer(view.reduceFun);\n\t\n\t    var groups = [];\n\t    var lvl = options.group_level;\n\t    results.forEach(function (e) {\n\t      var last = groups[groups.length - 1];\n\t      var key = shouldGroup ? e.key : null;\n\t\n\t      // only set group_level for array keys\n\t      if (shouldGroup && Array.isArray(key) && typeof lvl === 'number') {\n\t        key = key.length > lvl ? key.slice(0, lvl) : key;\n\t      }\n\t\n\t      if (last && collate(last.key[0][0], key) === 0) {\n\t        last.key.push([key, e.id]);\n\t        last.value.push(e.value);\n\t        return;\n\t      }\n\t      groups.push({key: [\n\t        [key, e.id]\n\t      ], value: [e.value]});\n\t    });\n\t    for (var i = 0, len = groups.length; i < len; i++) {\n\t      var e = groups[i];\n\t      var reduceTry = tryCode(view.sourceDB, reduceFun, [e.key, e.value, false]);\n\t      // TODO: can't do instanceof BuiltInError because this class is buried\n\t      // in mapreduce.js\n\t      if (reduceTry.error && /BuiltInError/.test(reduceTry.error.constructor)) {\n\t        // CouchDB returns an error if a built-in errors out\n\t        throw reduceTry.error;\n\t      }\n\t      // CouchDB just sets the value to null if a non-built-in errors out\n\t      e.value = reduceTry.error ? null : reduceTry.output;\n\t      e.key = e.key[0][0];\n\t    }\n\t    // no total_rows/offset when reducing\n\t    return {rows: sliceResults(groups, options.limit, options.skip)};\n\t  }\n\t\n\t  function queryView(view, opts) {\n\t    return utils.sequentialize(getQueue(view), function () {\n\t      return queryViewInQueue(view, opts);\n\t    })();\n\t  }\n\t\n\t  function queryViewInQueue(view, opts) {\n\t    var totalRows;\n\t    var shouldReduce = view.reduceFun && opts.reduce !== false;\n\t    var skip = opts.skip || 0;\n\t    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n\t      // equivalent query\n\t      opts.limit = 0;\n\t      delete opts.keys;\n\t    }\n\t\n\t    function fetchFromView(viewOpts) {\n\t      viewOpts.include_docs = true;\n\t      return view.db.allDocs(viewOpts).then(function (res) {\n\t        totalRows = res.total_rows;\n\t        return res.rows.map(function (result) {\n\t\n\t          // implicit migration - in older versions of PouchDB,\n\t          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n\t          // this is tested in a migration test\n\t          /* istanbul ignore next */\n\t          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n\t              result.doc.value !== null) {\n\t            var keys = Object.keys(result.doc.value).sort();\n\t            // this detection method is not perfect, but it's unlikely the user\n\t            // emitted a value which was an object with these 3 exact keys\n\t            var expectedKeys = ['id', 'key', 'value'];\n\t            if (!(keys < expectedKeys || keys > expectedKeys)) {\n\t              return result.doc.value;\n\t            }\n\t          }\n\t\n\t          var parsedKeyAndDocId = pouchCollate.parseIndexableString(result.doc._id);\n\t          return {\n\t            key: parsedKeyAndDocId[0],\n\t            id: parsedKeyAndDocId[1],\n\t            value: ('value' in result.doc ? result.doc.value : null)\n\t          };\n\t        });\n\t      });\n\t    }\n\t\n\t    function onMapResultsReady(rows) {\n\t      var finalResults;\n\t      if (shouldReduce) {\n\t        finalResults = reduceView(view, rows, opts);\n\t      } else {\n\t        finalResults = {\n\t          total_rows: totalRows,\n\t          offset: skip,\n\t          rows: rows\n\t        };\n\t      }\n\t      if (opts.include_docs) {\n\t        var docIds = utils.uniq(rows.map(rowToDocId));\n\t\n\t        return view.sourceDB.allDocs({\n\t          keys: docIds,\n\t          include_docs: true,\n\t          conflicts: opts.conflicts,\n\t          attachments: opts.attachments,\n\t          binary: opts.binary\n\t        }).then(function (allDocsRes) {\n\t          var docIdsToDocs = {};\n\t          allDocsRes.rows.forEach(function (row) {\n\t            if (row.doc) {\n\t              docIdsToDocs['$' + row.id] = row.doc;\n\t            }\n\t          });\n\t          rows.forEach(function (row) {\n\t            var docId = rowToDocId(row);\n\t            var doc = docIdsToDocs['$' + docId];\n\t            if (doc) {\n\t              row.doc = doc;\n\t            }\n\t          });\n\t          return finalResults;\n\t        });\n\t      } else {\n\t        return finalResults;\n\t      }\n\t    }\n\t\n\t    var flatten = function (array) {\n\t      return array.reduce(function (prev, cur) {\n\t        return prev.concat(cur);\n\t      });\n\t    };\n\t\n\t    if (typeof opts.keys !== 'undefined') {\n\t      var keys = opts.keys;\n\t      var fetchPromises = keys.map(function (key) {\n\t        var viewOpts = {\n\t          startkey : toIndexableString([key]),\n\t          endkey   : toIndexableString([key, {}])\n\t        };\n\t        return fetchFromView(viewOpts);\n\t      });\n\t      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n\t    } else { // normal query, no 'keys'\n\t      var viewOpts = {\n\t        descending : opts.descending\n\t      };\n\t      if (typeof opts.startkey !== 'undefined') {\n\t        viewOpts.startkey = opts.descending ?\n\t          toIndexableString([opts.startkey, {}]) :\n\t          toIndexableString([opts.startkey]);\n\t      }\n\t      if (typeof opts.endkey !== 'undefined') {\n\t        var inclusiveEnd = opts.inclusive_end !== false;\n\t        if (opts.descending) {\n\t          inclusiveEnd = !inclusiveEnd;\n\t        }\n\t\n\t        viewOpts.endkey = toIndexableString(inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);\n\t      }\n\t      if (typeof opts.key !== 'undefined') {\n\t        var keyStart = toIndexableString([opts.key]);\n\t        var keyEnd = toIndexableString([opts.key, {}]);\n\t        if (viewOpts.descending) {\n\t          viewOpts.endkey = keyStart;\n\t          viewOpts.startkey = keyEnd;\n\t        } else {\n\t          viewOpts.startkey = keyStart;\n\t          viewOpts.endkey = keyEnd;\n\t        }\n\t      }\n\t      if (!shouldReduce) {\n\t        if (typeof opts.limit === 'number') {\n\t          viewOpts.limit = opts.limit;\n\t        }\n\t        viewOpts.skip = skip;\n\t      }\n\t      return fetchFromView(viewOpts).then(onMapResultsReady);\n\t    }\n\t  }\n\t\n\t  function localViewCleanup(db) {\n\t    return db.get('_local/' + pluginName).then(function (metaDoc) {\n\t      var docsToViews = {};\n\t      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n\t        var parts = parseViewName(fullViewName);\n\t        var designDocName = '_design/' + parts[0];\n\t        var viewName = parts[1];\n\t        docsToViews[designDocName] = docsToViews[designDocName] || {};\n\t        docsToViews[designDocName][viewName] = true;\n\t      });\n\t      var opts = {\n\t        keys : Object.keys(docsToViews),\n\t        include_docs : true\n\t      };\n\t      return db.allDocs(opts).then(function (res) {\n\t        var viewsToStatus = {};\n\t        res.rows.forEach(function (row) {\n\t          var ddocName = row.key.substring(8);\n\t          Object.keys(docsToViews[row.key]).forEach(function (viewName) {\n\t            var fullViewName = ddocName + '/' + viewName;\n\t            /* istanbul ignore if */\n\t            if (!metaDoc.views[fullViewName]) {\n\t              // new format, without slashes, to support PouchDB 2.2.0\n\t              // migration test in pouchdb's browser.migration.js verifies this\n\t              fullViewName = viewName;\n\t            }\n\t            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n\t            // design doc deleted, or view function nonexistent\n\t            var statusIsGood = row.doc && row.doc.views && row.doc.views[viewName];\n\t            viewDBNames.forEach(function (viewDBName) {\n\t              viewsToStatus[viewDBName] = viewsToStatus[viewDBName] || statusIsGood;\n\t            });\n\t          });\n\t        });\n\t        var dbsToDelete = Object.keys(viewsToStatus).filter(function (viewDBName) {\n\t          return !viewsToStatus[viewDBName];\n\t        });\n\t        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n\t          return utils.sequentialize(getQueue(viewDBName), function () {\n\t            return new db.constructor(viewDBName, db.__opts).destroy();\n\t          })();\n\t        });\n\t        return Promise.all(destroyPromises).then(function () {\n\t          return {ok: true};\n\t        });\n\t      });\n\t    }, defaultsTo({ok: true}));\n\t  }\n\t\n\t  function queryPromised(db, fun, opts) {\n\t    if (typeof fun !== 'string') {\n\t      // temp_view\n\t      checkQueryParseError(opts, fun);\n\t\n\t      var createViewOpts = {\n\t        db : db,\n\t        viewName : 'temp_view/temp_view',\n\t        map : fun.map,\n\t        reduce : fun.reduce,\n\t        temporary : true,\n\t        pluginName: pluginName\n\t      };\n\t      tempViewQueue.add(function () {\n\t        return createView(createViewOpts).then(function (view) {\n\t          function cleanup() {\n\t            return view.db.destroy();\n\t          }\n\t          return utils.fin(updateView(view).then(function () {\n\t            return queryView(view, opts);\n\t          }), cleanup);\n\t        });\n\t      });\n\t      return tempViewQueue.finish();\n\t    } else {\n\t      // persistent view\n\t      var fullViewName = fun;\n\t      var parts = parseViewName(fullViewName);\n\t      var designDocName = parts[0];\n\t      var viewName = parts[1];\n\t      return db.get('_design/' + designDocName).then(function (doc) {\n\t        var fun = doc.views && doc.views[viewName];\n\t\n\t        if (!fun) {\n\t          // basic validator; it's assumed that every subclass would want this\n\t          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n\t            viewName);\n\t        }\n\t\n\t        ddocValidator(doc, viewName);\n\t        checkQueryParseError(opts, fun);\n\t\n\t        var createViewOpts = {\n\t          db : db,\n\t          viewName : fullViewName,\n\t          map : fun.map,\n\t          reduce : fun.reduce,\n\t          pluginName: pluginName\n\t        };\n\t        return createView(createViewOpts).then(function (view) {\n\t          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n\t            if (opts.stale === 'update_after') {\n\t              process.nextTick(function () {\n\t                updateView(view);\n\t              });\n\t            }\n\t            return queryView(view, opts);\n\t          } else { // stale not ok\n\t            return updateView(view).then(function () {\n\t              return queryView(view, opts);\n\t            });\n\t          }\n\t        });\n\t      });\n\t    }\n\t  }\n\t\n\t  var query = function (fun, opts, callback) {\n\t    var db = this;\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = utils.extend(true, {}, opts);\n\t\n\t    if (typeof fun === 'function') {\n\t      fun = {map : fun};\n\t    }\n\t\n\t    var promise = Promise.resolve().then(function () {\n\t      return queryPromised(db, fun, opts);\n\t    });\n\t    utils.promisedCallback(promise, callback);\n\t    return promise;\n\t  };\n\t\n\t  var viewCleanup = utils.callbackify(function () {\n\t    var db = this;\n\t    return localViewCleanup(db);\n\t  });\n\t\n\t  return {\n\t    query: query,\n\t    viewCleanup: viewCleanup\n\t  };\n\t}\n\t\n\tmodule.exports = createIndexer;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 6)))\n\n/***/ },\n/* 50 */\n/*!************************************************************!*\\\n  !*** ./~/pouchdb-find/lib/abstract-mapreduce/taskqueue.js ***!\n  \\************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/*\n\t * Simple task queue to sequentialize actions. Assumes callbacks will eventually fire (once).\n\t */\n\t\n\tvar Promise = __webpack_require__(/*! ./utils */ 9).Promise;\n\t\n\tfunction TaskQueue() {\n\t  this.promise = new Promise(function (fulfill) {fulfill(); });\n\t}\n\tTaskQueue.prototype.add = function (promiseFactory) {\n\t  this.promise = this.promise.catch(function () {\n\t    // just recover\n\t  }).then(function () {\n\t    return promiseFactory();\n\t  });\n\t  return this.promise;\n\t};\n\tTaskQueue.prototype.finish = function () {\n\t  return this.promise;\n\t};\n\t\n\tmodule.exports = TaskQueue;\n\n\n/***/ },\n/* 51 */\n/*!***************************************************!*\\\n  !*** ./~/pouchdb-find/lib/adapters/http/index.js ***!\n  \\***************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar massageCreateIndexRequest = __webpack_require__(/*! ../../massageCreateIndexRequest */ 14);\n\t\n\tfunction createIndex(db, requestDef, callback) {\n\t  requestDef = massageCreateIndexRequest(requestDef);\n\t\n\t  db.request({\n\t    method: 'POST',\n\t    url: '_index',\n\t    body: requestDef\n\t  }, callback);\n\t}\n\t\n\tfunction find(db, requestDef, callback) {\n\t  db.request({\n\t    method: 'POST',\n\t    url: '_find',\n\t    body: requestDef\n\t  }, callback);\n\t}\n\t\n\tfunction getIndexes(db, callback) {\n\t  db.request({\n\t    method: 'GET',\n\t    url: '_index'\n\t  }, callback);\n\t}\n\t\n\tfunction deleteIndex(db, indexDef, callback) {\n\t\n\t\n\t  var ddoc = indexDef.ddoc;\n\t  var type = indexDef.type || 'json';\n\t  var name = indexDef.name;\n\t\n\t  if (!ddoc) {\n\t    return callback(new Error('you must provide an index\\'s ddoc'));\n\t  }\n\t\n\t  if (!name) {\n\t    return callback(new Error('you must provide an index\\'s name'));\n\t  }\n\t\n\t  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\t\n\t  db.request({\n\t    method: 'DELETE',\n\t    url: url\n\t  }, callback);\n\t}\n\t\n\texports.createIndex = createIndex;\n\texports.find = find;\n\texports.getIndexes = getIndexes;\n\texports.deleteIndex = deleteIndex;\n\n/***/ },\n/* 52 */\n/*!*****************************************************************!*\\\n  !*** ./~/pouchdb-find/lib/adapters/local/create-index/index.js ***!\n  \\*****************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(/*! ../../../utils */ 3);\n\tvar log = utils.log;\n\t\n\tvar pouchUpsert = __webpack_require__(/*! pouchdb-upsert */ 18);\n\tvar abstractMapper = __webpack_require__(/*! ../abstract-mapper */ 10);\n\tvar localUtils = __webpack_require__(/*! ../utils */ 5);\n\tvar validateIndex = localUtils.validateIndex;\n\tvar massageIndexDef = localUtils.massageIndexDef;\n\tvar massageCreateIndexRequest = __webpack_require__(/*! ../../../massageCreateIndexRequest */ 14);\n\t\n\tfunction upsert(db, docId, diffFun) {\n\t  return pouchUpsert.upsert.call(db, docId, diffFun);\n\t}\n\t\n\tfunction createIndex(db, requestDef) {\n\t  requestDef = massageCreateIndexRequest(requestDef);\n\t  var originalIndexDef = utils.clone(requestDef.index);\n\t  requestDef.index = massageIndexDef(requestDef.index);\n\t\n\t  validateIndex(requestDef.index);\n\t\n\t  var md5 = utils.MD5(JSON.stringify(requestDef));\n\t\n\t  var viewName = requestDef.name || ('idx-' + md5);\n\t\n\t  var ddocName = requestDef.ddoc || ('idx-' + md5);\n\t  var ddocId = '_design/' + ddocName;\n\t\n\t  var hasInvalidLanguage = false;\n\t  var viewExists = false;\n\t\n\t  function updateDdoc(doc) {\n\t    if (doc._rev && doc.language !== 'query') {\n\t      hasInvalidLanguage = true;\n\t    }\n\t    doc.language = 'query';\n\t    doc.views = doc.views || {};\n\t\n\t    viewExists = !!doc.views[viewName];\n\t\n\t    doc.views[viewName] = {\n\t      map: {\n\t        fields: utils.mergeObjects(requestDef.index.fields)\n\t      },\n\t      reduce: '_count',\n\t      options: {\n\t        def: originalIndexDef\n\t      }\n\t    };\n\t\n\t    return doc;\n\t  }\n\t\n\t  log('creating index', ddocId);\n\t\n\t  return upsert(db, ddocId, updateDdoc).then(function () {\n\t    if (hasInvalidLanguage) {\n\t      throw new Error('invalid language for ddoc with id \"' +\n\t      ddocId +\n\t      '\" (should be \"query\")');\n\t    }\n\t  }).then(function () {\n\t    // kick off a build\n\t    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n\t    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n\t    var signature = ddocName + '/' + viewName;\n\t    return abstractMapper.query.call(db, signature, {\n\t      limit: 0,\n\t      reduce: false\n\t    }).then(function () {\n\t      return {\n\t        id: ddocId,\n\t        name: viewName,\n\t        result: viewExists ? 'exists' : 'created'\n\t      };\n\t    });\n\t  });\n\t}\n\t\n\tmodule.exports = createIndex;\n\n\n/***/ },\n/* 53 */\n/*!*****************************************************************!*\\\n  !*** ./~/pouchdb-find/lib/adapters/local/delete-index/index.js ***!\n  \\*****************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar abstractMapper = __webpack_require__(/*! ../abstract-mapper */ 10);\n\tvar upsert = __webpack_require__(/*! ../../../abstract-mapreduce/upsert */ 11);\n\t\n\tfunction deleteIndex(db, index) {\n\t\n\t  if (!index.ddoc) {\n\t    throw new Error('you must supply an index.ddoc when deleting');\n\t  }\n\t\n\t  if (!index.name) {\n\t    throw new Error('you must supply an index.name when deleting');\n\t  }\n\t\n\t  var docId = index.ddoc;\n\t  var viewName = index.name;\n\t\n\t  function deltaFun (doc) {\n\t    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n\t      // only one view in this ddoc, delete the whole ddoc\n\t      return {_id: docId, _deleted: true};\n\t    }\n\t    // more than one view here, just remove the view\n\t    delete doc.views[viewName];\n\t    return doc;\n\t  }\n\t\n\t  return upsert(db, docId, deltaFun).then(function () {\n\t    return abstractMapper.viewCleanup.apply(db);\n\t  }).then(function () {\n\t    return {ok: true};\n\t  });\n\t}\n\t\n\tmodule.exports = deleteIndex;\n\n/***/ },\n/* 54 */\n/*!********************************************************************!*\\\n  !*** ./~/pouchdb-find/lib/adapters/local/find/in-memory-filter.js ***!\n  \\********************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t//\n\t// Do an in-memory filtering of rows that aren't covered by the index.\n\t// E.g. if the user is asking for foo=1 and bar=2, but the index\n\t// only covers \"foo\", then this in-memory filter would take care of\n\t// \"bar\".\n\t//\n\t\n\tvar isArray = __webpack_require__(/*! is-array */ 62);\n\tvar collate = __webpack_require__(/*! pouchdb-collate */ 7).collate;\n\tvar localUtils = __webpack_require__(/*! ../utils */ 5);\n\tvar isCombinationalField = localUtils.isCombinationalField;\n\tvar getKey = localUtils.getKey;\n\tvar getValue = localUtils.getValue;\n\tvar parseField = localUtils.parseField;\n\tvar utils = __webpack_require__(/*! ../../../utils */ 3);\n\tvar getFieldFromDoc = utils.getFieldFromDoc;\n\t\n\t// create a comparator based on the sort object\n\tfunction createFieldSorter(sort) {\n\t\n\t  function getFieldValuesAsArray(doc) {\n\t    return sort.map(function (sorting) {\n\t      var fieldName = getKey(sorting);\n\t      var parsedField = parseField(fieldName);\n\t      var docFieldValue = getFieldFromDoc(doc, parsedField);\n\t      return docFieldValue;\n\t    });\n\t  }\n\t\n\t  return function (aRow, bRow) {\n\t    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n\t    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n\t    var collation = collate(aFieldValues, bFieldValues);\n\t    if (collation !== 0) {\n\t      return collation;\n\t    }\n\t    // this is what mango seems to do\n\t    return utils.compare(aRow.doc._id, bRow.doc._id);\n\t  };\n\t}\n\t\n\tfunction filterInMemoryFields (rows, requestDef, inMemoryFields) {\n\t  rows = rows.filter(function (row) {\n\t    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n\t  });\n\t\n\t  if (requestDef.sort) {\n\t    // in-memory sort\n\t    var fieldSorter = createFieldSorter(requestDef.sort);\n\t    rows = rows.sort(fieldSorter);\n\t    if (typeof requestDef.sort[0] !== 'string' &&\n\t        getValue(requestDef.sort[0]) === 'desc') {\n\t      rows = rows.reverse();\n\t    }\n\t  }\n\t\n\t  if ('limit' in requestDef || 'skip' in requestDef) {\n\t    // have to do the limit in-memory\n\t    var skip = requestDef.skip || 0;\n\t    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n\t    rows = rows.slice(skip, limit);\n\t  }\n\t  return rows;\n\t}\n\t\n\tfunction rowFilter (doc, selector, inMemoryFields) {\n\t  return inMemoryFields.every(function (field) {\n\t    var matcher = selector[field];\n\t    var parsedField = parseField(field);\n\t    var docFieldValue = getFieldFromDoc(doc, parsedField);\n\t    if (isCombinationalField(field)) {\n\t      return matchCominationalSelector(field, matcher, doc);\n\t    }\n\t\n\t    return matchSelector(matcher, doc, parsedField, docFieldValue);\n\t  });\n\t}\n\t\n\tfunction matchSelector (matcher, doc, parsedField, docFieldValue) {\n\t  if (!matcher) {\n\t    // no filtering necessary; this field is just needed for sorting\n\t    return true;\n\t  }\n\t\n\t  return Object.keys(matcher).every(function (userOperator) {\n\t    var userValue = matcher[userOperator];\n\t    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n\t  });\n\t}\n\t\n\tfunction matchCominationalSelector (field, matcher, doc) {\n\t\n\t  if (field === '$or') {\n\t    return matcher.some(function (orMatchers) {\n\t      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n\t    });\n\t  }\n\t\n\t  if (field === '$not') {\n\t    return !rowFilter(doc, matcher, Object.keys(matcher));\n\t  }\n\t\n\t  //`$nor`\n\t  return !matcher.find(function (orMatchers) {\n\t    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n\t  });\n\t\n\t}\n\t\n\tfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n\t  if (!matchers[userOperator]) {\n\t    throw new Error('unknown operator \"' + userOperator +\n\t      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n\t      '$nin, $size, $mod, $regex, $elemMatch, $type or $all');\n\t  }\n\t  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n\t}\n\t\n\tfunction fieldExists(docFieldValue) {\n\t  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n\t}\n\t\n\tfunction fieldIsNotUndefined(docFieldValue) {\n\t  return typeof docFieldValue !== 'undefined';\n\t}\n\t\n\tfunction modField (docFieldValue, userValue) {\n\t  var divisor = userValue[0];\n\t  var mod = userValue[1];\n\t  if (divisor === 0) {\n\t    throw new Error('Bad divisor, cannot divide by zero');\n\t  }\n\t\n\t  if (parseInt(divisor, 10) !== divisor ) {\n\t    throw new Error('Divisor is not an integer');\n\t  }\n\t\n\t  if (parseInt(mod, 10) !== mod ) {\n\t    throw new Error('Modulus is not an integer');\n\t  }\n\t\n\t  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n\t    return false;\n\t  }\n\t\n\t  return docFieldValue % divisor === mod;\n\t}\n\t\n\tfunction arrayContainsValue (docFieldValue, userValue) {\n\t  return userValue.some(function (val) {\n\t    if (docFieldValue instanceof Array) {\n\t      return docFieldValue.indexOf(val) > -1;\n\t    }\n\t\n\t    return docFieldValue === val;\n\t  });\n\t}\n\t\n\tfunction arrayContainsAllValues (docFieldValue, userValue) {\n\t  return userValue.every(function (val) {\n\t    return docFieldValue.indexOf(val) > -1;\n\t  });\n\t}\n\t\n\tfunction arraySize (docFieldValue, userValue) {\n\t  return docFieldValue.length === userValue;\n\t}\n\t\n\tfunction regexMatch(docFieldValue, userValue) {\n\t  var re = new RegExp(userValue);\n\t\n\t  return re.test(docFieldValue);\n\t}\n\t\n\tfunction typeMatch(docFieldValue, userValue) {\n\t\n\t  switch (userValue) {\n\t    case 'null':\n\t      return docFieldValue === null;\n\t    case 'boolean':\n\t      return typeof(docFieldValue) === 'boolean';\n\t    case 'number':\n\t      return typeof(docFieldValue) === 'number';\n\t    case 'string':\n\t      return typeof(docFieldValue) === 'string';\n\t    case 'array':\n\t      return docFieldValue instanceof Array;\n\t    case 'object':\n\t      return ({}).toString.call(docFieldValue) === '[object Object]';\n\t  }\n\t\n\t  throw new Error(userValue + ' not supported as a type.' +\n\t                  'Please use one of object, string, array, number, boolean or null.');\n\t\n\t}\n\t\n\tvar matchers = {\n\t\n\t  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n\t    if (!isArray(docFieldValue)) {\n\t      return false;\n\t    }\n\t\n\t    if (docFieldValue.length === 0) {\n\t      return false;\n\t    }\n\t\n\t    if (typeof docFieldValue[0] === 'object') {\n\t      return docFieldValue.some(function (val) {\n\t        return rowFilter(val, userValue, Object.keys(userValue));\n\t      });\n\t    }\n\t\n\t    return docFieldValue.some(function (val) {\n\t      return matchSelector(userValue, doc, parsedField, val);\n\t    });\n\t  },\n\t\n\t  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n\t  },\n\t\n\t  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n\t  },\n\t\n\t  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n\t  },\n\t\n\t  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n\t  },\n\t\n\t  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n\t  },\n\t\n\t  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n\t    //a field that is null is still considered to exist\n\t    if (userValue) {\n\t      return fieldIsNotUndefined(docFieldValue);\n\t    }\n\t\n\t    return !fieldIsNotUndefined(docFieldValue);\n\t  },\n\t\n\t  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n\t  },\n\t\n\t  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n\t    return userValue.every(function (neValue) {\n\t      return collate(docFieldValue, neValue) !== 0;\n\t    });\n\t  },\n\t  '$in': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n\t  },\n\t\n\t  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n\t  },\n\t\n\t  '$size': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n\t  },\n\t\n\t  '$all': function (doc, userValue, parsedField, docFieldValue) {\n\t    return isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n\t  },\n\t\n\t  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n\t  },\n\t\n\t  '$type': function (doc, userValue, parsedField, docFieldValue) {\n\t    return typeMatch(docFieldValue, userValue);\n\t  }\n\t};\n\t\n\tmodule.exports = filterInMemoryFields;\n\n\n/***/ },\n/* 55 */\n/*!*********************************************************!*\\\n  !*** ./~/pouchdb-find/lib/adapters/local/find/index.js ***!\n  \\*********************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(/*! ../../../utils */ 3);\n\tvar clone = utils.clone;\n\tvar getIndexes = __webpack_require__(/*! ../get-indexes */ 12);\n\tvar collate = __webpack_require__(/*! pouchdb-collate */ 7).collate;\n\tvar abstractMapper = __webpack_require__(/*! ../abstract-mapper */ 10);\n\tvar planQuery = __webpack_require__(/*! ./query-planner */ 56);\n\tvar localUtils = __webpack_require__(/*! ../utils */ 5);\n\tvar filterInMemoryFields = __webpack_require__(/*! ./in-memory-filter */ 54);\n\tvar massageSelector = localUtils.massageSelector;\n\tvar massageSort = localUtils.massageSort;\n\tvar getValue = localUtils.getValue;\n\tvar validateFindRequest = localUtils.validateFindRequest;\n\tvar validateSort = localUtils.validateSort;\n\tvar reverseOptions = localUtils.reverseOptions;\n\tvar filterInclusiveStart = localUtils.filterInclusiveStart;\n\tvar Promise = utils.Promise;\n\t\n\tfunction indexToSignature(index) {\n\t  // remove '_design/'\n\t  return index.ddoc.substring(8) + '/' + index.name;\n\t}\n\t\n\tfunction doAllDocs(db, originalOpts) {\n\t  var opts = clone(originalOpts);\n\t\n\t  // CouchDB responds in weird ways when you provide a non-string to _id;\n\t  // we mimic the behavior for consistency. See issue66 tests for details.\n\t\n\t  if (opts.descending) {\n\t    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n\t      opts.endkey = '';\n\t    }\n\t    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n\t      opts.limit = 0;\n\t    }\n\t  } else {\n\t    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n\t      opts.startkey = '';\n\t    }\n\t    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n\t      opts.limit = 0;\n\t    }\n\t  }\n\t  if ('key' in opts && typeof opts.key !== 'string') {\n\t    opts.limit = 0;\n\t  }\n\t\n\t  return db.allDocs(opts);\n\t}\n\t\n\tfunction find(db, requestDef) {\n\t\n\t  if (requestDef.selector) {\n\t    requestDef.selector = massageSelector(requestDef.selector);\n\t  }\n\t  if (requestDef.sort) {\n\t    requestDef.sort = massageSort(requestDef.sort);\n\t  }\n\t\n\t  validateFindRequest(requestDef);\n\t\n\t  return getIndexes(db).then(function (getIndexesRes) {\n\t\n\t    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n\t\n\t    var indexToUse = queryPlan.index;\n\t\n\t    validateSort(requestDef, indexToUse);\n\t\n\t    var opts = utils.extend(true, {\n\t      include_docs: true,\n\t      reduce: false\n\t    }, queryPlan.queryOpts);\n\t\n\t    if ('startkey' in opts && 'endkey' in opts &&\n\t        collate(opts.startkey, opts.endkey) > 0) {\n\t      // can't possibly return any results, startkey > endkey\n\t      return {docs: []};\n\t    }\n\t\n\t    var isDescending = requestDef.sort &&\n\t      typeof requestDef.sort[0] !== 'string' &&\n\t      getValue(requestDef.sort[0]) === 'desc';\n\t\n\t    if (isDescending) {\n\t      // either all descending or all ascending\n\t      opts.descending = true;\n\t      opts = reverseOptions(opts);\n\t    }\n\t\n\t    if (!queryPlan.inMemoryFields.length) {\n\t      // no in-memory filtering necessary, so we can let the\n\t      // database do the limit/skip for us\n\t      if ('limit' in requestDef) {\n\t        opts.limit = requestDef.limit;\n\t      }\n\t      if ('skip' in requestDef) {\n\t        opts.skip = requestDef.skip;\n\t      }\n\t    }\n\t\n\t    return Promise.resolve().then(function () {\n\t      if (indexToUse.name === '_all_docs') {\n\t        return doAllDocs(db, opts);\n\t      } else {\n\t        var signature = indexToSignature(indexToUse);\n\t        return abstractMapper.query.call(db, signature, opts);\n\t      }\n\t    }).then(function (res) {\n\t\n\t      if (opts.inclusive_start === false) {\n\t        // may have to manually filter the first one,\n\t        // since couchdb has no true inclusive_start option\n\t        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n\t      }\n\t\n\t      if (queryPlan.inMemoryFields.length) {\n\t        // need to filter some stuff in-memory\n\t        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n\t      }\n\t\n\t      var resp = {\n\t        docs: res.rows.map(function (row) {\n\t          var doc = row.doc;\n\t          if (requestDef.fields) {\n\t            return utils.pick(doc, requestDef.fields);\n\t          }\n\t          return doc;\n\t        })\n\t      };\n\t\n\t      if (indexToUse.defaultUsed) {\n\t        resp.warning = 'no matching index found, create an index to optimize query time';\n\t      }\n\t\n\t      return resp;\n\t    });\n\t  });\n\t}\n\t\n\tmodule.exports = find;\n\n\n/***/ },\n/* 56 */\n/*!*****************************************************************!*\\\n  !*** ./~/pouchdb-find/lib/adapters/local/find/query-planner.js ***!\n  \\*****************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(/*! ../../../utils */ 3);\n\tvar log = utils.log;\n\tvar localUtils = __webpack_require__(/*! ../utils */ 5);\n\tvar getKey = localUtils.getKey;\n\tvar getValue = localUtils.getValue;\n\tvar getUserFields = localUtils.getUserFields;\n\t\n\t// couchdb lowest collation value\n\tvar COLLATE_LO = null;\n\t\n\t// couchdb highest collation value (TODO: well not really, but close enough amirite)\n\tvar COLLATE_HI = {\"\\uffff\": {}};\n\t\n\t// couchdb second-lowest collation value\n\t\n\tfunction checkFieldInIndex(index, field) {\n\t  var indexFields = index.def.fields.map(getKey);\n\t  for (var i = 0, len = indexFields.length; i < len; i++) {\n\t    var indexField = indexFields[i];\n\t    if (field === indexField) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n\t// but when you do e.g. $gt/$eq, the first part can be done\n\t// in the database, but the second part has to be done in-memory,\n\t// because $gt has forced us to lose precision.\n\t// so that's what this determines\n\tfunction userOperatorLosesPrecision(selector, field) {\n\t  var matcher = selector[field];\n\t  var userOperator = getKey(matcher);\n\t\n\t  return userOperator !== '$eq';\n\t}\n\t\n\t// sort the user fields by their position in the index,\n\t// if they're in the index\n\tfunction sortFieldsByIndex(userFields, index) {\n\t  var indexFields = index.def.fields.map(getKey);\n\t\n\t  return userFields.slice().sort(function (a, b) {\n\t    var aIdx = indexFields.indexOf(a);\n\t    var bIdx = indexFields.indexOf(b);\n\t    if (aIdx === -1) {\n\t      aIdx = Number.MAX_VALUE;\n\t    }\n\t    if (bIdx === -1) {\n\t      bIdx = Number.MAX_VALUE;\n\t    }\n\t    return utils.compare(aIdx, bIdx);\n\t  });\n\t}\n\t\n\t// first pass to try to find fields that will need to be sorted in-memory\n\tfunction getBasicInMemoryFields(index, selector, userFields) {\n\t\n\t  userFields = sortFieldsByIndex(userFields, index);\n\t\n\t  // check if any of the user selectors lose precision\n\t  var needToFilterInMemory = false;\n\t  for (var i = 0, len = userFields.length; i < len; i++) {\n\t    var field = userFields[i];\n\t    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n\t      return userFields.slice(i);\n\t    }\n\t    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n\t      needToFilterInMemory = true;\n\t    }\n\t  }\n\t  return [];\n\t}\n\t\n\tfunction getInMemoryFieldsFromNe(selector) {\n\t  var fields = [];\n\t  Object.keys(selector).forEach(function (field) {\n\t    var matcher = selector[field];\n\t    Object.keys(matcher).forEach(function (operator) {\n\t      if (operator === '$ne') {\n\t        fields.push(field);\n\t      }\n\t    });\n\t  });\n\t  return fields;\n\t}\n\t\n\tfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n\t  var result = utils.flatten(\n\t    // in-memory fields reported as necessary by the query planner\n\t    coreInMemoryFields,\n\t    // combine with another pass that checks for any we may have missed\n\t    getBasicInMemoryFields(index, selector, userFields),\n\t    // combine with another pass that checks for $ne's\n\t    getInMemoryFieldsFromNe(selector)\n\t  );\n\t\n\t  return sortFieldsByIndex(utils.uniq(result), index);\n\t}\n\t\n\t// check that at least one field in the user's query is represented\n\t// in the index. order matters in the case of sorts\n\tfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n\t  if (sortOrder) {\n\t    // array has to be a strict subarray of index array. furthermore,\n\t    // the sortOrder fields need to all be represented in the index\n\t    var sortMatches = utils.oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n\t    var selectorMatches = utils.oneArrayIsSubArrayOfOther(fields, indexFields);\n\t\n\t    return sortMatches && selectorMatches;\n\t  }\n\t\n\t  // all of the user's specified fields still need to be\n\t  // on the left side of the index array, although the order\n\t  // doesn't matter\n\t  return utils.oneSetIsSubArrayOfOther(fields, indexFields);\n\t}\n\t\n\tvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\n\tfunction isNonLogicalMatcher (matcher) {\n\t  return logicalMatchers.indexOf(matcher) === -1;\n\t}\n\t\n\t// check all the index fields for usages of '$ne'\n\t// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n\t// then we can neither use an index on ['foo'] nor an index on\n\t// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\n\tfunction checkFieldsLogicallySound(indexFields, selector) {\n\t  var firstField = indexFields[0];\n\t  var matcher = selector[firstField];\n\t\n\t  var hasLogicalOperator = Object.keys(matcher).some(function (matcherKey) {\n\t    return !(isNonLogicalMatcher(matcherKey));\n\t  });\n\t\n\t  if (!hasLogicalOperator) {\n\t    return false;\n\t  }\n\t\n\t  var isInvalidNe = Object.keys(matcher).length === 1 &&\n\t    getKey(matcher) === '$ne';\n\t\n\t  return !isInvalidNe;\n\t}\n\t\n\tfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\t\n\t  var indexFields = index.def.fields.map(getKey);\n\t\n\t  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\t\n\t  if (!fieldsMatch) {\n\t    return false;\n\t  }\n\t\n\t  return checkFieldsLogicallySound(indexFields, selector);\n\t}\n\t\n\t//\n\t// the algorithm is very simple:\n\t// take all the fields the user supplies, and if those fields\n\t// are a strict subset of the fields in some index,\n\t// then use that index\n\t//\n\t//\n\tfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n\t\n\t  return indexes.reduce(function (res, index) {\n\t    var indexMatches = checkIndexMatches(index, sortOrder, userFields, selector);\n\t    if (indexMatches) {\n\t      res.push(index);\n\t    }\n\t    return res;\n\t  }, []);\n\t}\n\t\n\t// find the best index, i.e. the one that matches the most fields\n\t// in the user's query\n\tfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes) {\n\t\n\t  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\t\n\t  if (matchingIndexes.length === 0) {\n\t    //return `all_docs` as a default index;\n\t    //I'm assuming that _all_docs is always first\n\t    var defaultIndex = indexes[0];\n\t    defaultIndex.defaultUsed = true;\n\t    return defaultIndex;\n\t  }\n\t  if (matchingIndexes.length === 1) {\n\t    return matchingIndexes[0];\n\t  }\n\t\n\t  var userFieldsMap = utils.arrayToObject(userFields);\n\t\n\t  function scoreIndex(index) {\n\t    var indexFields = index.def.fields.map(getKey);\n\t    var score = 0;\n\t    for (var i = 0, len = indexFields.length; i < len; i++) {\n\t      var indexField = indexFields[i];\n\t      if (userFieldsMap[indexField]) {\n\t        score++;\n\t      }\n\t    }\n\t    return score;\n\t  }\n\t\n\t  return utils.max(matchingIndexes, scoreIndex);\n\t}\n\t\n\tfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n\t  switch (userOperator) {\n\t    case '$eq':\n\t      return {key: userValue};\n\t    case '$lte':\n\t      return {endkey: userValue};\n\t    case '$gte':\n\t      return {startkey: userValue};\n\t    case '$lt':\n\t      return {\n\t        endkey: userValue,\n\t        inclusive_end: false\n\t      };\n\t    case '$gt':\n\t      return {\n\t        startkey: userValue,\n\t        inclusive_start: false\n\t      };\n\t  }\n\t}\n\t\n\tfunction getSingleFieldCoreQueryPlan(selector, index) {\n\t  var field = getKey(index.def.fields[0]);\n\t  var matcher = selector[field];\n\t  var inMemoryFields = [];\n\t\n\t  var userOperators = Object.keys(matcher);\n\t\n\t  var combinedOpts;\n\t\n\t  userOperators.forEach(function (userOperator) {\n\t\n\t    if (isNonLogicalMatcher(userOperator)) {\n\t      inMemoryFields.push(field);\n\t      return;\n\t    }\n\t\n\t    var userValue = matcher[userOperator];\n\t\n\t    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\t\n\t    if (combinedOpts) {\n\t      combinedOpts = utils.mergeObjects([combinedOpts, newQueryOpts]);\n\t    } else {\n\t      combinedOpts = newQueryOpts;\n\t    }\n\t  });\n\t\n\t  return {\n\t    queryOpts: combinedOpts,\n\t    inMemoryFields: inMemoryFields\n\t  };\n\t}\n\t\n\tfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n\t  switch (userOperator) {\n\t    case '$eq':\n\t      return {\n\t        startkey: userValue,\n\t        endkey: userValue\n\t      };\n\t    case '$lte':\n\t      return {\n\t        endkey: userValue\n\t      };\n\t    case '$gte':\n\t      return {\n\t        startkey: userValue\n\t      };\n\t    case '$lt':\n\t      return {\n\t        endkey: userValue,\n\t        inclusive_end: false\n\t      };\n\t    case '$gt':\n\t      return {\n\t        startkey: userValue,\n\t        inclusive_start: false\n\t      };\n\t  }\n\t}\n\t\n\tfunction getMultiFieldQueryOpts(selector, index) {\n\t\n\t  var indexFields = index.def.fields.map(getKey);\n\t\n\t  var inMemoryFields = [];\n\t  var startkey = [];\n\t  var endkey = [];\n\t  var inclusiveStart;\n\t  var inclusiveEnd;\n\t\n\t\n\t  function finish(i) {\n\t\n\t    if (inclusiveStart !== false) {\n\t      startkey.push(COLLATE_LO);\n\t    }\n\t    if (inclusiveEnd !== false) {\n\t      endkey.push(COLLATE_HI);\n\t    }\n\t    // keep track of the fields where we lost specificity,\n\t    // and therefore need to filter in-memory\n\t    inMemoryFields = indexFields.slice(i);\n\t  }\n\t\n\t  for (var i = 0, len = indexFields.length; i < len; i++) {\n\t    var indexField = indexFields[i];\n\t\n\t    var matcher = selector[indexField];\n\t\n\t    if (!matcher) { // fewer fields in user query than in index\n\t      finish(i);\n\t      break;\n\t    } else if (i > 0) {\n\t      if ('$ne' in matcher) { // unusable $ne index\n\t        finish(i);\n\t        break;\n\t      }\n\t      var usingGtlt = (\n\t        '$gt' in matcher || '$gte' in matcher ||\n\t        '$lt' in matcher || '$lte' in matcher);\n\t      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n\t      var previousWasEq = utils.arrayEquals(previousKeys, ['$eq']);\n\t      var previousWasSame = utils.arrayEquals(previousKeys, Object.keys(matcher));\n\t      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n\t      if (gtltLostSpecificity) {\n\t        finish(i);\n\t        break;\n\t      }\n\t    }\n\t\n\t    var userOperators = Object.keys(matcher);\n\t\n\t    var combinedOpts = null;\n\t\n\t    for (var j = 0; j < userOperators.length; j++) {\n\t      var userOperator = userOperators[j];\n\t      var userValue = matcher[userOperator];\n\t\n\t      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\t\n\t      if (combinedOpts) {\n\t        combinedOpts = utils.mergeObjects([combinedOpts, newOpts]);\n\t      } else {\n\t        combinedOpts = newOpts;\n\t      }\n\t    }\n\t\n\t    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n\t    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n\t    if ('inclusive_start' in combinedOpts) {\n\t      inclusiveStart = combinedOpts.inclusive_start;\n\t    }\n\t    if ('inclusive_end' in combinedOpts) {\n\t      inclusiveEnd = combinedOpts.inclusive_end;\n\t    }\n\t  }\n\t\n\t  var res = {\n\t    startkey: startkey,\n\t    endkey: endkey\n\t  };\n\t\n\t  if (typeof inclusiveStart !== 'undefined') {\n\t    res.inclusive_start = inclusiveStart;\n\t  }\n\t  if (typeof inclusiveEnd !== 'undefined') {\n\t    res.inclusive_end = inclusiveEnd;\n\t  }\n\t\n\t  return {\n\t    queryOpts: res,\n\t    inMemoryFields: inMemoryFields\n\t  };\n\t}\n\t\n\tfunction getDefaultQueryPlan () {\n\t  return {\n\t    queryOpts: {startkey: null},\n\t    //getInMemoryFields will do the work here later\n\t    inMemoryFields: []\n\t  };\n\t}\n\t\n\tfunction getCoreQueryPlan(selector, index) {\n\t  if (index.defaultUsed) {\n\t    return getDefaultQueryPlan(selector, index);\n\t  }\n\t\n\t  if (index.def.fields.length === 1) {\n\t    // one field in index, so the value was indexed as a singleton\n\t    return getSingleFieldCoreQueryPlan(selector, index);\n\t  }\n\t  // else index has multiple fields, so the value was indexed as an array\n\t  return getMultiFieldQueryOpts(selector, index);\n\t}\n\t\n\tfunction planQuery(request, indexes) {\n\t\n\t  log('planning query', request);\n\t\n\t  var selector = request.selector;\n\t  var sort = request.sort;\n\t\n\t  var userFieldsRes = getUserFields(selector, sort);\n\t\n\t  var userFields = userFieldsRes.fields;\n\t  var sortOrder = userFieldsRes.sortOrder;\n\t  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes);\n\t\n\t  var coreQueryPlan = getCoreQueryPlan(selector, index);\n\t  var queryOpts = coreQueryPlan.queryOpts;\n\t  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\t\n\t  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\t\n\t  var res = {\n\t    queryOpts: queryOpts,\n\t    index: index,\n\t    inMemoryFields: inMemoryFields\n\t  };\n\t  log('query plan', res);\n\t  return res;\n\t}\n\t\n\tmodule.exports = planQuery;\n\n\n/***/ },\n/* 57 */\n/*!****************************************************!*\\\n  !*** ./~/pouchdb-find/lib/adapters/local/index.js ***!\n  \\****************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(/*! ../../utils */ 3);\n\tvar callbackify = utils.callbackify;\n\t\n\texports.createIndex = callbackify(__webpack_require__(/*! ./create-index */ 52));\n\texports.find = callbackify(__webpack_require__(/*! ./find */ 55));\n\texports.getIndexes = callbackify(__webpack_require__(/*! ./get-indexes */ 12));\n\texports.deleteIndex = callbackify(__webpack_require__(/*! ./delete-index */ 53));\n\n/***/ },\n/* 58 */\n/*!*********************************************!*\\\n  !*** ./~/pouchdb-find/~/argsarray/index.js ***!\n  \\*********************************************/\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = argsArray;\n\t\n\tfunction argsArray(fun) {\n\t  return function () {\n\t    var len = arguments.length;\n\t    if (len) {\n\t      var args = [];\n\t      var i = -1;\n\t      while (++i < len) {\n\t        args[i] = arguments[i];\n\t      }\n\t      return fun.call(this, args);\n\t    } else {\n\t      return fun.call(this, []);\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 59 */\n/*!*******************************************!*\\\n  !*** ./~/pouchdb-find/~/debug/browser.js ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(/*! ./debug */ 60);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\texports.storage = 'undefined' != typeof chrome\n\t               && 'undefined' != typeof chrome.storage\n\t                  ? chrome.storage.local\n\t                  : localstorage();\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  'lightseagreen',\n\t  'forestgreen',\n\t  'goldenrod',\n\t  'dodgerblue',\n\t  'darkorchid',\n\t  'crimson'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  return ('WebkitAppearance' in document.documentElement.style) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (window.console && (console.firebug || (console.exception && console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  return JSON.stringify(v);\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs() {\n\t  var args = arguments;\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return args;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t  return args;\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      exports.storage.removeItem('debug');\n\t    } else {\n\t      exports.storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  var r;\n\t  try {\n\t    r = exports.storage.debug;\n\t  } catch(e) {}\n\t  return r;\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\t\n\t/**\n\t * Localstorage attempts to return the localstorage.\n\t *\n\t * This is necessary because safari throws\n\t * when a user disables cookies/localstorage\n\t * and you attempt to access it.\n\t *\n\t * @return {LocalStorage}\n\t * @api private\n\t */\n\t\n\tfunction localstorage(){\n\t  try {\n\t    return window.localStorage;\n\t  } catch (e) {}\n\t}\n\n\n/***/ },\n/* 60 */\n/*!*****************************************!*\\\n  !*** ./~/pouchdb-find/~/debug/debug.js ***!\n  \\*****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = debug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(/*! ms */ 61);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lowercased letter, i.e. \"n\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previously assigned color.\n\t */\n\t\n\tvar prevColor = 0;\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t *\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor() {\n\t  return exports.colors[prevColor++ % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction debug(namespace) {\n\t\n\t  // define the `disabled` version\n\t  function disabled() {\n\t  }\n\t  disabled.enabled = false;\n\t\n\t  // define the `enabled` version\n\t  function enabled() {\n\t\n\t    var self = enabled;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // add the `color` if not set\n\t    if (null == self.useColors) self.useColors = exports.useColors();\n\t    if (null == self.color && self.useColors) self.color = selectColor();\n\t\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %o\n\t      args = ['%o'].concat(args);\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    if ('function' === typeof exports.formatArgs) {\n\t      args = exports.formatArgs.apply(self, args);\n\t    }\n\t    var logFn = enabled.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t  enabled.enabled = true;\n\t\n\t  var fn = exports.enabled(namespace) ? enabled : disabled;\n\t\n\t  fn.namespace = namespace;\n\t\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  var split = (namespaces || '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 61 */\n/*!**********************************************!*\\\n  !*** ./~/pouchdb-find/~/debug/~/ms/index.js ***!\n  \\**********************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000;\n\tvar m = s * 60;\n\tvar h = m * 60;\n\tvar d = h * 24;\n\tvar y = d * 365.25;\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} options\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(val, options){\n\t  options = options || {};\n\t  if ('string' == typeof val) return parse(val);\n\t  return options.long\n\t    ? long(val)\n\t    : short(val);\n\t};\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  str = '' + str;\n\t  if (str.length > 10000) return;\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n\t  if (!match) return;\n\t  var n = parseFloat(match[1]);\n\t  var type = (match[2] || 'ms').toLowerCase();\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'yrs':\n\t    case 'yr':\n\t    case 'y':\n\t      return n * y;\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d;\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'hrs':\n\t    case 'hr':\n\t    case 'h':\n\t      return n * h;\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'mins':\n\t    case 'min':\n\t    case 'm':\n\t      return n * m;\n\t    case 'seconds':\n\t    case 'second':\n\t    case 'secs':\n\t    case 'sec':\n\t    case 's':\n\t      return n * s;\n\t    case 'milliseconds':\n\t    case 'millisecond':\n\t    case 'msecs':\n\t    case 'msec':\n\t    case 'ms':\n\t      return n;\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction short(ms) {\n\t  if (ms >= d) return Math.round(ms / d) + 'd';\n\t  if (ms >= h) return Math.round(ms / h) + 'h';\n\t  if (ms >= m) return Math.round(ms / m) + 'm';\n\t  if (ms >= s) return Math.round(ms / s) + 's';\n\t  return ms + 'ms';\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction long(ms) {\n\t  return plural(ms, d, 'day')\n\t    || plural(ms, h, 'hour')\n\t    || plural(ms, m, 'minute')\n\t    || plural(ms, s, 'second')\n\t    || ms + ' ms';\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) return;\n\t  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n\t  return Math.ceil(ms / n) + ' ' + name + 's';\n\t}\n\n\n/***/ },\n/* 62 */\n/*!********************************************!*\\\n  !*** ./~/pouchdb-find/~/is-array/index.js ***!\n  \\********************************************/\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * isArray\n\t */\n\t\n\tvar isArray = Array.isArray;\n\t\n\t/**\n\t * toString\n\t */\n\t\n\tvar str = Object.prototype.toString;\n\t\n\t/**\n\t * Whether or not the given `val`\n\t * is an array.\n\t *\n\t * example:\n\t *\n\t *        isArray([]);\n\t *        // > true\n\t *        isArray(arguments);\n\t *        // > false\n\t *        isArray('');\n\t *        // > false\n\t *\n\t * @param {mixed} val\n\t * @return {bool}\n\t */\n\t\n\tmodule.exports = isArray || function (val) {\n\t  return !! val && '[object Array]' == str.call(val);\n\t};\n\n\n/***/ },\n/* 63 */\n/*!*******************************************************!*\\\n  !*** ./~/pouchdb-find/~/pouchdb-collate/lib/utils.js ***!\n  \\*******************************************************/\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction pad(str, padWith, upToLength) {\n\t  var padding = '';\n\t  var targetLength = upToLength - str.length;\n\t  while (padding.length < targetLength) {\n\t    padding += padWith;\n\t  }\n\t  return padding;\n\t}\n\t\n\texports.padLeft = function (str, padWith, upToLength) {\n\t  var padding = pad(str, padWith, upToLength);\n\t  return padding + str;\n\t};\n\t\n\texports.padRight = function (str, padWith, upToLength) {\n\t  var padding = pad(str, padWith, upToLength);\n\t  return str + padding;\n\t};\n\t\n\texports.stringLexCompare = function (a, b) {\n\t\n\t  var aLen = a.length;\n\t  var bLen = b.length;\n\t\n\t  var i;\n\t  for (i = 0; i < aLen; i++) {\n\t    if (i === bLen) {\n\t      // b is shorter substring of a\n\t      return 1;\n\t    }\n\t    var aChar = a.charAt(i);\n\t    var bChar = b.charAt(i);\n\t    if (aChar !== bChar) {\n\t      return aChar < bChar ? -1 : 1;\n\t    }\n\t  }\n\t\n\t  if (aLen < bLen) {\n\t    // a is shorter substring of b\n\t    return -1;\n\t  }\n\t\n\t  return 0;\n\t};\n\t\n\t/*\n\t * returns the decimal form for the given integer, i.e. writes\n\t * out all the digits (in base-10) instead of using scientific notation\n\t */\n\texports.intToDecimalForm = function (int) {\n\t\n\t  var isNeg = int < 0;\n\t  var result = '';\n\t\n\t  do {\n\t    var remainder = isNeg ? -Math.ceil(int % 10) : Math.floor(int % 10);\n\t\n\t    result = remainder + result;\n\t    int = isNeg ? Math.ceil(int / 10) : Math.floor(int / 10);\n\t  } while (int);\n\t\n\t\n\t  if (isNeg && result !== '0') {\n\t    result = '-' + result;\n\t  }\n\t\n\t  return result;\n\t};\n\n/***/ },\n/* 64 */\n/*!*************************************************************!*\\\n  !*** ./~/pouchdb-find/~/pouchdb-promise/~/lie/lib/index.js ***!\n  \\*************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\tvar immediate = __webpack_require__(/*! immediate */ 65);\n\t\n\t/* istanbul ignore next */\n\tfunction INTERNAL() {}\n\t\n\tvar handlers = {};\n\t\n\tvar REJECTED = ['REJECTED'];\n\tvar FULFILLED = ['FULFILLED'];\n\tvar PENDING = ['PENDING'];\n\t/* istanbul ignore else */\n\tif (!process.browser) {\n\t  // in which we actually take advantage of JS scoping\n\t  var UNHANDLED = ['UNHANDLED'];\n\t}\n\t\n\tmodule.exports = Promise;\n\t\n\tfunction Promise(resolver) {\n\t  if (typeof resolver !== 'function') {\n\t    throw new TypeError('resolver must be a function');\n\t  }\n\t  this.state = PENDING;\n\t  this.queue = [];\n\t  this.outcome = void 0;\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    this.handled = UNHANDLED;\n\t  }\n\t  if (resolver !== INTERNAL) {\n\t    safelyResolveThenable(this, resolver);\n\t  }\n\t}\n\t\n\tPromise.prototype.catch = function (onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\tPromise.prototype.then = function (onFulfilled, onRejected) {\n\t  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n\t    typeof onRejected !== 'function' && this.state === REJECTED) {\n\t    return this;\n\t  }\n\t  var promise = new this.constructor(INTERNAL);\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    if (this.handled === UNHANDLED) {\n\t      this.handled = null;\n\t    }\n\t  }\n\t  if (this.state !== PENDING) {\n\t    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n\t    unwrap(promise, resolver, this.outcome);\n\t  } else {\n\t    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n\t  }\n\t\n\t  return promise;\n\t};\n\tfunction QueueItem(promise, onFulfilled, onRejected) {\n\t  this.promise = promise;\n\t  if (typeof onFulfilled === 'function') {\n\t    this.onFulfilled = onFulfilled;\n\t    this.callFulfilled = this.otherCallFulfilled;\n\t  }\n\t  if (typeof onRejected === 'function') {\n\t    this.onRejected = onRejected;\n\t    this.callRejected = this.otherCallRejected;\n\t  }\n\t}\n\tQueueItem.prototype.callFulfilled = function (value) {\n\t  handlers.resolve(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallFulfilled = function (value) {\n\t  unwrap(this.promise, this.onFulfilled, value);\n\t};\n\tQueueItem.prototype.callRejected = function (value) {\n\t  handlers.reject(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallRejected = function (value) {\n\t  unwrap(this.promise, this.onRejected, value);\n\t};\n\t\n\tfunction unwrap(promise, func, value) {\n\t  immediate(function () {\n\t    var returnValue;\n\t    try {\n\t      returnValue = func(value);\n\t    } catch (e) {\n\t      return handlers.reject(promise, e);\n\t    }\n\t    if (returnValue === promise) {\n\t      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n\t    } else {\n\t      handlers.resolve(promise, returnValue);\n\t    }\n\t  });\n\t}\n\t\n\thandlers.resolve = function (self, value) {\n\t  var result = tryCatch(getThen, value);\n\t  if (result.status === 'error') {\n\t    return handlers.reject(self, result.value);\n\t  }\n\t  var thenable = result.value;\n\t\n\t  if (thenable) {\n\t    safelyResolveThenable(self, thenable);\n\t  } else {\n\t    self.state = FULFILLED;\n\t    self.outcome = value;\n\t    var i = -1;\n\t    var len = self.queue.length;\n\t    while (++i < len) {\n\t      self.queue[i].callFulfilled(value);\n\t    }\n\t  }\n\t  return self;\n\t};\n\thandlers.reject = function (self, error) {\n\t  self.state = REJECTED;\n\t  self.outcome = error;\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    if (self.handled === UNHANDLED) {\n\t      immediate(function () {\n\t        if (self.handled === UNHANDLED) {\n\t          process.emit('unhandledRejection', error, self);\n\t        }\n\t      });\n\t    }\n\t  }\n\t  var i = -1;\n\t  var len = self.queue.length;\n\t  while (++i < len) {\n\t    self.queue[i].callRejected(error);\n\t  }\n\t  return self;\n\t};\n\t\n\tfunction getThen(obj) {\n\t  // Make sure we only access the accessor once as required by the spec\n\t  var then = obj && obj.then;\n\t  if (obj && typeof obj === 'object' && typeof then === 'function') {\n\t    return function appyThen() {\n\t      then.apply(obj, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction safelyResolveThenable(self, thenable) {\n\t  // Either fulfill, reject or reject with error\n\t  var called = false;\n\t  function onError(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.reject(self, value);\n\t  }\n\t\n\t  function onSuccess(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.resolve(self, value);\n\t  }\n\t\n\t  function tryToUnwrap() {\n\t    thenable(onSuccess, onError);\n\t  }\n\t\n\t  var result = tryCatch(tryToUnwrap);\n\t  if (result.status === 'error') {\n\t    onError(result.value);\n\t  }\n\t}\n\t\n\tfunction tryCatch(func, value) {\n\t  var out = {};\n\t  try {\n\t    out.value = func(value);\n\t    out.status = 'success';\n\t  } catch (e) {\n\t    out.status = 'error';\n\t    out.value = e;\n\t  }\n\t  return out;\n\t}\n\t\n\tPromise.resolve = resolve;\n\tfunction resolve(value) {\n\t  if (value instanceof this) {\n\t    return value;\n\t  }\n\t  return handlers.resolve(new this(INTERNAL), value);\n\t}\n\t\n\tPromise.reject = reject;\n\tfunction reject(reason) {\n\t  var promise = new this(INTERNAL);\n\t  return handlers.reject(promise, reason);\n\t}\n\t\n\tPromise.all = all;\n\tfunction all(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var values = new Array(len);\n\t  var resolved = 0;\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    allResolver(iterable[i], i);\n\t  }\n\t  return promise;\n\t  function allResolver(value, i) {\n\t    self.resolve(value).then(resolveFromAll, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t    function resolveFromAll(outValue) {\n\t      values[i] = outValue;\n\t      if (++resolved === len && !called) {\n\t        called = true;\n\t        handlers.resolve(promise, values);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tPromise.race = race;\n\tfunction race(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    resolver(iterable[i]);\n\t  }\n\t  return promise;\n\t  function resolver(value) {\n\t    self.resolve(value).then(function (response) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.resolve(promise, response);\n\t      }\n\t    }, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 6)))\n\n/***/ },\n/* 65 */\n/*!***************************************************************************!*\\\n  !*** ./~/pouchdb-find/~/pouchdb-promise/~/lie/~/immediate/lib/browser.js ***!\n  \\***************************************************************************/\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\tvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\t\n\tvar scheduleDrain;\n\t\n\t{\n\t  if (Mutation) {\n\t    var called = 0;\n\t    var observer = new Mutation(nextTick);\n\t    var element = global.document.createTextNode('');\n\t    observer.observe(element, {\n\t      characterData: true\n\t    });\n\t    scheduleDrain = function () {\n\t      element.data = (called = ++called % 2);\n\t    };\n\t  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n\t    var channel = new global.MessageChannel();\n\t    channel.port1.onmessage = nextTick;\n\t    scheduleDrain = function () {\n\t      channel.port2.postMessage(0);\n\t    };\n\t  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n\t    scheduleDrain = function () {\n\t\n\t      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t      var scriptEl = global.document.createElement('script');\n\t      scriptEl.onreadystatechange = function () {\n\t        nextTick();\n\t\n\t        scriptEl.onreadystatechange = null;\n\t        scriptEl.parentNode.removeChild(scriptEl);\n\t        scriptEl = null;\n\t      };\n\t      global.document.documentElement.appendChild(scriptEl);\n\t    };\n\t  } else {\n\t    scheduleDrain = function () {\n\t      setTimeout(nextTick, 0);\n\t    };\n\t  }\n\t}\n\t\n\tvar draining;\n\tvar queue = [];\n\t//named nextTick for less confusing stack traces\n\tfunction nextTick() {\n\t  draining = true;\n\t  var i, oldQueue;\n\t  var len = queue.length;\n\t  while (len) {\n\t    oldQueue = queue;\n\t    queue = [];\n\t    i = -1;\n\t    while (++i < len) {\n\t      oldQueue[i]();\n\t    }\n\t    len = queue.length;\n\t  }\n\t  draining = false;\n\t}\n\t\n\tmodule.exports = immediate;\n\tfunction immediate(task) {\n\t  if (queue.push(task) === 1 && !draining) {\n\t    scheduleDrain();\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 66 */\n/*!************************************************************************!*\\\n  !*** ./~/pouchdb-find/~/pouchdb-upsert/~/pouchdb-promise/lib/index.js ***!\n  \\************************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar lie = _interopDefault(__webpack_require__(/*! lie */ 67));\n\t\n\t/* istanbul ignore next */\n\tvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\t\n\tmodule.exports = PouchPromise;\n\n/***/ },\n/* 67 */\n/*!******************************************************************************!*\\\n  !*** ./~/pouchdb-find/~/pouchdb-upsert/~/pouchdb-promise/~/lie/lib/index.js ***!\n  \\******************************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\tvar immediate = __webpack_require__(/*! immediate */ 68);\n\t\n\t/* istanbul ignore next */\n\tfunction INTERNAL() {}\n\t\n\tvar handlers = {};\n\t\n\tvar REJECTED = ['REJECTED'];\n\tvar FULFILLED = ['FULFILLED'];\n\tvar PENDING = ['PENDING'];\n\t/* istanbul ignore else */\n\tif (!process.browser) {\n\t  // in which we actually take advantage of JS scoping\n\t  var UNHANDLED = ['UNHANDLED'];\n\t}\n\t\n\tmodule.exports = Promise;\n\t\n\tfunction Promise(resolver) {\n\t  if (typeof resolver !== 'function') {\n\t    throw new TypeError('resolver must be a function');\n\t  }\n\t  this.state = PENDING;\n\t  this.queue = [];\n\t  this.outcome = void 0;\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    this.handled = UNHANDLED;\n\t  }\n\t  if (resolver !== INTERNAL) {\n\t    safelyResolveThenable(this, resolver);\n\t  }\n\t}\n\t\n\tPromise.prototype.catch = function (onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\tPromise.prototype.then = function (onFulfilled, onRejected) {\n\t  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n\t    typeof onRejected !== 'function' && this.state === REJECTED) {\n\t    return this;\n\t  }\n\t  var promise = new this.constructor(INTERNAL);\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    if (this.handled === UNHANDLED) {\n\t      this.handled = null;\n\t    }\n\t  }\n\t  if (this.state !== PENDING) {\n\t    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n\t    unwrap(promise, resolver, this.outcome);\n\t  } else {\n\t    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n\t  }\n\t\n\t  return promise;\n\t};\n\tfunction QueueItem(promise, onFulfilled, onRejected) {\n\t  this.promise = promise;\n\t  if (typeof onFulfilled === 'function') {\n\t    this.onFulfilled = onFulfilled;\n\t    this.callFulfilled = this.otherCallFulfilled;\n\t  }\n\t  if (typeof onRejected === 'function') {\n\t    this.onRejected = onRejected;\n\t    this.callRejected = this.otherCallRejected;\n\t  }\n\t}\n\tQueueItem.prototype.callFulfilled = function (value) {\n\t  handlers.resolve(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallFulfilled = function (value) {\n\t  unwrap(this.promise, this.onFulfilled, value);\n\t};\n\tQueueItem.prototype.callRejected = function (value) {\n\t  handlers.reject(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallRejected = function (value) {\n\t  unwrap(this.promise, this.onRejected, value);\n\t};\n\t\n\tfunction unwrap(promise, func, value) {\n\t  immediate(function () {\n\t    var returnValue;\n\t    try {\n\t      returnValue = func(value);\n\t    } catch (e) {\n\t      return handlers.reject(promise, e);\n\t    }\n\t    if (returnValue === promise) {\n\t      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n\t    } else {\n\t      handlers.resolve(promise, returnValue);\n\t    }\n\t  });\n\t}\n\t\n\thandlers.resolve = function (self, value) {\n\t  var result = tryCatch(getThen, value);\n\t  if (result.status === 'error') {\n\t    return handlers.reject(self, result.value);\n\t  }\n\t  var thenable = result.value;\n\t\n\t  if (thenable) {\n\t    safelyResolveThenable(self, thenable);\n\t  } else {\n\t    self.state = FULFILLED;\n\t    self.outcome = value;\n\t    var i = -1;\n\t    var len = self.queue.length;\n\t    while (++i < len) {\n\t      self.queue[i].callFulfilled(value);\n\t    }\n\t  }\n\t  return self;\n\t};\n\thandlers.reject = function (self, error) {\n\t  self.state = REJECTED;\n\t  self.outcome = error;\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    if (self.handled === UNHANDLED) {\n\t      immediate(function () {\n\t        if (self.handled === UNHANDLED) {\n\t          process.emit('unhandledRejection', error, self);\n\t        }\n\t      });\n\t    }\n\t  }\n\t  var i = -1;\n\t  var len = self.queue.length;\n\t  while (++i < len) {\n\t    self.queue[i].callRejected(error);\n\t  }\n\t  return self;\n\t};\n\t\n\tfunction getThen(obj) {\n\t  // Make sure we only access the accessor once as required by the spec\n\t  var then = obj && obj.then;\n\t  if (obj && typeof obj === 'object' && typeof then === 'function') {\n\t    return function appyThen() {\n\t      then.apply(obj, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction safelyResolveThenable(self, thenable) {\n\t  // Either fulfill, reject or reject with error\n\t  var called = false;\n\t  function onError(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.reject(self, value);\n\t  }\n\t\n\t  function onSuccess(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.resolve(self, value);\n\t  }\n\t\n\t  function tryToUnwrap() {\n\t    thenable(onSuccess, onError);\n\t  }\n\t\n\t  var result = tryCatch(tryToUnwrap);\n\t  if (result.status === 'error') {\n\t    onError(result.value);\n\t  }\n\t}\n\t\n\tfunction tryCatch(func, value) {\n\t  var out = {};\n\t  try {\n\t    out.value = func(value);\n\t    out.status = 'success';\n\t  } catch (e) {\n\t    out.status = 'error';\n\t    out.value = e;\n\t  }\n\t  return out;\n\t}\n\t\n\tPromise.resolve = resolve;\n\tfunction resolve(value) {\n\t  if (value instanceof this) {\n\t    return value;\n\t  }\n\t  return handlers.resolve(new this(INTERNAL), value);\n\t}\n\t\n\tPromise.reject = reject;\n\tfunction reject(reason) {\n\t  var promise = new this(INTERNAL);\n\t  return handlers.reject(promise, reason);\n\t}\n\t\n\tPromise.all = all;\n\tfunction all(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var values = new Array(len);\n\t  var resolved = 0;\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    allResolver(iterable[i], i);\n\t  }\n\t  return promise;\n\t  function allResolver(value, i) {\n\t    self.resolve(value).then(resolveFromAll, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t    function resolveFromAll(outValue) {\n\t      values[i] = outValue;\n\t      if (++resolved === len && !called) {\n\t        called = true;\n\t        handlers.resolve(promise, values);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tPromise.race = race;\n\tfunction race(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    resolver(iterable[i]);\n\t  }\n\t  return promise;\n\t  function resolver(value) {\n\t    self.resolve(value).then(function (response) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.resolve(promise, response);\n\t      }\n\t    }, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 6)))\n\n/***/ },\n/* 68 */\n/*!********************************************************************************************!*\\\n  !*** ./~/pouchdb-find/~/pouchdb-upsert/~/pouchdb-promise/~/lie/~/immediate/lib/browser.js ***!\n  \\********************************************************************************************/\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\tvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\t\n\tvar scheduleDrain;\n\t\n\t{\n\t  if (Mutation) {\n\t    var called = 0;\n\t    var observer = new Mutation(nextTick);\n\t    var element = global.document.createTextNode('');\n\t    observer.observe(element, {\n\t      characterData: true\n\t    });\n\t    scheduleDrain = function () {\n\t      element.data = (called = ++called % 2);\n\t    };\n\t  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n\t    var channel = new global.MessageChannel();\n\t    channel.port1.onmessage = nextTick;\n\t    scheduleDrain = function () {\n\t      channel.port2.postMessage(0);\n\t    };\n\t  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n\t    scheduleDrain = function () {\n\t\n\t      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t      var scriptEl = global.document.createElement('script');\n\t      scriptEl.onreadystatechange = function () {\n\t        nextTick();\n\t\n\t        scriptEl.onreadystatechange = null;\n\t        scriptEl.parentNode.removeChild(scriptEl);\n\t        scriptEl = null;\n\t      };\n\t      global.document.documentElement.appendChild(scriptEl);\n\t    };\n\t  } else {\n\t    scheduleDrain = function () {\n\t      setTimeout(nextTick, 0);\n\t    };\n\t  }\n\t}\n\t\n\tvar draining;\n\tvar queue = [];\n\t//named nextTick for less confusing stack traces\n\tfunction nextTick() {\n\t  draining = true;\n\t  var i, oldQueue;\n\t  var len = queue.length;\n\t  while (len) {\n\t    oldQueue = queue;\n\t    queue = [];\n\t    i = -1;\n\t    while (++i < len) {\n\t      oldQueue[i]();\n\t    }\n\t    len = queue.length;\n\t  }\n\t  draining = false;\n\t}\n\t\n\tmodule.exports = immediate;\n\tfunction immediate(task) {\n\t  if (queue.push(task) === 1 && !draining) {\n\t    scheduleDrain();\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 69 */\n/*!****************************************!*\\\n  !*** ./~/pouchdb/~/argsarray/index.js ***!\n  \\****************************************/\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = argsArray;\n\t\n\tfunction argsArray(fun) {\n\t  return function () {\n\t    var len = arguments.length;\n\t    if (len) {\n\t      var args = [];\n\t      var i = -1;\n\t      while (++i < len) {\n\t        args[i] = arguments[i];\n\t      }\n\t      return fun.call(this, args);\n\t    } else {\n\t      return fun.call(this, []);\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 70 */\n/*!**************************************!*\\\n  !*** ./~/pouchdb/~/debug/browser.js ***!\n  \\**************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(/*! ./debug */ 71);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\texports.storage = 'undefined' != typeof chrome\n\t               && 'undefined' != typeof chrome.storage\n\t                  ? chrome.storage.local\n\t                  : localstorage();\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  'lightseagreen',\n\t  'forestgreen',\n\t  'goldenrod',\n\t  'dodgerblue',\n\t  'darkorchid',\n\t  'crimson'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  return ('WebkitAppearance' in document.documentElement.style) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (window.console && (console.firebug || (console.exception && console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  return JSON.stringify(v);\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs() {\n\t  var args = arguments;\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return args;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t  return args;\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      exports.storage.removeItem('debug');\n\t    } else {\n\t      exports.storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  var r;\n\t  try {\n\t    r = exports.storage.debug;\n\t  } catch(e) {}\n\t  return r;\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\t\n\t/**\n\t * Localstorage attempts to return the localstorage.\n\t *\n\t * This is necessary because safari throws\n\t * when a user disables cookies/localstorage\n\t * and you attempt to access it.\n\t *\n\t * @return {LocalStorage}\n\t * @api private\n\t */\n\t\n\tfunction localstorage(){\n\t  try {\n\t    return window.localStorage;\n\t  } catch (e) {}\n\t}\n\n\n/***/ },\n/* 71 */\n/*!************************************!*\\\n  !*** ./~/pouchdb/~/debug/debug.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = debug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(/*! ms */ 72);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lowercased letter, i.e. \"n\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previously assigned color.\n\t */\n\t\n\tvar prevColor = 0;\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t *\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor() {\n\t  return exports.colors[prevColor++ % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction debug(namespace) {\n\t\n\t  // define the `disabled` version\n\t  function disabled() {\n\t  }\n\t  disabled.enabled = false;\n\t\n\t  // define the `enabled` version\n\t  function enabled() {\n\t\n\t    var self = enabled;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // add the `color` if not set\n\t    if (null == self.useColors) self.useColors = exports.useColors();\n\t    if (null == self.color && self.useColors) self.color = selectColor();\n\t\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %o\n\t      args = ['%o'].concat(args);\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    if ('function' === typeof exports.formatArgs) {\n\t      args = exports.formatArgs.apply(self, args);\n\t    }\n\t    var logFn = enabled.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t  enabled.enabled = true;\n\t\n\t  var fn = exports.enabled(namespace) ? enabled : disabled;\n\t\n\t  fn.namespace = namespace;\n\t\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  var split = (namespaces || '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 72 */\n/*!*****************************************!*\\\n  !*** ./~/pouchdb/~/debug/~/ms/index.js ***!\n  \\*****************************************/\n/***/ function(module, exports) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000;\n\tvar m = s * 60;\n\tvar h = m * 60;\n\tvar d = h * 24;\n\tvar y = d * 365.25;\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} options\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(val, options){\n\t  options = options || {};\n\t  if ('string' == typeof val) return parse(val);\n\t  return options.long\n\t    ? long(val)\n\t    : short(val);\n\t};\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  str = '' + str;\n\t  if (str.length > 10000) return;\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n\t  if (!match) return;\n\t  var n = parseFloat(match[1]);\n\t  var type = (match[2] || 'ms').toLowerCase();\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'yrs':\n\t    case 'yr':\n\t    case 'y':\n\t      return n * y;\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d;\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'hrs':\n\t    case 'hr':\n\t    case 'h':\n\t      return n * h;\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'mins':\n\t    case 'min':\n\t    case 'm':\n\t      return n * m;\n\t    case 'seconds':\n\t    case 'second':\n\t    case 'secs':\n\t    case 'sec':\n\t    case 's':\n\t      return n * s;\n\t    case 'milliseconds':\n\t    case 'millisecond':\n\t    case 'msecs':\n\t    case 'msec':\n\t    case 'ms':\n\t      return n;\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction short(ms) {\n\t  if (ms >= d) return Math.round(ms / d) + 'd';\n\t  if (ms >= h) return Math.round(ms / h) + 'h';\n\t  if (ms >= m) return Math.round(ms / m) + 'm';\n\t  if (ms >= s) return Math.round(ms / s) + 's';\n\t  return ms + 'ms';\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction long(ms) {\n\t  return plural(ms, d, 'day')\n\t    || plural(ms, h, 'hour')\n\t    || plural(ms, m, 'minute')\n\t    || plural(ms, s, 'second')\n\t    || ms + ' ms';\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) return;\n\t  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n\t  return Math.ceil(ms / n) + ' ' + name + 's';\n\t}\n\n\n/***/ },\n/* 73 */\n/*!**********************************************************!*\\\n  !*** ./~/pouchdb/~/es6-promise-pool/es6-promise-pool.js ***!\n  \\**********************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\r\n\t  /* istanbul ignore next */\r\n\t  if (true) {\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\t  } else if (typeof exports === 'object') {\r\n\t    module.exports = factory()\r\n\t  } else {\r\n\t    root.PromisePool = factory()\r\n\t    // Legacy API\r\n\t    root.promisePool = root.PromisePool\r\n\t  }\r\n\t})(this, function () {\r\n\t  'use strict'\r\n\t\r\n\t  var EventTarget = function () {\r\n\t    this._listeners = {}\r\n\t  }\r\n\t\r\n\t  EventTarget.prototype.addEventListener = function (type, listener) {\r\n\t    this._listeners[type] = this._listeners[type] || []\r\n\t    if (this._listeners[type].indexOf(listener) < 0) {\r\n\t      this._listeners[type].push(listener)\r\n\t    }\r\n\t  }\r\n\t\r\n\t  EventTarget.prototype.removeEventListener = function (type, listener) {\r\n\t    if (this._listeners[type]) {\r\n\t      var p = this._listeners[type].indexOf(listener)\r\n\t      if (p >= 0) {\r\n\t        this._listeners[type].splice(p, 1)\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  EventTarget.prototype.dispatchEvent = function (evt) {\r\n\t    if (this._listeners[evt.type] && this._listeners[evt.type].length) {\r\n\t      var listeners = this._listeners[evt.type].slice()\r\n\t      for (var i = 0, l = listeners.length; i < l; ++i) {\r\n\t        listeners[i].call(this, evt)\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  var isGenerator = function (func) {\r\n\t    return (typeof func.constructor === 'function' &&\r\n\t      func.constructor.name === 'GeneratorFunction')\r\n\t  }\r\n\t\r\n\t  var functionToIterator = function (func) {\r\n\t    return {\r\n\t      next: function () {\r\n\t        var promise = func()\r\n\t        return promise ? {value: promise} : {done: true}\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  var promiseToIterator = function (promise) {\r\n\t    var called = false\r\n\t    return {\r\n\t      next: function () {\r\n\t        if (called) {\r\n\t          return {done: true}\r\n\t        }\r\n\t        called = true\r\n\t        return {value: promise}\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t  var toIterator = function (obj, Promise) {\r\n\t    var type = typeof obj\r\n\t    if (type === 'object') {\r\n\t      if (typeof obj.next === 'function') {\r\n\t        return obj\r\n\t      }\r\n\t      /* istanbul ignore else */\r\n\t      if (typeof obj.then === 'function') {\r\n\t        return promiseToIterator(obj)\r\n\t      }\r\n\t    }\r\n\t    if (type === 'function') {\r\n\t      return isGenerator(obj) ? obj() : functionToIterator(obj)\r\n\t    }\r\n\t    return promiseToIterator(Promise.resolve(obj))\r\n\t  }\r\n\t\r\n\t  var PromisePoolEvent = function (target, type, data) {\r\n\t    this.target = target\r\n\t    this.type = type\r\n\t    this.data = data\r\n\t  }\r\n\t\r\n\t  var PromisePool = function (source, concurrency, options) {\r\n\t    EventTarget.call(this)\r\n\t    if (typeof concurrency !== 'number' ||\r\n\t        Math.floor(concurrency) !== concurrency ||\r\n\t        concurrency < 1) {\r\n\t      throw new Error('Invalid concurrency')\r\n\t    }\r\n\t    this._concurrency = concurrency\r\n\t    this._options = options || {}\r\n\t    this._options.promise = this._options.promise || Promise\r\n\t    this._iterator = toIterator(source, this._options.promise)\r\n\t    this._done = false\r\n\t    this._size = 0\r\n\t    this._promise = null\r\n\t    this._callbacks = null\r\n\t  }\r\n\t  PromisePool.prototype = new EventTarget()\r\n\t  PromisePool.prototype.constructor = PromisePool\r\n\t\r\n\t  PromisePool.prototype.concurrency = function (value) {\r\n\t    if (typeof value !== 'undefined') {\r\n\t      this._concurrency = value\r\n\t      if (this.active()) {\r\n\t        this._proceed()\r\n\t      }\r\n\t    }\r\n\t    return this._concurrency\r\n\t  }\r\n\t\r\n\t  PromisePool.prototype.size = function () {\r\n\t    return this._size\r\n\t  }\r\n\t\r\n\t  PromisePool.prototype.active = function () {\r\n\t    return !!this._promise\r\n\t  }\r\n\t\r\n\t  PromisePool.prototype.promise = function () {\r\n\t    return this._promise\r\n\t  }\r\n\t\r\n\t  PromisePool.prototype.start = function () {\r\n\t    var that = this\r\n\t    var Promise = this._options.promise\r\n\t    this._promise = new Promise(function (resolve, reject) {\r\n\t      that._callbacks = {\r\n\t        reject: reject,\r\n\t        resolve: resolve\r\n\t      }\r\n\t      that._proceed()\r\n\t    })\r\n\t    return this._promise\r\n\t  }\r\n\t\r\n\t  PromisePool.prototype._fireEvent = function (type, data) {\r\n\t    this.dispatchEvent(new PromisePoolEvent(this, type, data))\r\n\t  }\r\n\t\r\n\t  PromisePool.prototype._settle = function (error) {\r\n\t    if (error) {\r\n\t      this._callbacks.reject(error)\r\n\t    } else {\r\n\t      this._callbacks.resolve()\r\n\t    }\r\n\t    this._promise = null\r\n\t    this._callbacks = null\r\n\t  }\r\n\t\r\n\t  PromisePool.prototype._onPooledPromiseFulfilled = function (promise, result) {\r\n\t    this._size--\r\n\t    if (this.active()) {\r\n\t      this._fireEvent('fulfilled', {\r\n\t        promise: promise,\r\n\t        result: result\r\n\t      })\r\n\t      this._proceed()\r\n\t    }\r\n\t  }\r\n\t\r\n\t  PromisePool.prototype._onPooledPromiseRejected = function (promise, error) {\r\n\t    this._size--\r\n\t    if (this.active()) {\r\n\t      this._fireEvent('rejected', {\r\n\t        promise: promise,\r\n\t        error: error\r\n\t      })\r\n\t      this._settle(error || new Error('Unknown error'))\r\n\t    }\r\n\t  }\r\n\t\r\n\t  PromisePool.prototype._trackPromise = function (promise) {\r\n\t    var that = this\r\n\t    promise\r\n\t      .then(function (result) {\r\n\t        that._onPooledPromiseFulfilled(promise, result)\r\n\t      }, function (error) {\r\n\t        that._onPooledPromiseRejected(promise, error)\r\n\t      })['catch'](function (err) {\r\n\t        that._settle(new Error('Promise processing failed: ' + err))\r\n\t      })\r\n\t  }\r\n\t\r\n\t  PromisePool.prototype._proceed = function () {\r\n\t    if (!this._done) {\r\n\t      var result = null\r\n\t      while (this._size < this._concurrency &&\r\n\t          !(result = this._iterator.next()).done) {\r\n\t        this._size++\r\n\t        this._trackPromise(result.value)\r\n\t      }\r\n\t      this._done = (result === null || !!result.done)\r\n\t    }\r\n\t    if (this._done && this._size === 0) {\r\n\t      this._settle()\r\n\t    }\r\n\t  }\r\n\t\r\n\t  PromisePool.PromisePoolEvent = PromisePoolEvent\r\n\t  // Legacy API\r\n\t  PromisePool.PromisePool = PromisePool\r\n\t\r\n\t  return PromisePool\r\n\t})\r\n\n\n/***/ },\n/* 74 */\n/*!**************************************************!*\\\n  !*** ./~/pouchdb/~/inherits/inherits_browser.js ***!\n  \\**************************************************/\n/***/ function(module, exports) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 75 */\n/*!****************************************!*\\\n  !*** ./~/pouchdb/~/lie/lib/browser.js ***!\n  \\****************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar immediate = __webpack_require__(/*! immediate */ 76);\n\t\n\t/* istanbul ignore next */\n\tfunction INTERNAL() {}\n\t\n\tvar handlers = {};\n\t\n\tvar REJECTED = ['REJECTED'];\n\tvar FULFILLED = ['FULFILLED'];\n\tvar PENDING = ['PENDING'];\n\t\n\tmodule.exports = Promise;\n\t\n\tfunction Promise(resolver) {\n\t  if (typeof resolver !== 'function') {\n\t    throw new TypeError('resolver must be a function');\n\t  }\n\t  this.state = PENDING;\n\t  this.queue = [];\n\t  this.outcome = void 0;\n\t  if (resolver !== INTERNAL) {\n\t    safelyResolveThenable(this, resolver);\n\t  }\n\t}\n\t\n\tPromise.prototype[\"catch\"] = function (onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\tPromise.prototype.then = function (onFulfilled, onRejected) {\n\t  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n\t    typeof onRejected !== 'function' && this.state === REJECTED) {\n\t    return this;\n\t  }\n\t  var promise = new this.constructor(INTERNAL);\n\t  if (this.state !== PENDING) {\n\t    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n\t    unwrap(promise, resolver, this.outcome);\n\t  } else {\n\t    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n\t  }\n\t\n\t  return promise;\n\t};\n\tfunction QueueItem(promise, onFulfilled, onRejected) {\n\t  this.promise = promise;\n\t  if (typeof onFulfilled === 'function') {\n\t    this.onFulfilled = onFulfilled;\n\t    this.callFulfilled = this.otherCallFulfilled;\n\t  }\n\t  if (typeof onRejected === 'function') {\n\t    this.onRejected = onRejected;\n\t    this.callRejected = this.otherCallRejected;\n\t  }\n\t}\n\tQueueItem.prototype.callFulfilled = function (value) {\n\t  handlers.resolve(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallFulfilled = function (value) {\n\t  unwrap(this.promise, this.onFulfilled, value);\n\t};\n\tQueueItem.prototype.callRejected = function (value) {\n\t  handlers.reject(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallRejected = function (value) {\n\t  unwrap(this.promise, this.onRejected, value);\n\t};\n\t\n\tfunction unwrap(promise, func, value) {\n\t  immediate(function () {\n\t    var returnValue;\n\t    try {\n\t      returnValue = func(value);\n\t    } catch (e) {\n\t      return handlers.reject(promise, e);\n\t    }\n\t    if (returnValue === promise) {\n\t      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n\t    } else {\n\t      handlers.resolve(promise, returnValue);\n\t    }\n\t  });\n\t}\n\t\n\thandlers.resolve = function (self, value) {\n\t  var result = tryCatch(getThen, value);\n\t  if (result.status === 'error') {\n\t    return handlers.reject(self, result.value);\n\t  }\n\t  var thenable = result.value;\n\t\n\t  if (thenable) {\n\t    safelyResolveThenable(self, thenable);\n\t  } else {\n\t    self.state = FULFILLED;\n\t    self.outcome = value;\n\t    var i = -1;\n\t    var len = self.queue.length;\n\t    while (++i < len) {\n\t      self.queue[i].callFulfilled(value);\n\t    }\n\t  }\n\t  return self;\n\t};\n\thandlers.reject = function (self, error) {\n\t  self.state = REJECTED;\n\t  self.outcome = error;\n\t  var i = -1;\n\t  var len = self.queue.length;\n\t  while (++i < len) {\n\t    self.queue[i].callRejected(error);\n\t  }\n\t  return self;\n\t};\n\t\n\tfunction getThen(obj) {\n\t  // Make sure we only access the accessor once as required by the spec\n\t  var then = obj && obj.then;\n\t  if (obj && typeof obj === 'object' && typeof then === 'function') {\n\t    return function appyThen() {\n\t      then.apply(obj, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction safelyResolveThenable(self, thenable) {\n\t  // Either fulfill, reject or reject with error\n\t  var called = false;\n\t  function onError(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.reject(self, value);\n\t  }\n\t\n\t  function onSuccess(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.resolve(self, value);\n\t  }\n\t\n\t  function tryToUnwrap() {\n\t    thenable(onSuccess, onError);\n\t  }\n\t\n\t  var result = tryCatch(tryToUnwrap);\n\t  if (result.status === 'error') {\n\t    onError(result.value);\n\t  }\n\t}\n\t\n\tfunction tryCatch(func, value) {\n\t  var out = {};\n\t  try {\n\t    out.value = func(value);\n\t    out.status = 'success';\n\t  } catch (e) {\n\t    out.status = 'error';\n\t    out.value = e;\n\t  }\n\t  return out;\n\t}\n\t\n\tPromise.resolve = resolve;\n\tfunction resolve(value) {\n\t  if (value instanceof this) {\n\t    return value;\n\t  }\n\t  return handlers.resolve(new this(INTERNAL), value);\n\t}\n\t\n\tPromise.reject = reject;\n\tfunction reject(reason) {\n\t  var promise = new this(INTERNAL);\n\t  return handlers.reject(promise, reason);\n\t}\n\t\n\tPromise.all = all;\n\tfunction all(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var values = new Array(len);\n\t  var resolved = 0;\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    allResolver(iterable[i], i);\n\t  }\n\t  return promise;\n\t  function allResolver(value, i) {\n\t    self.resolve(value).then(resolveFromAll, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t    function resolveFromAll(outValue) {\n\t      values[i] = outValue;\n\t      if (++resolved === len && !called) {\n\t        called = true;\n\t        handlers.resolve(promise, values);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tPromise.race = race;\n\tfunction race(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    resolver(iterable[i]);\n\t  }\n\t  return promise;\n\t  function resolver(value) {\n\t    self.resolve(value).then(function (response) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.resolve(promise, response);\n\t      }\n\t    }, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t  }\n\t}\n\n\n/***/ },\n/* 76 */\n/*!****************************************************!*\\\n  !*** ./~/pouchdb/~/lie/~/immediate/lib/browser.js ***!\n  \\****************************************************/\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\tvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\t\n\tvar scheduleDrain;\n\t\n\t{\n\t  if (Mutation) {\n\t    var called = 0;\n\t    var observer = new Mutation(nextTick);\n\t    var element = global.document.createTextNode('');\n\t    observer.observe(element, {\n\t      characterData: true\n\t    });\n\t    scheduleDrain = function () {\n\t      element.data = (called = ++called % 2);\n\t    };\n\t  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n\t    var channel = new global.MessageChannel();\n\t    channel.port1.onmessage = nextTick;\n\t    scheduleDrain = function () {\n\t      channel.port2.postMessage(0);\n\t    };\n\t  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n\t    scheduleDrain = function () {\n\t\n\t      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t      var scriptEl = global.document.createElement('script');\n\t      scriptEl.onreadystatechange = function () {\n\t        nextTick();\n\t\n\t        scriptEl.onreadystatechange = null;\n\t        scriptEl.parentNode.removeChild(scriptEl);\n\t        scriptEl = null;\n\t      };\n\t      global.document.documentElement.appendChild(scriptEl);\n\t    };\n\t  } else {\n\t    scheduleDrain = function () {\n\t      setTimeout(nextTick, 0);\n\t    };\n\t  }\n\t}\n\t\n\tvar draining;\n\tvar queue = [];\n\t//named nextTick for less confusing stack traces\n\tfunction nextTick() {\n\t  draining = true;\n\t  var i, oldQueue;\n\t  var len = queue.length;\n\t  while (len) {\n\t    oldQueue = queue;\n\t    queue = [];\n\t    i = -1;\n\t    while (++i < len) {\n\t      oldQueue[i]();\n\t    }\n\t    len = queue.length;\n\t  }\n\t  draining = false;\n\t}\n\t\n\tmodule.exports = immediate;\n\tfunction immediate(task) {\n\t  if (queue.push(task) === 1 && !draining) {\n\t    scheduleDrain();\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 77 */\n/*!**********************************************!*\\\n  !*** ./~/pouchdb/~/scope-eval/scope_eval.js ***!\n  \\**********************************************/\n/***/ function(module, exports) {\n\n\t// Generated by CoffeeScript 1.9.2\n\t(function() {\n\t  var hasProp = {}.hasOwnProperty,\n\t    slice = [].slice;\n\t\n\t  module.exports = function(source, scope) {\n\t    var key, keys, value, values;\n\t    keys = [];\n\t    values = [];\n\t    for (key in scope) {\n\t      if (!hasProp.call(scope, key)) continue;\n\t      value = scope[key];\n\t      if (key === 'this') {\n\t        continue;\n\t      }\n\t      keys.push(key);\n\t      values.push(value);\n\t    }\n\t    return Function.apply(null, slice.call(keys).concat([source])).apply(scope[\"this\"], values);\n\t  };\n\t\n\t}).call(this);\n\n\n/***/ },\n/* 78 */\n/*!********************************************!*\\\n  !*** ./~/pouchdb/~/spark-md5/spark-md5.js ***!\n  \\********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (factory) {\n\t    if (true) {\n\t        // Node/CommonJS\n\t        module.exports = factory();\n\t    } else if (typeof define === 'function' && define.amd) {\n\t        // AMD\n\t        define(factory);\n\t    } else {\n\t        // Browser globals (with support for web workers)\n\t        var glob;\n\t\n\t        try {\n\t            glob = window;\n\t        } catch (e) {\n\t            glob = self;\n\t        }\n\t\n\t        glob.SparkMD5 = factory();\n\t    }\n\t}(function (undefined) {\n\t\n\t    'use strict';\n\t\n\t    /*\n\t     * Fastest md5 implementation around (JKM md5).\n\t     * Credits: Joseph Myers\n\t     *\n\t     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n\t     * @see http://jsperf.com/md5-shootout/7\n\t     */\n\t\n\t    /* this function is much faster,\n\t      so if possible we use it. Some IEs\n\t      are the only ones I know of that\n\t      need the idiotic second function,\n\t      generated by an if clause.  */\n\t    var add32 = function (a, b) {\n\t        return (a + b) & 0xFFFFFFFF;\n\t    },\n\t        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\t\n\t\n\t    function cmn(q, a, b, x, s, t) {\n\t        a = add32(add32(a, q), add32(x, t));\n\t        return add32((a << s) | (a >>> (32 - s)), b);\n\t    }\n\t\n\t    function ff(a, b, c, d, x, s, t) {\n\t        return cmn((b & c) | ((~b) & d), a, b, x, s, t);\n\t    }\n\t\n\t    function gg(a, b, c, d, x, s, t) {\n\t        return cmn((b & d) | (c & (~d)), a, b, x, s, t);\n\t    }\n\t\n\t    function hh(a, b, c, d, x, s, t) {\n\t        return cmn(b ^ c ^ d, a, b, x, s, t);\n\t    }\n\t\n\t    function ii(a, b, c, d, x, s, t) {\n\t        return cmn(c ^ (b | (~d)), a, b, x, s, t);\n\t    }\n\t\n\t    function md5cycle(x, k) {\n\t        var a = x[0],\n\t            b = x[1],\n\t            c = x[2],\n\t            d = x[3];\n\t\n\t        a = ff(a, b, c, d, k[0], 7, -680876936);\n\t        d = ff(d, a, b, c, k[1], 12, -389564586);\n\t        c = ff(c, d, a, b, k[2], 17, 606105819);\n\t        b = ff(b, c, d, a, k[3], 22, -1044525330);\n\t        a = ff(a, b, c, d, k[4], 7, -176418897);\n\t        d = ff(d, a, b, c, k[5], 12, 1200080426);\n\t        c = ff(c, d, a, b, k[6], 17, -1473231341);\n\t        b = ff(b, c, d, a, k[7], 22, -45705983);\n\t        a = ff(a, b, c, d, k[8], 7, 1770035416);\n\t        d = ff(d, a, b, c, k[9], 12, -1958414417);\n\t        c = ff(c, d, a, b, k[10], 17, -42063);\n\t        b = ff(b, c, d, a, k[11], 22, -1990404162);\n\t        a = ff(a, b, c, d, k[12], 7, 1804603682);\n\t        d = ff(d, a, b, c, k[13], 12, -40341101);\n\t        c = ff(c, d, a, b, k[14], 17, -1502002290);\n\t        b = ff(b, c, d, a, k[15], 22, 1236535329);\n\t\n\t        a = gg(a, b, c, d, k[1], 5, -165796510);\n\t        d = gg(d, a, b, c, k[6], 9, -1069501632);\n\t        c = gg(c, d, a, b, k[11], 14, 643717713);\n\t        b = gg(b, c, d, a, k[0], 20, -373897302);\n\t        a = gg(a, b, c, d, k[5], 5, -701558691);\n\t        d = gg(d, a, b, c, k[10], 9, 38016083);\n\t        c = gg(c, d, a, b, k[15], 14, -660478335);\n\t        b = gg(b, c, d, a, k[4], 20, -405537848);\n\t        a = gg(a, b, c, d, k[9], 5, 568446438);\n\t        d = gg(d, a, b, c, k[14], 9, -1019803690);\n\t        c = gg(c, d, a, b, k[3], 14, -187363961);\n\t        b = gg(b, c, d, a, k[8], 20, 1163531501);\n\t        a = gg(a, b, c, d, k[13], 5, -1444681467);\n\t        d = gg(d, a, b, c, k[2], 9, -51403784);\n\t        c = gg(c, d, a, b, k[7], 14, 1735328473);\n\t        b = gg(b, c, d, a, k[12], 20, -1926607734);\n\t\n\t        a = hh(a, b, c, d, k[5], 4, -378558);\n\t        d = hh(d, a, b, c, k[8], 11, -2022574463);\n\t        c = hh(c, d, a, b, k[11], 16, 1839030562);\n\t        b = hh(b, c, d, a, k[14], 23, -35309556);\n\t        a = hh(a, b, c, d, k[1], 4, -1530992060);\n\t        d = hh(d, a, b, c, k[4], 11, 1272893353);\n\t        c = hh(c, d, a, b, k[7], 16, -155497632);\n\t        b = hh(b, c, d, a, k[10], 23, -1094730640);\n\t        a = hh(a, b, c, d, k[13], 4, 681279174);\n\t        d = hh(d, a, b, c, k[0], 11, -358537222);\n\t        c = hh(c, d, a, b, k[3], 16, -722521979);\n\t        b = hh(b, c, d, a, k[6], 23, 76029189);\n\t        a = hh(a, b, c, d, k[9], 4, -640364487);\n\t        d = hh(d, a, b, c, k[12], 11, -421815835);\n\t        c = hh(c, d, a, b, k[15], 16, 530742520);\n\t        b = hh(b, c, d, a, k[2], 23, -995338651);\n\t\n\t        a = ii(a, b, c, d, k[0], 6, -198630844);\n\t        d = ii(d, a, b, c, k[7], 10, 1126891415);\n\t        c = ii(c, d, a, b, k[14], 15, -1416354905);\n\t        b = ii(b, c, d, a, k[5], 21, -57434055);\n\t        a = ii(a, b, c, d, k[12], 6, 1700485571);\n\t        d = ii(d, a, b, c, k[3], 10, -1894986606);\n\t        c = ii(c, d, a, b, k[10], 15, -1051523);\n\t        b = ii(b, c, d, a, k[1], 21, -2054922799);\n\t        a = ii(a, b, c, d, k[8], 6, 1873313359);\n\t        d = ii(d, a, b, c, k[15], 10, -30611744);\n\t        c = ii(c, d, a, b, k[6], 15, -1560198380);\n\t        b = ii(b, c, d, a, k[13], 21, 1309151649);\n\t        a = ii(a, b, c, d, k[4], 6, -145523070);\n\t        d = ii(d, a, b, c, k[11], 10, -1120210379);\n\t        c = ii(c, d, a, b, k[2], 15, 718787259);\n\t        b = ii(b, c, d, a, k[9], 21, -343485551);\n\t\n\t        x[0] = add32(a, x[0]);\n\t        x[1] = add32(b, x[1]);\n\t        x[2] = add32(c, x[2]);\n\t        x[3] = add32(d, x[3]);\n\t    }\n\t\n\t    function md5blk(s) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n\t        }\n\t        return md5blks;\n\t    }\n\t\n\t    function md5blk_array(a) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n\t        }\n\t        return md5blks;\n\t    }\n\t\n\t    function md51(s) {\n\t        var n = s.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk(s.substring(i - 64, i)));\n\t        }\n\t        s = s.substring(i - 64);\n\t        length = s.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t        return state;\n\t    }\n\t\n\t    function md51_array(a) {\n\t        var n = a.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n\t        }\n\t\n\t        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n\t        // containing the last element of the parent array if the sub array specified starts\n\t        // beyond the length of the parent array - weird.\n\t        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n\t        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\t\n\t        length = a.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t\n\t        return state;\n\t    }\n\t\n\t    function rhex(n) {\n\t        var s = '',\n\t            j;\n\t        for (j = 0; j < 4; j += 1) {\n\t            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n\t        }\n\t        return s;\n\t    }\n\t\n\t    function hex(x) {\n\t        var i;\n\t        for (i = 0; i < x.length; i += 1) {\n\t            x[i] = rhex(x[i]);\n\t        }\n\t        return x.join('');\n\t    }\n\t\n\t    // In some cases the fast add32 function cannot be used..\n\t    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n\t        add32 = function (x, y) {\n\t            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n\t                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t            return (msw << 16) | (lsw & 0xFFFF);\n\t        };\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * ArrayBuffer slice polyfill.\n\t     *\n\t     * @see https://github.com/ttaubert/node-arraybuffer-slice\n\t     */\n\t\n\t    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n\t        (function () {\n\t            function clamp(val, length) {\n\t                val = (val | 0) || 0;\n\t\n\t                if (val < 0) {\n\t                    return Math.max(val + length, 0);\n\t                }\n\t\n\t                return Math.min(val, length);\n\t            }\n\t\n\t            ArrayBuffer.prototype.slice = function (from, to) {\n\t                var length = this.byteLength,\n\t                    begin = clamp(from, length),\n\t                    end = length,\n\t                    num,\n\t                    target,\n\t                    targetArray,\n\t                    sourceArray;\n\t\n\t                if (to !== undefined) {\n\t                    end = clamp(to, length);\n\t                }\n\t\n\t                if (begin > end) {\n\t                    return new ArrayBuffer(0);\n\t                }\n\t\n\t                num = end - begin;\n\t                target = new ArrayBuffer(num);\n\t                targetArray = new Uint8Array(target);\n\t\n\t                sourceArray = new Uint8Array(this, begin, num);\n\t                targetArray.set(sourceArray);\n\t\n\t                return target;\n\t            };\n\t        })();\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * Helpers.\n\t     */\n\t\n\t    function toUtf8(str) {\n\t        if (/[\\u0080-\\uFFFF]/.test(str)) {\n\t            str = unescape(encodeURIComponent(str));\n\t        }\n\t\n\t        return str;\n\t    }\n\t\n\t    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n\t        var length = str.length,\n\t           buff = new ArrayBuffer(length),\n\t           arr = new Uint8Array(buff),\n\t           i;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            arr[i] = str.charCodeAt(i);\n\t        }\n\t\n\t        return returnUInt8Array ? arr : buff;\n\t    }\n\t\n\t    function arrayBuffer2Utf8Str(buff) {\n\t        return String.fromCharCode.apply(null, new Uint8Array(buff));\n\t    }\n\t\n\t    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n\t        var result = new Uint8Array(first.byteLength + second.byteLength);\n\t\n\t        result.set(new Uint8Array(first));\n\t        result.set(new Uint8Array(second), first.byteLength);\n\t\n\t        return returnUInt8Array ? result : result.buffer;\n\t    }\n\t\n\t    function hexToBinaryString(hex) {\n\t        var bytes = [],\n\t            length = hex.length,\n\t            x;\n\t\n\t        for (x = 0; x < length - 1; x += 2) {\n\t            bytes.push(parseInt(hex.substr(x, 2), 16));\n\t        }\n\t\n\t        return String.fromCharCode.apply(String, bytes);\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation.\n\t     *\n\t     * Use this class to perform an incremental md5, otherwise use the\n\t     * static methods instead.\n\t     */\n\t\n\t    function SparkMD5() {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    }\n\t\n\t    /**\n\t     * Appends a string.\n\t     * A conversion will be applied if an utf8 string is detected.\n\t     *\n\t     * @param {String} str The string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.append = function (str) {\n\t        // Converts the string to utf8 bytes if necessary\n\t        // Then append as binary\n\t        this.appendBinary(toUtf8(str));\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Appends a binary string.\n\t     *\n\t     * @param {String} contents The binary string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.appendBinary = function (contents) {\n\t        this._buff += contents;\n\t        this._length += contents.length;\n\t\n\t        var length = this._buff.length,\n\t            i;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n\t        }\n\t\n\t        this._buff = this._buff.substring(i - 64);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     *\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            i,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = hex(this._hash);\n\t\n\t        if (raw) {\n\t            ret = hexToBinaryString(ret);\n\t        }\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.reset = function () {\n\t        this._buff = '';\n\t        this._length = 0;\n\t        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @return {Object} The state\n\t     */\n\t    SparkMD5.prototype.getState = function () {\n\t        return {\n\t            buff: this._buff,\n\t            length: this._length,\n\t            hash: this._hash\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @param {Object} state The state\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.setState = function (state) {\n\t        this._buff = state.buff;\n\t        this._length = state.length;\n\t        this._hash = state.hash;\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Releases memory used by the incremental buffer and other additional\n\t     * resources. If you plan to use the instance again, use reset instead.\n\t     */\n\t    SparkMD5.prototype.destroy = function () {\n\t        delete this._hash;\n\t        delete this._buff;\n\t        delete this._length;\n\t    };\n\t\n\t    /**\n\t     * Finish the final calculation based on the tail.\n\t     *\n\t     * @param {Array}  tail   The tail (will be modified)\n\t     * @param {Number} length The length of the remaining buffer\n\t     */\n\t    SparkMD5.prototype._finish = function (tail, length) {\n\t        var i = length,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(this._hash, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Do the final computation based on the tail and length\n\t        // Beware that the final length may not fit in 32 bits so we take care of that\n\t        tmp = this._length * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t        md5cycle(this._hash, tail);\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on a string.\n\t     * A conversion will be applied if utf8 string is detected.\n\t     *\n\t     * @param {String}  str The string\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.hash = function (str, raw) {\n\t        // Converts the string to utf8 bytes if necessary\n\t        // Then compute it using the binary function\n\t        return SparkMD5.hashBinary(toUtf8(str), raw);\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on a binary string.\n\t     *\n\t     * @param {String}  content The binary string\n\t     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.hashBinary = function (content, raw) {\n\t        var hash = md51(content),\n\t            ret = hex(hash);\n\t\n\t        return raw ? hexToBinaryString(ret) : ret;\n\t    };\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation for array buffers.\n\t     *\n\t     * Use this class to perform an incremental md5 ONLY for array buffers.\n\t     */\n\t    SparkMD5.ArrayBuffer = function () {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    };\n\t\n\t    /**\n\t     * Appends an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array to be appended\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n\t        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n\t            length = buff.length,\n\t            i;\n\t\n\t        this._length += arr.byteLength;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n\t        }\n\t\n\t        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     *\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            i,\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = hex(this._hash);\n\t\n\t        if (raw) {\n\t            ret = hexToBinaryString(ret);\n\t        }\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.reset = function () {\n\t        this._buff = new Uint8Array(0);\n\t        this._length = 0;\n\t        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @return {Object} The state\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.getState = function () {\n\t        var state = SparkMD5.prototype.getState.call(this);\n\t\n\t        // Convert buffer to a string\n\t        state.buff = arrayBuffer2Utf8Str(state.buff);\n\t\n\t        return state;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @param {Object} state The state\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n\t        // Convert string to buffer\n\t        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\t\n\t        return SparkMD5.prototype.setState.call(this, state);\n\t    };\n\t\n\t    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\t\n\t    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\t\n\t    /**\n\t     * Performs the md5 hash on an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array buffer\n\t     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n\t        var hash = md51_array(new Uint8Array(arr)),\n\t            ret = hex(hash);\n\t\n\t        return raw ? hexToBinaryString(ret) : ret;\n\t    };\n\t\n\t    return SparkMD5;\n\t}));\n\n\n/***/ },\n/* 79 */\n/*!***************************************!*\\\n  !*** ./~/pouchdb/~/vuvuzela/index.js ***!\n  \\***************************************/\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Stringify/parse functions that don't operate\n\t * recursively, so they avoid call stack exceeded\n\t * errors.\n\t */\n\texports.stringify = function stringify(input) {\n\t  var queue = [];\n\t  queue.push({obj: input});\n\t\n\t  var res = '';\n\t  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n\t  while ((next = queue.pop())) {\n\t    obj = next.obj;\n\t    prefix = next.prefix || '';\n\t    val = next.val || '';\n\t    res += prefix;\n\t    if (val) {\n\t      res += val;\n\t    } else if (typeof obj !== 'object') {\n\t      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n\t    } else if (obj === null) {\n\t      res += 'null';\n\t    } else if (Array.isArray(obj)) {\n\t      queue.push({val: ']'});\n\t      for (i = obj.length - 1; i >= 0; i--) {\n\t        arrayPrefix = i === 0 ? '' : ',';\n\t        queue.push({obj: obj[i], prefix: arrayPrefix});\n\t      }\n\t      queue.push({val: '['});\n\t    } else { // object\n\t      keys = [];\n\t      for (k in obj) {\n\t        if (obj.hasOwnProperty(k)) {\n\t          keys.push(k);\n\t        }\n\t      }\n\t      queue.push({val: '}'});\n\t      for (i = keys.length - 1; i >= 0; i--) {\n\t        key = keys[i];\n\t        value = obj[key];\n\t        objPrefix = (i > 0 ? ',' : '');\n\t        objPrefix += JSON.stringify(key) + ':';\n\t        queue.push({obj: value, prefix: objPrefix});\n\t      }\n\t      queue.push({val: '{'});\n\t    }\n\t  }\n\t  return res;\n\t};\n\t\n\t// Convenience function for the parse function.\n\t// This pop function is basically copied from\n\t// pouchCollate.parseIndexableString\n\tfunction pop(obj, stack, metaStack) {\n\t  var lastMetaElement = metaStack[metaStack.length - 1];\n\t  if (obj === lastMetaElement.element) {\n\t    // popping a meta-element, e.g. an object whose value is another object\n\t    metaStack.pop();\n\t    lastMetaElement = metaStack[metaStack.length - 1];\n\t  }\n\t  var element = lastMetaElement.element;\n\t  var lastElementIndex = lastMetaElement.index;\n\t  if (Array.isArray(element)) {\n\t    element.push(obj);\n\t  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t    var key = stack.pop();\n\t    element[key] = obj;\n\t  } else {\n\t    stack.push(obj); // obj with key only\n\t  }\n\t}\n\t\n\texports.parse = function (str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t  var collationIndex,parsedNum,numChar;\n\t  var parsedString,lastCh,numConsecutiveSlashes,ch;\n\t  var arrayElement, objElement;\n\t  while (true) {\n\t    collationIndex = str[i++];\n\t    if (collationIndex === '}' ||\n\t        collationIndex === ']' ||\n\t        typeof collationIndex === 'undefined') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack.pop(), stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case ' ':\n\t      case '\\t':\n\t      case '\\n':\n\t      case ':':\n\t      case ',':\n\t        break;\n\t      case 'n':\n\t        i += 3; // 'ull'\n\t        pop(null, stack, metaStack);\n\t        break;\n\t      case 't':\n\t        i += 3; // 'rue'\n\t        pop(true, stack, metaStack);\n\t        break;\n\t      case 'f':\n\t        i += 4; // 'alse'\n\t        pop(false, stack, metaStack);\n\t        break;\n\t      case '0':\n\t      case '1':\n\t      case '2':\n\t      case '3':\n\t      case '4':\n\t      case '5':\n\t      case '6':\n\t      case '7':\n\t      case '8':\n\t      case '9':\n\t      case '-':\n\t        parsedNum = '';\n\t        i--;\n\t        while (true) {\n\t          numChar = str[i++];\n\t          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n\t            parsedNum += numChar;\n\t          } else {\n\t            i--;\n\t            break;\n\t          }\n\t        }\n\t        pop(parseFloat(parsedNum), stack, metaStack);\n\t        break;\n\t      case '\"':\n\t        parsedString = '';\n\t        lastCh = void 0;\n\t        numConsecutiveSlashes = 0;\n\t        while (true) {\n\t          ch = str[i++];\n\t          if (ch !== '\"' || (lastCh === '\\\\' &&\n\t              numConsecutiveSlashes % 2 === 1)) {\n\t            parsedString += ch;\n\t            lastCh = ch;\n\t            if (lastCh === '\\\\') {\n\t              numConsecutiveSlashes++;\n\t            } else {\n\t              numConsecutiveSlashes = 0;\n\t            }\n\t          } else {\n\t            break;\n\t          }\n\t        }\n\t        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n\t        break;\n\t      case '[':\n\t        arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '{':\n\t        objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      default:\n\t        throw new Error(\n\t          'unexpectedly reached end of input: ' + collationIndex);\n\t    }\n\t  }\n\t};\n\n\n/***/ },\n/* 80 */,\n/* 81 */,\n/* 82 */\n/*!********************************************************!*\\\n  !*** (webpack)/~/node-libs-browser/~/events/events.js ***!\n  \\********************************************************/\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      } else {\n\t        // At least give some kind of context to the user\n\t        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t        err.context = er;\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 83 */\n/*!************************!*\\\n  !*** crypto (ignored) ***!\n  \\************************/\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n/* 84 */\n/*!************************!*\\\n  !*** crypto (ignored) ***!\n  \\************************/\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** vendor.bundle.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t0:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8ae8e044cde9db8515d9\n **/","'use strict';\n\nvar Promise = require('pouchdb-promise');\n\n/* istanbul ignore next */\nexports.once = function (fun) {\n  var called = false;\n  return exports.getArguments(function (args) {\n    if (called) {\n      console.trace();\n      throw new Error('once called  more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n};\n/* istanbul ignore next */\nexports.getArguments = function (fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n    return fun.call(this, args);\n  };\n};\n/* istanbul ignore next */\nexports.toPromise = function (func) {\n  //create the function we will be returning\n  return exports.getArguments(function (args) {\n    var self = this;\n    var tempCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    // if the last argument is a function, assume its a callback\n    var usedCB;\n    if (tempCB) {\n      // if it was a callback, create a new callback which calls it,\n      // but do so async so we don't trap any errors\n      usedCB = function (err, resp) {\n        process.nextTick(function () {\n          tempCB(err, resp);\n        });\n      };\n    }\n    var promise = new Promise(function (fulfill, reject) {\n      try {\n        var callback = exports.once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        func.apply(self, args);\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    promise.cancel = function () {\n      return this;\n    };\n    return promise;\n  });\n};\n\nexports.inherits = require('inherits');\nexports.Promise = Promise;\n\nexports.clone = function (obj) {\n  return exports.extend(true, {}, obj);\n};\n\nexports.extend = require('pouchdb-extend');\n\nexports.callbackify = function (fun) {\n  return exports.getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    exports.promisedCallback(promise, cb);\n    return promise;\n  });\n};\n\nexports.promisedCallback = function (promise, callback) {\n  promise.then(function (res) {\n    process.nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    process.nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n};\n\nvar crypto = require('crypto');\nvar Md5 = require('spark-md5');\n\nexports.MD5 = function (string) {\n  /* istanbul ignore else */\n  if (!process.browser) {\n    return crypto.createHash('md5').update(string).digest('hex');\n  } else {\n    return Md5.hash(string);\n  }\n};\n\nexports.flatten = exports.getArguments(function (args) {\n  var res = [];\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n    if (Array.isArray(subArr)) {\n      res = res.concat(exports.flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n  return res;\n});\n\nexports.mergeObjects = function (arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = exports.extend(true, res, arr[i]);\n  }\n  return res;\n};\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nexports.getFieldFromDoc = function (doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n};\n\nexports.setFieldInDoc = function (doc, parsedField, value) {\n  for (var i = 0, len = parsedField.length; i < len-1; i++) {\n    var elem = parsedField[i];\n    doc = doc[elem] = {};\n  }\n  doc[parsedField[len-1]] = value;\n};\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nexports.parseField = function (fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n};\n\n// Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\nexports.pick = function (obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = exports.parseField(arr[i]);\n    var value = exports.getFieldFromDoc(obj, parsedField);\n    if(typeof value !== 'undefined') {\n      exports.setFieldInDoc(res, parsedField, value);\n    }\n  }\n  return res;\n};\n\n// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\nexports.oneArrayIsSubArrayOfOther = function (left, right) {\n\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// e.g.['a', 'b', 'c'], ['a', 'b'] is false\nexports.oneArrayIsStrictSubArrayOfOther = function (left, right) {\n\n  if (left.length > right.length) {\n    return false;\n  }\n\n  return exports.oneArrayIsSubArrayOfOther(left, right);\n};\n\n// same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\nexports.oneSetIsSubArrayOfOther = function (left, right) {\n  left = left.slice();\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n    if (!left.length) {\n      break;\n    }\n    var leftIdx = left.indexOf(field);\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n  return true;\n};\n\nexports.compare = function (left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n};\n\nexports.arrayToObject = function (arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n  return res;\n};\n\nexports.max = function (arr, fun) {\n  var max = null;\n  var maxScore = -1;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n  return max;\n};\n\nexports.arrayEquals = function (arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexports.uniq = function(arr) {\n  var obj = {};\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n};\n\nexports.log = require('debug')('pouchdb:find');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/utils.js\n ** module id = 3\n ** module chunks = 0\n **/","(function () {\r\n  'use strict';\r\n\r\n  // common function which is often using\r\n  var commonUse = {\r\n    /**\r\n     * [Add class to element]\r\n     *\r\n     * @param el {Object}   -- element.\r\n     * @param cls {String}  -- classes.\r\n     */\r\n    addClass: function(el, cls) {\r\n      var elClass = el.className;\r\n      var blank = (elClass !== '') ? ' ' : '';\r\n      var added = elClass + blank + cls;\r\n      el.className = added;\r\n    },\r\n\r\n    /**\r\n     * [Remove class from element]\r\n     *\r\n     * @param el {Object}   -- element.\r\n     * @param cls {String}  -- classes.\r\n     */\r\n    removeClass: function(el, cls) {\r\n      var elClass = ' '+el.className+' ';\r\n      elClass = elClass.replace(/(\\s+)/gi, ' ');\r\n      var removed = elClass.replace(' '+cls+' ', ' ');\r\n      removed = removed.replace(/(^\\s+)|(\\s+$)/g, '');\r\n      el.className = removed;\r\n    },\r\n\r\n    /**\r\n     * [if element has some class]\r\n     *\r\n     * @param el {Object}   -- element.\r\n     * @param cls {String}  -- classes.\r\n     *\r\n     * @return  {Boolean}   -- true or false.\r\n     */\r\n    hasClass: function(el, cls) {\r\n      var elClass = el.className;\r\n      var elClassList = elClass.split(/\\s+/);\r\n      var x = 0;\r\n      for(x in elClassList) {\r\n        if(elClassList[x] == cls) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    },\r\n\r\n    /**\r\n     * [add event to some element, dom0, dom1, supports fuck ie]\r\n     *\r\n     * @param el {Object}       -- element.\r\n     * @param type {String}     -- event type, such as 'click', 'mouseover'.\r\n     * @param func {Function}   -- function.\r\n     *\r\n     */\r\n    addEvent: function(el, type, func) {\r\n      if(el.addEventListener) {\r\n        el.addEventListener(type, func, false);\r\n      } else if(el.attachEvent){ \r\n        el.attachEvent('on' + type, func);\r\n      } else{ \r\n        el['on' + type] = func; \r\n      }  \r\n    },\r\n\r\n    /**\r\n     * [remove event to some element, dom0, dom1, supports fuck ie]\r\n     *\r\n     * @param el {Object}       -- element.\r\n     * @param type {String}     -- event type, such as 'click', 'mouseover'.\r\n     * @param func {Function}   -- function.\r\n     *\r\n     */\r\n    removeEvent: function(el, type, func) {\r\n      if (el.removeEventListener){ \r\n        el.removeEventListener(type, func, false);\r\n      } else if (el.detachEvent){\r\n        el.detachEvent('on' + type, func);\r\n      } else {\r\n        delete el['on' + type];\r\n      }\r\n    },\r\n\r\n    /**\r\n     * [Remove element node]\r\n     *\r\n     * @param el {Object}   -- element.\r\n     *\r\n     */\r\n    removeElement: function(el) {\r\n      (el && el.parentNode) && el.parentNode.removeChild(el);\r\n    },\r\n\r\n    /**\r\n     * [Set unique id]\r\n     *\r\n     * @param prefix {String}   -- id prefix name.\r\n     *\r\n     * @return  {String}\r\n     */\r\n    setUid: function(prefix) {\r\n      do prefix += Math.floor(Math.random() * 1000000);\r\n      while (document.getElementById(prefix));\r\n      return prefix;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * [Alertiy public API]\r\n   *\r\n   * @return {Object}\r\n   */\r\n  var Alerty = function() {\r\n\r\n    // private object for Alerty object inherit\r\n    var Dialog = {\r\n      \r\n      // static defaults params\r\n      defaults: {\r\n        okLabel: '\\u786e\\u5b9a',\r\n        cancelLabel: '\\u53d6\\u6d88',\r\n        time: 2000\r\n      },\r\n\r\n      previousCallback: null,  // for cache previous toasts callbak, to handle if call more than 1 alerty\r\n\r\n      // html templates\r\n      template: '<div class=\"alerty-overlay\" tabindex=\"-1\"></div>'+\r\n                '<div class=\"alerty\">'+\r\n                  '<div class=\"alerty-title\"></div>'+\r\n                  '<div class=\"alerty-content\">'+\r\n                    '<p class=\"alerty-message\"></p>'+\r\n                    '<div class=\"alerty-prompt\">'+\r\n                      '<input type=\"text\" placeholder=\"\" value=\"\">'+\r\n                      '<div class=\"input-line\"></div>'+\r\n                    '</div>'+\r\n                  '</div>'+\r\n                  '<div class=\"alerty-action\">'+\r\n                    '<a class=\"btn-cancel\"></a>'+\r\n                    '<a class=\"btn-ok\"></a>'+\r\n                  '</div>'+\r\n                '</div>',\r\n\r\n\r\n\r\n      /** \r\n       * [Build the HTML contents]\r\n       *\r\n       * @param type {String}           -- get the dialog type to arrange the correspondent html content.\r\n       * @param content {String}        -- the text contents dialog to users.\r\n       * @param opts {Object}           -- options.\r\n       * @param onOk {Function}         -- custom callback function after click ok button.\r\n       * @param onCancel {Function}     -- custom callback function after click cancel button.\r\n       */\r\n      setup: function(type, content, opts, onOk, onCancel) {\r\n        // for if argument opts is not given.\r\n        var detect = typeof opts === 'function';\r\n        if (detect) {\r\n          onCancel = onOk;\r\n          onOk = opts;\r\n        }\r\n\r\n        var $oldModal = document.querySelector('.alerty');\r\n\r\n\r\n        // if previous modal is open, remove it and immediately callback\r\n        if ($oldModal) {\r\n          commonUse.removeElement($oldModal);\r\n          var _callback = this.previousCallback;\r\n          if (_callback) _callback();\r\n        }\r\n\r\n        var $wrapper = document.createElement('div');\r\n        $wrapper.innerHTML = this.template;\r\n\r\n        // append alerty to body\r\n        while ($wrapper.firstChild) {\r\n          document.body.appendChild($wrapper.firstChild);\r\n        }\r\n\r\n        // cache alerty dom for next use\r\n        var $modal = document.querySelector('.alerty');\r\n        var $overlay = document.querySelector('.alerty-overlay');\r\n        var $title = $modal.querySelector('.alerty-title');\r\n        var $message = $modal.querySelector('.alerty-message');\r\n        var $btnArea = $modal.querySelector('.alerty-action');\r\n        var $btnOk = $modal.querySelector('.btn-ok');\r\n        var $btnCancel = $modal.querySelector('.btn-cancel');\r\n        var $prompt = $modal.querySelector('.alerty-prompt');\r\n        var $input = $prompt.querySelector('input');\r\n\r\n        // set uid\r\n        $modal.id = commonUse.setUid('alerty');\r\n        $overlay.id = 'overlay-'+$modal.id;\r\n\r\n        // animation show alerty\r\n        commonUse.addClass($overlay, 'active');\r\n        commonUse.addClass($modal, 'alerty-show');\r\n        $message.innerHTML = content;  // set msg\r\n\r\n        if (opts && opts.time) this.defaults.time = opts.time; // handle time if set\r\n\r\n        if (type !== 'prompt') {\r\n          commonUse.removeElement($prompt); // other type do not need\r\n        } else {\r\n          $input.focus(); // auto focus input if type prompt\r\n\r\n          if(opts && opts.inputType) $input.setAttribute('type', opts.inputType); // handle input type, such as 'password'\r\n          if(opts && opts.inputPlaceholder) $input.setAttribute('placeholder', opts.inputPlaceholder); // handle input placeholder\r\n          if(opts && opts.inputValue) $input.setAttribute('value', opts.inputValue); // handle input default value \r\n        }\r\n\r\n        if (type === 'toasts') {\r\n          this.previousCallback = onOk;  // cache callback\r\n\r\n          // rearrange template\r\n          commonUse.removeElement($title);\r\n          commonUse.removeElement($btnArea);\r\n          commonUse.removeElement($overlay);\r\n          commonUse.addClass($modal, 'toasts');\r\n\r\n          if (opts && opts.place === 'top') commonUse.addClass($modal, 'place-top'); // handle toasts top place\r\n          if (opts && opts.bgColor) $modal.style.backgroundColor = opts.bgColor;\r\n          if (opts && opts.fontColor) $message.style.color =opts.fontColor;\r\n\r\n        } else {\r\n          commonUse.addClass(document.body, 'no-scrolling'); // body no scorll\r\n          (opts && opts.title) ? $title.innerHTML = opts.title : commonUse.removeElement($title); // handle title if set\r\n          (opts && opts.okLabel) ? $btnOk.innerHTML = opts.okLabel : $btnOk.innerHTML = this.defaults.okLabel; // handle ok text if set\r\n          $modal.style.marginTop =  - $modal.offsetHeight / 2 + 'px'; // set the place to center using margin-top;\r\n\r\n          if (type === 'confirm' || type === 'prompt') {\r\n            (opts && opts.cancelLabel) ? $btnCancel.innerHTML = opts.cancelLabel : $btnCancel.innerHTML = this.defaults.cancelLabel; // handle cancel text if set\r\n          } else {\r\n            commonUse.removeElement($btnCancel); // toasts and alery type do not need cancel btn\r\n          }\r\n        }\r\n\r\n        this.bindEvent($modal, onOk, onCancel); // see next\r\n      },\r\n\r\n      /** \r\n       * [Bind event to dialog]\r\n       *\r\n       * @param $modal {Object}       -- modal node.\r\n       * @param: onOk {Function}      -- ok callback.\r\n       * @param: onCancel {Function}  -- cancel callback.\r\n       */\r\n      bindEvent: function($modal, onOk, onCancel) {\r\n        var that = this;\r\n        var $btnOk = $modal.querySelector('.btn-ok');\r\n        var $btnCancel = $modal.querySelector('.btn-cancel');\r\n\r\n        // toasts delay hide\r\n        if (commonUse.hasClass($modal, 'toasts')) {\r\n          setTimeout(function() {\r\n            // if toasts has been removed\r\n            if (document.getElementById($modal.id) === null) return;\r\n            that.close($modal, onOk);\r\n          }, that.defaults.time);\r\n        }\r\n        // click ok button\r\n        if ($btnOk) {\r\n          commonUse.addEvent($btnOk, 'click', function() {\r\n            that.close($modal, onOk);\r\n          });\r\n        }\r\n        // click cancel button\r\n        if ($btnCancel) {\r\n          commonUse.addEvent($btnCancel, 'click', function() {\r\n            that.close($modal, onCancel);\r\n          });\r\n        }\r\n      },\r\n\r\n      /** \r\n       * [Close the actived modal and remove it]\r\n       *\r\n       * @param: $modal {Obejct}  -- modal element to remove.\r\n       * @param: callback {Function}  -- callback function.\r\n       */\r\n      close: function($modal, callback) {\r\n        var $input = $modal.querySelector('input');\r\n        var $overlay = document.getElementById('overlay-'+$modal.id);\r\n\r\n        // hide alerty with animation\r\n        commonUse.removeClass($modal, 'alerty-show');\r\n        commonUse.addClass($modal, 'alerty-hide');\r\n\r\n        // remove alerty and other added elements\r\n        setTimeout(function(){\r\n          $overlay && commonUse.removeClass($overlay, 'active'), commonUse.removeClass(document.body, 'no-scrolling');\r\n          \r\n          commonUse.removeElement($modal);\r\n          commonUse.removeElement($overlay);\r\n          if (callback) {\r\n            setTimeout(function(){\r\n              !$input ? callback() : callback($input.value);  // handle prompt type, callback the input value\r\n            }, 100);\r\n          }\r\n        },100);\r\n      }\r\n    };\r\n\r\n    return {\r\n      // return alerty.toasts();\r\n      toasts: function(content, opts, callback) {\r\n        Dialog.setup('toasts', content, opts, callback);\r\n      },\r\n\r\n      // return alerty.alert();\r\n      alert: function(content, opts, onOk) {\r\n        Dialog.setup('alert', content, opts, onOk);\r\n      },\r\n\r\n      // return alerty.confirm();\r\n      confirm: function(content, opts, onOk, onCancel) {\r\n        Dialog.setup('confirm', content, opts, onOk, onCancel);\r\n      },\r\n\r\n      // return alerty.prompt();\r\n      prompt: function(content, opts, callback) {\r\n        Dialog.setup('prompt', content, opts, callback);\r\n      }\r\n    };\r\n  };\r\n\r\n\r\n\r\n  // NPM, AMD, and wndow support\r\n  if ('undefined' !== typeof module && !! module && !! module.exports) {\r\n    module.exports = function() {\r\n      return new Alerty();\r\n    };\r\n    var obj = new Alerty();\r\n    for (var key in obj) {\r\n      module.exports[key] = obj[key];\r\n    }\r\n  } else if (typeof define === 'function' && define.amd) {\r\n    define(function() {\r\n      return new Alerty();\r\n    });\r\n  } else {\r\n    window.alerty = new Alerty();\r\n  }\r\n}());\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/alerty/alerty.js\n ** module id = 4\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('../../utils');\nvar collate = require('pouchdb-collate');\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n// normalize the \"sort\" value\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField (field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = utils.clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\n\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n    return field;\n  });\n  return indexDef;\n}\n\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = getKey(index.def.fields[i]);\n    res.push(doc[field]);\n  }\n  return res;\n}\n\n// have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i];\n\n    // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else { // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    }\n    //ABS as we just looking for values that don't match\n    if (Math.abs(collate.collate(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n  return i > 0 ? rows.slice(i) : rows;\n}\n\nfunction reverseOptions(opts) {\n  var newOpts = utils.clone(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n  return newOpts;\n}\n\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return getValue(field) === 'asc';\n  });\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\n\nfunction validateSort (requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') +\n      '\" when using the default index');\n    }\n  }\n\n  if (index.defaultUsed) {\n    return;\n  }\n}\n\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n}\n\n// determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort? sort.map(getKey) : [];\n  var userFields;\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  }\n\n  // sort according to the user's preferred sorting\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n    var rightIdx = sortFields.indexOf(right);\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n\n  return {\n    fields: userFields,\n    sortOrder: sort.map(getKey)\n  };\n}\n\nmodule.exports = {\n  getKey: getKey,\n  getValue: getValue,\n  massageSort: massageSort,\n  massageSelector: massageSelector,\n  validateIndex: validateIndex,\n  validateFindRequest: validateFindRequest,\n  validateSort: validateSort,\n  reverseOptions: reverseOptions,\n  filterInclusiveStart: filterInclusiveStart,\n  massageIndexDef: massageIndexDef,\n  parseField: utils.parseField,\n  getUserFields: getUserFields,\n  isCombinationalField: isCombinationalField\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/adapters/local/utils.js\n ** module id = 5\n ** module chunks = 0\n **/","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nvar utils = require('./utils');\n\nexports.collate = function (a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = exports.normalizeKey(a);\n  b = exports.normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  if (a === null) {\n    return 0;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a === b ? 0 : (a < b ? -1 : 1);\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n};\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nexports.normalizeKey = function (key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = exports.normalizeKey(origKey[i]);\n        }\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = exports.normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n};\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += exports.toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += exports.toIndexableString(objKey) +\n                exports.toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nexports.toIndexableString = function (key) {\n  var zero = '\\u0000';\n  key = exports.normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n};\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    if (neg) {\n      num = num - 10;\n    }\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nexports.parseIndexableString = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = exports.collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = exports.collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = exports.collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = utils.padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/pouchdb-collate/lib/index.js\n ** module id = 7\n ** module chunks = 0\n **/","/*!\n * Pikaday\n *\n * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday\n */\n\n(function (root, factory)\n{\n    'use strict';\n\n    // if (typeof exports === 'object') {\n    //     // CommonJS module\n    //     // Load moment.js as an optional dependency\n    //     try { moment = require('moment'); } catch (e) {}\n    //     module.exports = factory(moment);\n    // } else if (typeof define === 'function' && define.amd) {\n    //     // AMD. Register as an anonymous module.\n    //     define(function (req)\n    //     {\n    //         // Load moment.js as an optional dependency\n    //         var id = 'moment';\n    //         try { moment = req(id); } catch (e) {}\n    //         return factory(moment);\n    //     });\n    // } else {\n    //     root.Pikaday = factory(root.moment);\n    // }\n\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if ( typeof exports === 'object' ) {\n        // Node/CommonJS\n        module.exports = factory();\n    } else {\n        // Browser globals\n        root.Pikaday = factory();\n    }\n\n}(this, function ()\n{\n    'use strict';\n\n    /**\n     * feature detection and helper functions\n     */\n    var hasMoment = typeof moment === 'function',\n\n    hasEventListeners = !!window.addEventListener,\n\n    document = window.document,\n\n    sto = window.setTimeout,\n\n    addEvent = function(el, e, callback, capture)\n    {\n        if (hasEventListeners) {\n            el.addEventListener(e, callback, !!capture);\n        } else {\n            el.attachEvent('on' + e, callback);\n        }\n    },\n\n    removeEvent = function(el, e, callback, capture)\n    {\n        if (hasEventListeners) {\n            el.removeEventListener(e, callback, !!capture);\n        } else {\n            el.detachEvent('on' + e, callback);\n        }\n    },\n\n    fireEvent = function(el, eventName, data)\n    {\n        var ev;\n\n        if (document.createEvent) {\n            ev = document.createEvent('HTMLEvents');\n            ev.initEvent(eventName, true, false);\n            ev = extend(ev, data);\n            el.dispatchEvent(ev);\n        } else if (document.createEventObject) {\n            ev = document.createEventObject();\n            ev = extend(ev, data);\n            el.fireEvent('on' + eventName, ev);\n        }\n    },\n\n    trim = function(str)\n    {\n        return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g,'');\n    },\n\n    hasClass = function(el, cn)\n    {\n        return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;\n    },\n\n    addClass = function(el, cn)\n    {\n        if (!hasClass(el, cn)) {\n            el.className = (el.className === '') ? cn : el.className + ' ' + cn;\n        }\n    },\n\n    removeClass = function(el, cn)\n    {\n        el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));\n    },\n\n    isArray = function(obj)\n    {\n        return (/Array/).test(Object.prototype.toString.call(obj));\n    },\n\n    isDate = function(obj)\n    {\n        return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());\n    },\n\n    isWeekend = function(date)\n    {\n        var day = date.getDay();\n        return day === 0 || day === 6;\n    },\n\n    isLeapYear = function(year)\n    {\n        // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951\n        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n    },\n\n    getDaysInMonth = function(year, month)\n    {\n        return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n    },\n\n    setToStartOfDay = function(date)\n    {\n        if (isDate(date)) date.setHours(0,0,0,0);\n    },\n\n    compareDates = function(a,b)\n    {\n        // weak date comparison (use setToStartOfDay(date) to ensure correct result)\n        return a.getTime() === b.getTime();\n    },\n\n    extend = function(to, from, overwrite)\n    {\n        var prop, hasProp;\n        for (prop in from) {\n            hasProp = to[prop] !== undefined;\n            if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {\n                if (isDate(from[prop])) {\n                    if (overwrite) {\n                        to[prop] = new Date(from[prop].getTime());\n                    }\n                }\n                else if (isArray(from[prop])) {\n                    if (overwrite) {\n                        to[prop] = from[prop].slice(0);\n                    }\n                } else {\n                    to[prop] = extend({}, from[prop], overwrite);\n                }\n            } else if (overwrite || !hasProp) {\n                to[prop] = from[prop];\n            }\n        }\n        return to;\n    },\n\n    adjustCalendar = function(calendar) {\n        if (calendar.month < 0) {\n            calendar.year -= Math.ceil(Math.abs(calendar.month)/12);\n            calendar.month += 12;\n        }\n        if (calendar.month > 11) {\n            calendar.year += Math.floor(Math.abs(calendar.month)/12);\n            calendar.month -= 12;\n        }\n        return calendar;\n    },\n\n    /**\n     * defaults and localisation\n     */\n    defaults = {\n\n        // bind the picker to a form field\n        field: null,\n\n        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)\n        bound: undefined,\n\n        // position of the datepicker, relative to the field (default to bottom & left)\n        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)\n        position: 'bottom left',\n\n        // automatically fit in the viewport even if it means repositioning from the position option\n        reposition: true,\n\n        // the default output format for `.toString()` and `field` value\n        format: 'YYYY-MM-DD',\n\n        // the initial date to view when first opened\n        defaultDate: null,\n\n        // make the `defaultDate` the initial selected value\n        setDefaultDate: false,\n\n        // first day of week (0: Sunday, 1: Monday etc)\n        firstDay: 0,\n\n        // the minimum/earliest date that can be selected\n        minDate: null,\n        // the maximum/latest date that can be selected\n        maxDate: null,\n\n        // number of years either side, or array of upper/lower range\n        yearRange: 10,\n\n        // show week numbers at head of row\n        showWeekNumber: false,\n\n        // used internally (don't config outside)\n        minYear: 0,\n        maxYear: 9999,\n        minMonth: undefined,\n        maxMonth: undefined,\n\n        startRange: null,\n        endRange: null,\n\n        isRTL: false,\n\n        // Additional text to append to the year in the calendar title\n        yearSuffix: '',\n\n        // Render the month after year in the calendar title\n        showMonthAfterYear: false,\n\n        // how many months are visible\n        numberOfMonths: 1,\n\n        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)\n        // only used for the first display or when a selected date is not visible\n        mainCalendar: 'left',\n\n        // Specify a DOM element to render the calendar in\n        container: undefined,\n\n        // internationalization\n        i18n: {\n            previousMonth : 'Previous Month',\n            nextMonth     : 'Next Month',\n            months        : ['January','February','March','April','May','June','July','August','September','October','November','December'],\n            weekdays      : ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],\n            weekdaysShort : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']\n        },\n\n        // Theme Classname\n        theme: null,\n\n        // callback function\n        onSelect: null,\n        onOpen: null,\n        onClose: null,\n        onDraw: null\n    },\n\n\n    /**\n     * templating functions to abstract HTML rendering\n     */\n    renderDayName = function(opts, day, abbr)\n    {\n        day += opts.firstDay;\n        while (day >= 7) {\n            day -= 7;\n        }\n        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];\n    },\n\n    renderDay = function(opts)\n    {\n        if (opts.isEmpty) {\n            return '<td class=\"is-empty\"></td>';\n        }\n        var arr = [];\n        if (opts.isDisabled) {\n            arr.push('is-disabled');\n        }\n        if (opts.isToday) {\n            arr.push('is-today');\n        }\n        if (opts.isSelected) {\n            arr.push('is-selected');\n        }\n        if (opts.isInRange) {\n            arr.push('is-inrange');\n        }\n        if (opts.isStartRange) {\n            arr.push('is-startrange');\n        }\n        if (opts.isEndRange) {\n            arr.push('is-endrange');\n        }\n        return '<td data-day=\"' + opts.day + '\" class=\"' + arr.join(' ') + '\">' +\n                 '<button class=\"pika-button pika-day\" type=\"button\" ' +\n                    'data-pika-year=\"' + opts.year + '\" data-pika-month=\"' + opts.month + '\" data-pika-day=\"' + opts.day + '\">' +\n                        opts.day +\n                 '</button>' +\n               '</td>';\n    },\n\n    renderWeek = function (d, m, y) {\n        // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.\n        var onejan = new Date(y, 0, 1),\n            weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay()+1)/7);\n        return '<td class=\"pika-week\">' + weekNum + '</td>';\n    },\n\n    renderRow = function(days, isRTL)\n    {\n        return '<tr>' + (isRTL ? days.reverse() : days).join('') + '</tr>';\n    },\n\n    renderBody = function(rows)\n    {\n        return '<tbody>' + rows.join('') + '</tbody>';\n    },\n\n    renderHead = function(opts)\n    {\n        var i, arr = [];\n        if (opts.showWeekNumber) {\n            arr.push('<th></th>');\n        }\n        for (i = 0; i < 7; i++) {\n            arr.push('<th scope=\"col\"><abbr title=\"' + renderDayName(opts, i) + '\">' + renderDayName(opts, i, true) + '</abbr></th>');\n        }\n        return '<thead>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</thead>';\n    },\n\n    renderTitle = function(instance, c, year, month, refYear)\n    {\n        var i, j, arr,\n            opts = instance._o,\n            isMinYear = year === opts.minYear,\n            isMaxYear = year === opts.maxYear,\n            html = '<div class=\"pika-title\">',\n            monthHtml,\n            yearHtml,\n            prev = true,\n            next = true;\n\n        for (arr = [], i = 0; i < 12; i++) {\n            arr.push('<option value=\"' + (year === refYear ? i - c : 12 + i - c) + '\"' +\n                (i === month ? ' selected': '') +\n                ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled' : '') + '>' +\n                opts.i18n.months[i] + '</option>');\n        }\n        monthHtml = '<div class=\"pika-label\">' + opts.i18n.months[month] + '<select class=\"pika-select pika-select-month\" tabindex=\"-1\">' + arr.join('') + '</select></div>';\n\n        if (isArray(opts.yearRange)) {\n            i = opts.yearRange[0];\n            j = opts.yearRange[1] + 1;\n        } else {\n            i = year - opts.yearRange;\n            j = 1 + year + opts.yearRange;\n        }\n\n        for (arr = []; i < j && i <= opts.maxYear; i++) {\n            if (i >= opts.minYear) {\n                arr.push('<option value=\"' + i + '\"' + (i === year ? ' selected': '') + '>' + (i) + '</option>');\n            }\n        }\n        yearHtml = '<div class=\"pika-label\">' + year + opts.yearSuffix + '<select class=\"pika-select pika-select-year\" tabindex=\"-1\">' + arr.join('') + '</select></div>';\n\n        if (opts.showMonthAfterYear) {\n            html += yearHtml + monthHtml;\n        } else {\n            html += monthHtml + yearHtml;\n        }\n\n        if (isMinYear && (month === 0 || opts.minMonth >= month)) {\n            prev = false;\n        }\n\n        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {\n            next = false;\n        }\n\n        if (c === 0) {\n            html += '<button class=\"pika-prev' + (prev ? '' : ' is-disabled') + '\" type=\"button\">' + opts.i18n.previousMonth + '</button>';\n        }\n        if (c === (instance._o.numberOfMonths - 1) ) {\n            html += '<button class=\"pika-next' + (next ? '' : ' is-disabled') + '\" type=\"button\">' + opts.i18n.nextMonth + '</button>';\n        }\n\n        return html += '</div>';\n    },\n\n    renderTable = function(opts, data)\n    {\n        return '<table cellpadding=\"0\" cellspacing=\"0\" class=\"pika-table\">' + renderHead(opts) + renderBody(data) + '</table>';\n    },\n\n\n    /**\n     * Pikaday constructor\n     */\n    Pikaday = function(options)\n    {\n        var self = this,\n            opts = self.config(options);\n\n        self._onMouseDown = function(e)\n        {\n            if (!self._v) {\n                return;\n            }\n            e = e || window.event;\n            var target = e.target || e.srcElement;\n            if (!target) {\n                return;\n            }\n\n            if (!hasClass(target, 'is-disabled')) {\n                if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty')) {\n                    self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));\n                    if (opts.bound) {\n                        sto(function() {\n                            self.hide();\n                            if (opts.field) {\n                                opts.field.blur();\n                            }\n                        }, 100);\n                    }\n                }\n                else if (hasClass(target, 'pika-prev')) {\n                    self.prevMonth();\n                }\n                else if (hasClass(target, 'pika-next')) {\n                    self.nextMonth();\n                }\n            }\n            if (!hasClass(target, 'pika-select')) {\n                // if this is touch event prevent mouse events emulation\n                if (e.preventDefault) {\n                    e.preventDefault();\n                } else {\n                    e.returnValue = false;\n                    return false;\n                }\n            } else {\n                self._c = true;\n            }\n        };\n\n        self._onChange = function(e)\n        {\n            e = e || window.event;\n            var target = e.target || e.srcElement;\n            if (!target) {\n                return;\n            }\n            if (hasClass(target, 'pika-select-month')) {\n                self.gotoMonth(target.value);\n            }\n            else if (hasClass(target, 'pika-select-year')) {\n                self.gotoYear(target.value);\n            }\n        };\n\n        self._onInputChange = function(e)\n        {\n            var date;\n\n            if (e.firedBy === self) {\n                return;\n            }\n            if (hasMoment) {\n                date = moment(opts.field.value, opts.format);\n                date = (date && date.isValid()) ? date.toDate() : null;\n            }\n            else {\n                date = new Date(Date.parse(opts.field.value));\n            }\n            if (isDate(date)) {\n              self.setDate(date);\n            }\n            if (!self._v) {\n                self.show();\n            }\n        };\n\n        self._onInputFocus = function()\n        {\n            self.show();\n        };\n\n        self._onInputClick = function()\n        {\n            self.show();\n        };\n\n        self._onInputBlur = function()\n        {\n            // IE allows pika div to gain focus; catch blur the input field\n            var pEl = document.activeElement;\n            do {\n                if (hasClass(pEl, 'pika-single')) {\n                    return;\n                }\n            }\n            while ((pEl = pEl.parentNode));\n\n            if (!self._c) {\n                self._b = sto(function() {\n                    self.hide();\n                }, 50);\n            }\n            self._c = false;\n        };\n\n        self._onClick = function(e)\n        {\n            e = e || window.event;\n            var target = e.target || e.srcElement,\n                pEl = target;\n            if (!target) {\n                return;\n            }\n            if (!hasEventListeners && hasClass(target, 'pika-select')) {\n                if (!target.onchange) {\n                    target.setAttribute('onchange', 'return;');\n                    addEvent(target, 'change', self._onChange);\n                }\n            }\n            do {\n                if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {\n                    return;\n                }\n            }\n            while ((pEl = pEl.parentNode));\n            if (self._v && target !== opts.trigger && pEl !== opts.trigger) {\n                self.hide();\n            }\n        };\n\n        self.el = document.createElement('div');\n        self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');\n\n        addEvent(self.el, 'mousedown', self._onMouseDown, true);\n        addEvent(self.el, 'touchend', self._onMouseDown, true);\n        addEvent(self.el, 'change', self._onChange);\n\n        if (opts.field) {\n            if (opts.container) {\n                opts.container.appendChild(self.el);\n            } else if (opts.bound) {\n                document.body.appendChild(self.el);\n            } else {\n                opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);\n            }\n            addEvent(opts.field, 'change', self._onInputChange);\n\n            if (!opts.defaultDate) {\n                if (hasMoment && opts.field.value) {\n                    opts.defaultDate = moment(opts.field.value, opts.format).toDate();\n                } else {\n                    opts.defaultDate = new Date(Date.parse(opts.field.value));\n                }\n                opts.setDefaultDate = true;\n            }\n        }\n\n        var defDate = opts.defaultDate;\n\n        if (isDate(defDate)) {\n            if (opts.setDefaultDate) {\n                self.setDate(defDate, true);\n            } else {\n                self.gotoDate(defDate);\n            }\n        } else {\n            self.gotoDate(new Date());\n        }\n\n        if (opts.bound) {\n            this.hide();\n            self.el.className += ' is-bound';\n            addEvent(opts.trigger, 'click', self._onInputClick);\n            addEvent(opts.trigger, 'focus', self._onInputFocus);\n            addEvent(opts.trigger, 'blur', self._onInputBlur);\n        } else {\n            this.show();\n        }\n    };\n\n\n    /**\n     * public Pikaday API\n     */\n    Pikaday.prototype = {\n\n\n        /**\n         * configure functionality\n         */\n        config: function(options)\n        {\n            if (!this._o) {\n                this._o = extend({}, defaults, true);\n            }\n\n            var opts = extend(this._o, options, true);\n\n            opts.isRTL = !!opts.isRTL;\n\n            opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;\n\n            opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;\n\n            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);\n\n            opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;\n\n            opts.disableWeekends = !!opts.disableWeekends;\n\n            opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;\n\n            var nom = parseInt(opts.numberOfMonths, 10) || 1;\n            opts.numberOfMonths = nom > 4 ? 4 : nom;\n\n            if (!isDate(opts.minDate)) {\n                opts.minDate = false;\n            }\n            if (!isDate(opts.maxDate)) {\n                opts.maxDate = false;\n            }\n            if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {\n                opts.maxDate = opts.minDate = false;\n            }\n            if (opts.minDate) {\n                this.setMinDate(opts.minDate);\n            }\n            if (opts.maxDate) {\n                this.setMaxDate(opts.maxDate);\n            }\n\n            if (isArray(opts.yearRange)) {\n                var fallback = new Date().getFullYear() - 10;\n                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;\n                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;\n            } else {\n                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;\n                if (opts.yearRange > 100) {\n                    opts.yearRange = 100;\n                }\n            }\n\n            return opts;\n        },\n\n        /**\n         * return a formatted string of the current selection (using Moment.js if available)\n         */\n        toString: function(format)\n        {\n            return !isDate(this._d) ? '' : hasMoment ? moment(this._d).format(format || this._o.format) : this._d.toDateString();\n        },\n\n        /**\n         * return a Moment.js object of the current selection (if available)\n         */\n        getMoment: function()\n        {\n            return hasMoment ? moment(this._d) : null;\n        },\n\n        /**\n         * set the current selection from a Moment.js object (if available)\n         */\n        setMoment: function(date, preventOnSelect)\n        {\n            if (hasMoment && moment.isMoment(date)) {\n                this.setDate(date.toDate(), preventOnSelect);\n            }\n        },\n\n        /**\n         * return a Date object of the current selection\n         */\n        getDate: function()\n        {\n            return isDate(this._d) ? new Date(this._d.getTime()) : null;\n        },\n\n        /**\n         * set the current selection\n         */\n        setDate: function(date, preventOnSelect)\n        {\n            if (!date) {\n                this._d = null;\n\n                if (this._o.field) {\n                    this._o.field.value = '';\n                    fireEvent(this._o.field, 'change', { firedBy: this });\n                }\n\n                return this.draw();\n            }\n            if (typeof date === 'string') {\n                date = new Date(Date.parse(date));\n            }\n            if (!isDate(date)) {\n                return;\n            }\n\n            var min = this._o.minDate,\n                max = this._o.maxDate;\n\n            if (isDate(min) && date < min) {\n                date = min;\n            } else if (isDate(max) && date > max) {\n                date = max;\n            }\n\n            this._d = new Date(date.getTime());\n            setToStartOfDay(this._d);\n            this.gotoDate(this._d);\n\n            if (this._o.field) {\n                this._o.field.value = this.toString();\n                fireEvent(this._o.field, 'change', { firedBy: this });\n            }\n            if (!preventOnSelect && typeof this._o.onSelect === 'function') {\n                this._o.onSelect.call(this, this.getDate());\n            }\n        },\n\n        /**\n         * change view to a specific date\n         */\n        gotoDate: function(date)\n        {\n            var newCalendar = true;\n\n            if (!isDate(date)) {\n                return;\n            }\n\n            if (this.calendars) {\n                var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),\n                    lastVisibleDate = new Date(this.calendars[this.calendars.length-1].year, this.calendars[this.calendars.length-1].month, 1),\n                    visibleDate = date.getTime();\n                // get the end of the month\n                lastVisibleDate.setMonth(lastVisibleDate.getMonth()+1);\n                lastVisibleDate.setDate(lastVisibleDate.getDate()-1);\n                newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);\n            }\n\n            if (newCalendar) {\n                this.calendars = [{\n                    month: date.getMonth(),\n                    year: date.getFullYear()\n                }];\n                if (this._o.mainCalendar === 'right') {\n                    this.calendars[0].month += 1 - this._o.numberOfMonths;\n                }\n            }\n\n            this.adjustCalendars();\n        },\n\n        adjustCalendars: function() {\n            this.calendars[0] = adjustCalendar(this.calendars[0]);\n            for (var c = 1; c < this._o.numberOfMonths; c++) {\n                this.calendars[c] = adjustCalendar({\n                    month: this.calendars[0].month + c,\n                    year: this.calendars[0].year\n                });\n            }\n            this.draw();\n        },\n\n        gotoToday: function()\n        {\n            this.gotoDate(new Date());\n        },\n\n        /**\n         * change view to a specific month (zero-index, e.g. 0: January)\n         */\n        gotoMonth: function(month)\n        {\n            if (!isNaN(month)) {\n                this.calendars[0].month = parseInt(month, 10);\n                this.adjustCalendars();\n            }\n        },\n\n        nextMonth: function()\n        {\n            this.calendars[0].month++;\n            this.adjustCalendars();\n        },\n\n        prevMonth: function()\n        {\n            this.calendars[0].month--;\n            this.adjustCalendars();\n        },\n\n        /**\n         * change view to a specific full year (e.g. \"2012\")\n         */\n        gotoYear: function(year)\n        {\n            if (!isNaN(year)) {\n                this.calendars[0].year = parseInt(year, 10);\n                this.adjustCalendars();\n            }\n        },\n\n        /**\n         * change the minDate\n         */\n        setMinDate: function(value)\n        {\n            setToStartOfDay(value);\n            this._o.minDate = value;\n            this._o.minYear  = value.getFullYear();\n            this._o.minMonth = value.getMonth();\n            this.draw();\n        },\n\n        /**\n         * change the maxDate\n         */\n        setMaxDate: function(value)\n        {\n            setToStartOfDay(value);\n            this._o.maxDate = value;\n            this._o.maxYear = value.getFullYear();\n            this._o.maxMonth = value.getMonth();\n            this.draw();\n        },\n\n        setStartRange: function(value)\n        {\n            this._o.startRange = value;\n        },\n\n        setEndRange: function(value)\n        {\n            this._o.endRange = value;\n        },\n\n        /**\n         * refresh the HTML\n         */\n        draw: function(force)\n        {\n            if (!this._v && !force) {\n                return;\n            }\n            var opts = this._o,\n                minYear = opts.minYear,\n                maxYear = opts.maxYear,\n                minMonth = opts.minMonth,\n                maxMonth = opts.maxMonth,\n                html = '';\n\n            if (this._y <= minYear) {\n                this._y = minYear;\n                if (!isNaN(minMonth) && this._m < minMonth) {\n                    this._m = minMonth;\n                }\n            }\n            if (this._y >= maxYear) {\n                this._y = maxYear;\n                if (!isNaN(maxMonth) && this._m > maxMonth) {\n                    this._m = maxMonth;\n                }\n            }\n\n            for (var c = 0; c < opts.numberOfMonths; c++) {\n                html += '<div class=\"pika-lendar\">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year) + this.render(this.calendars[c].year, this.calendars[c].month) + '</div>';\n            }\n\n            this.el.innerHTML = html;\n\n            if (opts.bound) {\n                if(opts.field.type !== 'hidden') {\n                    sto(function() {\n                        opts.trigger.focus();\n                    }, 1);\n                }\n            }\n\n            if (typeof this._o.onDraw === 'function') {\n                var self = this;\n                sto(function() {\n                    self._o.onDraw.call(self);\n                }, 0);\n            }\n        },\n\n        adjustPosition: function()\n        {\n            var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect;\n\n            if (this._o.container) return;\n\n            this.el.style.position = 'absolute';\n\n            field = this._o.trigger;\n            pEl = field;\n            width = this.el.offsetWidth;\n            height = this.el.offsetHeight;\n            viewportWidth = window.innerWidth || document.documentElement.clientWidth;\n            viewportHeight = window.innerHeight || document.documentElement.clientHeight;\n            scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;\n\n            if (typeof field.getBoundingClientRect === 'function') {\n                clientRect = field.getBoundingClientRect();\n                left = clientRect.left + window.pageXOffset;\n                top = clientRect.bottom + window.pageYOffset;\n            } else {\n                left = pEl.offsetLeft;\n                top  = pEl.offsetTop + pEl.offsetHeight;\n                while((pEl = pEl.offsetParent)) {\n                    left += pEl.offsetLeft;\n                    top  += pEl.offsetTop;\n                }\n            }\n\n            // default position is bottom & left\n            if ((this._o.reposition && left + width > viewportWidth) ||\n                (\n                    this._o.position.indexOf('right') > -1 &&\n                    left - width + field.offsetWidth > 0\n                )\n            ) {\n                left = left - width + field.offsetWidth;\n            }\n            if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||\n                (\n                    this._o.position.indexOf('top') > -1 &&\n                    top - height - field.offsetHeight > 0\n                )\n            ) {\n                top = top - height - field.offsetHeight;\n            }\n\n            this.el.style.left = left + 'px';\n            this.el.style.top = top + 'px';\n        },\n\n        /**\n         * render HTML for a particular month\n         */\n        render: function(year, month)\n        {\n            var opts   = this._o,\n                now    = new Date(),\n                days   = getDaysInMonth(year, month),\n                before = new Date(year, month, 1).getDay(),\n                data   = [],\n                row    = [];\n            setToStartOfDay(now);\n            if (opts.firstDay > 0) {\n                before -= opts.firstDay;\n                if (before < 0) {\n                    before += 7;\n                }\n            }\n            var cells = days + before,\n                after = cells;\n            while(after > 7) {\n                after -= 7;\n            }\n            cells += 7 - after;\n            for (var i = 0, r = 0; i < cells; i++)\n            {\n                var day = new Date(year, month, 1 + (i - before)),\n                    isSelected = isDate(this._d) ? compareDates(day, this._d) : false,\n                    isToday = compareDates(day, now),\n                    isEmpty = i < before || i >= (days + before),\n                    isStartRange = opts.startRange && compareDates(opts.startRange, day),\n                    isEndRange = opts.endRange && compareDates(opts.endRange, day),\n                    isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,\n                    isDisabled = (opts.minDate && day < opts.minDate) ||\n                                 (opts.maxDate && day > opts.maxDate) ||\n                                 (opts.disableWeekends && isWeekend(day)) ||\n                                 (opts.disableDayFn && opts.disableDayFn(day)),\n                    dayConfig = {\n                        day: 1 + (i - before),\n                        month: month,\n                        year: year,\n                        isSelected: isSelected,\n                        isToday: isToday,\n                        isDisabled: isDisabled,\n                        isEmpty: isEmpty,\n                        isStartRange: isStartRange,\n                        isEndRange: isEndRange,\n                        isInRange: isInRange\n                    };\n\n                row.push(renderDay(dayConfig));\n\n                if (++r === 7) {\n                    if (opts.showWeekNumber) {\n                        row.unshift(renderWeek(i - before, month, year));\n                    }\n                    data.push(renderRow(row, opts.isRTL));\n                    row = [];\n                    r = 0;\n                }\n            }\n            return renderTable(opts, data);\n        },\n\n        isVisible: function()\n        {\n            return this._v;\n        },\n\n        show: function()\n        {\n            if (!this._v) {\n                removeClass(this.el, 'is-hidden');\n                this._v = true;\n                this.draw();\n                if (this._o.bound) {\n                    addEvent(document, 'click', this._onClick);\n                    this.adjustPosition();\n                }\n                if (typeof this._o.onOpen === 'function') {\n                    this._o.onOpen.call(this);\n                }\n            }\n        },\n\n        hide: function()\n        {\n            var v = this._v;\n            if (v !== false) {\n                if (this._o.bound) {\n                    removeEvent(document, 'click', this._onClick);\n                }\n                this.el.style.position = 'static'; // reset\n                this.el.style.left = 'auto';\n                this.el.style.top = 'auto';\n                addClass(this.el, 'is-hidden');\n                this._v = false;\n                if (v !== undefined && typeof this._o.onClose === 'function') {\n                    this._o.onClose.call(this);\n                }\n            }\n        },\n\n        /**\n         * GAME OVER\n         */\n        destroy: function()\n        {\n            this.hide();\n            removeEvent(this.el, 'mousedown', this._onMouseDown, true);\n            removeEvent(this.el, 'touchend', this._onMouseDown, true);\n            removeEvent(this.el, 'change', this._onChange);\n            if (this._o.field) {\n                removeEvent(this._o.field, 'change', this._onInputChange);\n                if (this._o.bound) {\n                    removeEvent(this._o.trigger, 'click', this._onInputClick);\n                    removeEvent(this._o.trigger, 'focus', this._onInputFocus);\n                    removeEvent(this._o.trigger, 'blur', this._onInputBlur);\n                }\n            }\n            if (this.el.parentNode) {\n                this.el.parentNode.removeChild(this.el);\n            }\n        }\n\n    };\n\n    return Pikaday;\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pikaday/pikaday.js\n ** module id = 8\n ** module chunks = 0\n **/","'use strict';\n/* istanbul ignore if */\nexports.Promise = require('pouchdb-promise');\n\nexports.inherits = require('inherits');\nexports.extend = require('pouchdb-extend');\nvar argsarray = require('argsarray');\n\n/* istanbul ignore next */\nexports.promisedCallback = function (promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      process.nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      process.nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n};\n\n/* istanbul ignore next */\nexports.callbackify = function (fun) {\n  return argsarray(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      exports.promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n};\n\n// Promise finally util similar to Q.finally\n/* istanbul ignore next */\nexports.fin = function (promise, cb) {\n  return promise.then(function (res) {\n    var promise2 = cb();\n    if (typeof promise2.then === 'function') {\n      return promise2.then(function () {\n        return res;\n      });\n    }\n    return res;\n  }, function (reason) {\n    var promise2 = cb();\n    if (typeof promise2.then === 'function') {\n      return promise2.then(function () {\n        throw reason;\n      });\n    }\n    throw reason;\n  });\n};\n\nexports.sequentialize = function (queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n};\n\nexports.flatten = function (arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n};\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nexports.uniq = function (arr) {\n  var map = {};\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    map['$' + arr[i]] = true;\n  }\n\n  var keys = Object.keys(map);\n  var output = new Array(keys.length);\n\n  for (i = 0, len = keys.length; i < len; i++) {\n    output[i] = keys[i].substring(1);\n  }\n  return output;\n};\n\nvar crypto = require('crypto');\nvar Md5 = require('spark-md5');\n\nexports.MD5 = function (string) {\n  /* istanbul ignore else */\n  if (!process.browser) {\n    return crypto.createHash('md5').update(string).digest('hex');\n  } else {\n    return Md5.hash(string);\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/abstract-mapreduce/utils.js\n ** module id = 9\n ** module chunks = 0\n **/","'use strict';\n\nvar localUtils = require('./utils');\nvar abstractMapReduce = require('../../abstract-mapreduce');\nvar parseField = localUtils.parseField;\n\n//\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\n\nfunction createDeepMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = parseField(fields[i]);\n      var value = doc;\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n        if (!value) {\n          break;\n        }\n      }\n      toEmit.push(value);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction createDeepSingleMapper(field, emit) {\n  var parsedField = parseField(field);\n  return function (doc) {\n    var value = doc;\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n      if (!value) {\n        return; // do nothing\n      }\n    }\n    emit(value);\n  };\n}\n\nfunction createShallowSingleMapper(field, emit) {\n  return function (doc) {\n    emit(doc[field]);\n  };\n}\n\nfunction createShallowMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createMapper(fields, emit) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1;\n\n  // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit);\n    } else { // multi\n      return createShallowMultiMapper(fields, emit);\n    }\n  } else { // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit);\n    } else { // multi\n      return createDeepMultiMapper(fields, emit);\n    }\n  }\n}\n\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n\n  var fields = Object.keys(mapFunDef.fields);\n\n  return createMapper(fields, emit);\n}\n\n/* istanbul ignore next */\nfunction reducer(/*reduceFunDef*/) {\n  throw new Error('reduce not supported');\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName];\n  // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n  /* istanbul ignore if */\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +\n      ' doesn\\'t have map.fields defined. ' +\n      'maybe it wasn\\'t created by this plugin?');\n  }\n}\n\nvar abstractMapper = abstractMapReduce({\n  name: 'indexes',\n  mapper: mapper,\n  reducer: reducer,\n  ddocValidator: ddocValidator\n});\n\nmodule.exports = abstractMapper;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/adapters/local/abstract-mapper.js\n ** module id = 10\n ** module chunks = 0\n **/","'use strict';\n\nvar upsert = require('pouchdb-upsert').upsert;\n\nmodule.exports = function (db, doc, diffFun) {\n  return upsert.apply(db, [doc, diffFun]);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/abstract-mapreduce/upsert.js\n ** module id = 11\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('../../../utils');\n\nvar localUtils = require('../utils');\nvar massageIndexDef = localUtils.massageIndexDef;\n\nfunction getIndexes(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: '_design/\\uffff',\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{_id: 'asc'}]\n        }\n      }]\n    };\n\n    res.indexes = utils.flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    }));\n\n    // these are sorted by view name for some reason\n    res.indexes.sort(function (left, right) {\n      return utils.compare(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n}\n\nmodule.exports = getIndexes;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/adapters/local/get-indexes/index.js\n ** module id = 12\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('./utils');\n\nvar httpIndexes = require('./adapters/http');\nvar localIndexes = require('./adapters/local');\n\nvar plugin = {};\nplugin.createIndex = utils.toPromise(function (requestDef, callback) {\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n\n  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\n  adapter.createIndex(this, requestDef, callback);\n});\n\nplugin.find = utils.toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n\n  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\n  adapter.find(this, requestDef, callback);\n});\n\nplugin.getIndexes = utils.toPromise(function (callback) {\n\n  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\n  adapter.getIndexes(this, callback);\n});\n\nplugin.deleteIndex = utils.toPromise(function (indexDef, callback) {\n\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n\n  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\n  adapter.deleteIndex(this, indexDef, callback);\n});\n\nmodule.exports = plugin;\n\n/* istanbul ignore next */\nif (typeof window !== 'undefined' && window.PouchDB) {\n  window.PouchDB.plugin(plugin);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/index.js\n ** module id = 13\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('./utils');\nvar clone = utils.clone;\n\n// we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\nmodule.exports = function (requestDef) {\n  requestDef = clone(requestDef);\n\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n  return requestDef;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/massageCreateIndexRequest.js\n ** module id = 14\n ** module chunks = 0\n **/","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/inherits/inherits_browser.js\n ** module id = 15\n ** module chunks = 0\n **/","\"use strict\";\n\n// Extends method\n// (taken from http://code.jquery.com/jquery-1.9.0.js)\n// Populate the class2type map\nvar class2type = {};\n\nvar types = [\n  \"Boolean\", \"Number\", \"String\", \"Function\", \"Array\",\n  \"Date\", \"RegExp\", \"Object\", \"Error\"\n];\nfor (var i = 0; i < types.length; i++) {\n  var typename = types[i];\n  class2type[\"[object \" + typename + \"]\"] = typename.toLowerCase();\n}\n\nvar core_toString = class2type.toString;\nvar core_hasOwn = class2type.hasOwnProperty;\n\nfunction type(obj) {\n  if (obj === null) {\n    return String(obj);\n  }\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\n    class2type[core_toString.call(obj)] || \"object\" :\n    typeof obj;\n}\n\nfunction isWindow(obj) {\n  return obj !== null && obj === obj.window;\n}\n\nfunction isPlainObject(obj) {\n  // Must be an Object.\n  // Because of IE, we also have to check the presence of\n  // the constructor property.\n  // Make sure that DOM nodes and window objects don't pass through, as well\n  if (!obj || type(obj) !== \"object\" || obj.nodeType || isWindow(obj)) {\n    return false;\n  }\n\n  try {\n    // Not own constructor property must be Object\n    if (obj.constructor &&\n      !core_hasOwn.call(obj, \"constructor\") &&\n      !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n      return false;\n    }\n  } catch ( e ) {\n    // IE8,9 Will throw exceptions on certain host objects #9897\n    return false;\n  }\n\n  // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n  var key;\n  for (key in obj) {}\n\n  return key === undefined || core_hasOwn.call(obj, key);\n}\n\n\nfunction isFunction(obj) {\n  return type(obj) === \"function\";\n}\n\nvar isArray = Array.isArray || function (obj) {\n  return type(obj) === \"array\";\n};\n\nfunction extend() {\n  // originally extend() was recursive, but this ended up giving us\n  // \"call stack exceeded\", so it's been unrolled to use a literal stack\n  // (see https://github.com/pouchdb/pouchdb/issues/2543)\n  var stack = [];\n  var i = -1;\n  var len = arguments.length;\n  var args = new Array(len);\n  while (++i < len) {\n    args[i] = arguments[i];\n  }\n  var container = {};\n  stack.push({args: args, result: {container: container, key: 'key'}});\n  var next;\n  while ((next = stack.pop())) {\n    extendInner(stack, next.args, next.result);\n  }\n  return container.key;\n}\n\nfunction extendInner(stack, args, result) {\n  var options, name, src, copy, copyIsArray, clone,\n    target = args[0] || {},\n    i = 1,\n    length = args.length,\n    deep = false,\n    numericStringRegex = /\\d+/,\n    optionsIsArray;\n\n  // Handle a deep copy situation\n  if (typeof target === \"boolean\") {\n    deep = target;\n    target = args[1] || {};\n    // skip the boolean and the target\n    i = 2;\n  }\n\n  // Handle case when target is a string or something (possible in deep copy)\n  if (typeof target !== \"object\" && !isFunction(target)) {\n    target = {};\n  }\n\n  // extend jQuery itself if only one argument is passed\n  if (length === i) {\n    /* jshint validthis: true */\n    target = this;\n    --i;\n  }\n\n  for (; i < length; i++) {\n    // Only deal with non-null/undefined values\n    if ((options = args[i]) != null) {\n      optionsIsArray = isArray(options);\n      // Extend the base object\n      for (name in options) {\n        //if (options.hasOwnProperty(name)) {\n        if (!(name in Object.prototype)) {\n          if (optionsIsArray && !numericStringRegex.test(name)) {\n            continue;\n          }\n\n          src = target[name];\n          copy = options[name];\n\n          // Prevent never-ending loop\n          if (target === copy) {\n            continue;\n          }\n\n          // Recurse if we're merging plain objects or arrays\n          if (deep && copy && (isPlainObject(copy) ||\n              (copyIsArray = isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && isArray(src) ? src : [];\n\n            } else {\n              clone = src && isPlainObject(src) ? src : {};\n            }\n\n            // Never move original objects, clone them\n            stack.push({\n              args: [deep, clone, copy],\n              result: {\n                container: target,\n                key: name\n              }\n            });\n\n          // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            if (!(isArray(options) && isFunction(copy))) {\n              target[name] = copy;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // \"Return\" the modified object by setting the key\n  // on the given container\n  result.container[result.key] = target;\n}\n\n\nmodule.exports = extend;\n\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/pouchdb-extend/index.js\n ** module id = 16\n ** module chunks = 0\n **/","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(require('lie'));\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\nmodule.exports = PouchPromise;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/pouchdb-promise/lib/index.js\n ** module id = 17\n ** module chunks = 0\n **/","'use strict';\n\nvar PouchPromise = require('pouchdb-promise');\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsertInner(db, docId, diffFun) {\n  if (typeof docId !== 'string') {\n    return PouchPromise.reject(new Error('doc id is required'));\n  }\n\n  return db.get(docId).catch(function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 404) {\n      throw err;\n    }\n    return {};\n  }).then(function (doc) {\n    // the user might change the _rev, so save it for posterity\n    var docRev = doc._rev;\n    var newDoc = diffFun(doc);\n\n    if (!newDoc) {\n      // if the diffFun returns falsy, we short-circuit as\n      // an optimization\n      return { updated: false, rev: docRev };\n    }\n\n    // users aren't allowed to modify these values,\n    // so reset them here\n    newDoc._id = docId;\n    newDoc._rev = docRev;\n    return tryAndPut(db, newDoc, diffFun);\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsertInner(db, doc._id, diffFun);\n  });\n}\n\nexports.upsert = function upsert(docId, diffFun, cb) {\n  var db = this;\n  var promise = upsertInner(db, docId, diffFun);\n  if (typeof cb !== 'function') {\n    return promise;\n  }\n  promise.then(function (resp) {\n    cb(null, resp);\n  }, cb);\n};\n\nexports.putIfNotExists = function putIfNotExists(docId, doc, cb) {\n  var db = this;\n\n  if (typeof docId !== 'string') {\n    cb = doc;\n    doc = docId;\n    docId = doc._id;\n  }\n\n  var diffFun = function (existingDoc) {\n    if (existingDoc._rev) {\n      return false; // do nothing\n    }\n    return doc;\n  };\n\n  var promise = upsertInner(db, docId, diffFun);\n  if (typeof cb !== 'function') {\n    return promise;\n  }\n  promise.then(function (resp) {\n    cb(null, resp);\n  }, cb);\n};\n\n\n/* istanbul ignore next */\nif (typeof window !== 'undefined' && window.PouchDB) {\n  window.PouchDB.plugin(exports);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/pouchdb-upsert/index.js\n ** module id = 18\n ** module chunks = 0\n **/","/*jshint bitwise:false*/\n/*global unescape*/\n\n(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    /*\n     * Fastest md5 implementation around (JKM md5)\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n\n    cmn = function (q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    },\n\n    ff = function (a, b, c, d, x, s, t) {\n        return cmn((b & c) | ((~b) & d), a, b, x, s, t);\n    },\n\n    gg = function (a, b, c, d, x, s, t) {\n        return cmn((b & d) | (c & (~d)), a, b, x, s, t);\n    },\n\n    hh = function (a, b, c, d, x, s, t) {\n        return cmn(b ^ c ^ d, a, b, x, s, t);\n    },\n\n    ii = function (a, b, c, d, x, s, t) {\n        return cmn(c ^ (b | (~d)), a, b, x, s, t);\n    },\n\n    md5cycle = function (x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a = ff(a, b, c, d, k[0], 7, -680876936);\n        d = ff(d, a, b, c, k[1], 12, -389564586);\n        c = ff(c, d, a, b, k[2], 17, 606105819);\n        b = ff(b, c, d, a, k[3], 22, -1044525330);\n        a = ff(a, b, c, d, k[4], 7, -176418897);\n        d = ff(d, a, b, c, k[5], 12, 1200080426);\n        c = ff(c, d, a, b, k[6], 17, -1473231341);\n        b = ff(b, c, d, a, k[7], 22, -45705983);\n        a = ff(a, b, c, d, k[8], 7, 1770035416);\n        d = ff(d, a, b, c, k[9], 12, -1958414417);\n        c = ff(c, d, a, b, k[10], 17, -42063);\n        b = ff(b, c, d, a, k[11], 22, -1990404162);\n        a = ff(a, b, c, d, k[12], 7, 1804603682);\n        d = ff(d, a, b, c, k[13], 12, -40341101);\n        c = ff(c, d, a, b, k[14], 17, -1502002290);\n        b = ff(b, c, d, a, k[15], 22, 1236535329);\n\n        a = gg(a, b, c, d, k[1], 5, -165796510);\n        d = gg(d, a, b, c, k[6], 9, -1069501632);\n        c = gg(c, d, a, b, k[11], 14, 643717713);\n        b = gg(b, c, d, a, k[0], 20, -373897302);\n        a = gg(a, b, c, d, k[5], 5, -701558691);\n        d = gg(d, a, b, c, k[10], 9, 38016083);\n        c = gg(c, d, a, b, k[15], 14, -660478335);\n        b = gg(b, c, d, a, k[4], 20, -405537848);\n        a = gg(a, b, c, d, k[9], 5, 568446438);\n        d = gg(d, a, b, c, k[14], 9, -1019803690);\n        c = gg(c, d, a, b, k[3], 14, -187363961);\n        b = gg(b, c, d, a, k[8], 20, 1163531501);\n        a = gg(a, b, c, d, k[13], 5, -1444681467);\n        d = gg(d, a, b, c, k[2], 9, -51403784);\n        c = gg(c, d, a, b, k[7], 14, 1735328473);\n        b = gg(b, c, d, a, k[12], 20, -1926607734);\n\n        a = hh(a, b, c, d, k[5], 4, -378558);\n        d = hh(d, a, b, c, k[8], 11, -2022574463);\n        c = hh(c, d, a, b, k[11], 16, 1839030562);\n        b = hh(b, c, d, a, k[14], 23, -35309556);\n        a = hh(a, b, c, d, k[1], 4, -1530992060);\n        d = hh(d, a, b, c, k[4], 11, 1272893353);\n        c = hh(c, d, a, b, k[7], 16, -155497632);\n        b = hh(b, c, d, a, k[10], 23, -1094730640);\n        a = hh(a, b, c, d, k[13], 4, 681279174);\n        d = hh(d, a, b, c, k[0], 11, -358537222);\n        c = hh(c, d, a, b, k[3], 16, -722521979);\n        b = hh(b, c, d, a, k[6], 23, 76029189);\n        a = hh(a, b, c, d, k[9], 4, -640364487);\n        d = hh(d, a, b, c, k[12], 11, -421815835);\n        c = hh(c, d, a, b, k[15], 16, 530742520);\n        b = hh(b, c, d, a, k[2], 23, -995338651);\n\n        a = ii(a, b, c, d, k[0], 6, -198630844);\n        d = ii(d, a, b, c, k[7], 10, 1126891415);\n        c = ii(c, d, a, b, k[14], 15, -1416354905);\n        b = ii(b, c, d, a, k[5], 21, -57434055);\n        a = ii(a, b, c, d, k[12], 6, 1700485571);\n        d = ii(d, a, b, c, k[3], 10, -1894986606);\n        c = ii(c, d, a, b, k[10], 15, -1051523);\n        b = ii(b, c, d, a, k[1], 21, -2054922799);\n        a = ii(a, b, c, d, k[8], 6, 1873313359);\n        d = ii(d, a, b, c, k[15], 10, -30611744);\n        c = ii(c, d, a, b, k[6], 15, -1560198380);\n        b = ii(b, c, d, a, k[13], 21, 1309151649);\n        a = ii(a, b, c, d, k[4], 6, -145523070);\n        d = ii(d, a, b, c, k[11], 10, -1120210379);\n        c = ii(c, d, a, b, k[2], 15, 718787259);\n        b = ii(b, c, d, a, k[9], 21, -343485551);\n\n        x[0] = add32(a, x[0]);\n        x[1] = add32(b, x[1]);\n        x[2] = add32(c, x[2]);\n        x[3] = add32(d, x[3]);\n    },\n\n    /* there needs to be support for Unicode here,\n       * unless we pretend that we can redefine the MD-5\n       * algorithm for multi-byte characters (perhaps\n       * by adding every four 16-bit characters and\n       * shortening the sum to 32 bits). Otherwise\n       * I suggest performing MD-5 as if every character\n       * was two bytes--e.g., 0040 0025 = @%--but then\n       * how will an ordinary MD-5 sum be matched?\n       * There is no way to standardize text to something\n       * like UTF-8 before transformation; speed cost is\n       * utterly prohibitive. The JavaScript standard\n       * itself needs to look at this: it should start\n       * providing access to strings as preformed UTF-8\n       * 8-bit unsigned value arrays.\n       */\n    md5blk = function (s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    },\n\n    md5blk_array = function (a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    },\n\n    md51 = function (s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    },\n\n    md51_array = function (a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    },\n\n    hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'],\n\n    rhex = function (n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    },\n\n    hex = function (x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    },\n\n    md5 = function (s) {\n        return hex(md51(s));\n    },\n\n\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n    SparkMD5 = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n\n    // In some cases the fast add32 function cannot be used..\n    if (md5('hello') !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // converts the string to utf8 bytes if necessary\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        // then append as binary\n        this.appendBinary(str);\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._state, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substr(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     * Use the raw parameter to obtain the raw result instead of the hex one.\n     *\n     * @param {Boolean} raw True to get the raw result, false to get the hex result\n     *\n     * @return {String|Array} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = !!raw ? this._state : hex(this._state);\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._state, tail);\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = \"\";\n        this._length = 0;\n        this._state = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other aditional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._state;\n        delete this._buff;\n        delete this._length;\n    };\n\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw result, false to get the hex result\n     *\n     * @return {String|Array} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // converts the string to utf8 bytes if necessary\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        var hash = md51(str);\n\n        return !!raw ? hash : hex(hash);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw result, false to get the hex result\n     *\n     * @return {String|Array} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content);\n\n        return !!raw ? hash : hex(hash);\n    };\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        // TODO: we could avoid the concatenation here but the algorithm would be more complex\n        //       if you find yourself needing extra performance, please make a PR.\n        var buff = this._concatArrayBuffer(this._buff, arr),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._state, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        // Avoids IE10 weirdness (documented above)\n        this._buff = (i - 64) < length ? buff.subarray(i - 64) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     * Use the raw parameter to obtain the raw result instead of the hex one.\n     *\n     * @param {Boolean} raw True to get the raw result, false to get the hex result\n     *\n     * @return {String|Array} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = !!raw ? this._state : hex(this._state);\n\n        this.reset();\n\n        return ret;\n    };\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._state = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other aditional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    /**\n     * Concats two array buffers, returning a new one.\n     *\n     * @param  {ArrayBuffer} first  The first array buffer\n     * @param  {ArrayBuffer} second The second array buffer\n     *\n     * @return {ArrayBuffer} The new array buffer\n     */\n    SparkMD5.ArrayBuffer.prototype._concatArrayBuffer = function (first, second) {\n        var firstLength = first.length,\n            result = new Uint8Array(firstLength + second.byteLength);\n\n        result.set(first);\n        result.set(new Uint8Array(second), firstLength);\n\n        return result;\n    };\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw result, false to get the hex result\n     *\n     * @return {String|Array} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr));\n\n        return !!raw ? hash : hex(hash);\n    };\n\n    return SparkMD5;\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/spark-md5/spark-md5.js\n ** module id = 19\n ** module chunks = 0\n **/","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(require('lie'));\nvar getArguments = _interopDefault(require('argsarray'));\nvar debug = _interopDefault(require('debug'));\nvar events = require('events');\nvar inherits = _interopDefault(require('inherits'));\nvar scopedEval = _interopDefault(require('scope-eval'));\nvar Md5 = _interopDefault(require('spark-md5'));\nvar vuvuzela = _interopDefault(require('vuvuzela'));\nvar PromisePool = _interopDefault(require('es6-promise-pool'));\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    var tempCB =\n      (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    // if the last argument is a function, assume its a callback\n    var usedCB;\n    if (tempCB) {\n      // if it was a callback, create a new callback which calls it,\n      // but do so async so we don't trap any errors\n      usedCB = function (err, resp) {\n        process.nextTick(function () {\n          tempCB(err, resp);\n        });\n      };\n    }\n    var promise = new PouchPromise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nvar log = debug('pouchdb:api');\n\nfunction adapterFun(name, callback) {\n  function logApiCall(self, name, args) {\n    /* istanbul ignore if */\n    if (log.enabled) {\n      var logArgs = [self.name, name];\n      for (var i = 0; i < args.length - 1; i++) {\n        logArgs.push(args[i]);\n      }\n      log.apply(null, logArgs);\n\n      // override the callback itself to log the response\n      var origCallback = args[args.length - 1];\n      args[args.length - 1] = function (err, res) {\n        var responseArgs = [self.name, name];\n        responseArgs = responseArgs.concat(\n          err ? ['error', err] : ['success', res]\n        );\n        log.apply(null, responseArgs);\n        origCallback(err, res);\n      };\n    }\n  }\n\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return PouchPromise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return PouchPromise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new PouchPromise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = {};\n  requests.forEach(function (request) {\n    if (request.id in requestsById) {\n      requestsById[request.id].push(request);\n    } else {\n      requestsById[request.id] = [request];\n    }\n  });\n\n  var numDocs = Object.keys(requestsById).length;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = Object.keys(requestsById);\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById[docId];\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n    typeof chrome.storage !== \"undefined\" &&\n    typeof chrome.storage.local !== \"undefined\");\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\ninherits(Changes, events.EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else { // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  events.EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        setTimeout(function (){\n          eventFunction();\n        },0);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  events.EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({dbName: dbName});\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (console !== 'undefined' && method in console) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if(max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\n// forked from\n// https://github.com/vmattos/js-extend/blob/7023fd69a9e9552688086b8b8006b1fcf916a306/extend.js\n// TODO: I don't know why we have two different extend() functions in PouchDB\n\nvar slice = Array.prototype.slice;\nvar each = Array.prototype.forEach;\n\nfunction extend$1(obj) {\n  if (typeof obj !== 'object') {\n    throw obj + ' is not an object' ;\n  }\n\n  var sources = slice.call(arguments, 1);\n\n  each.call(sources, function (source) {\n    if (source) {\n      for (var prop in source) {\n        if (typeof source[prop] === 'object' && obj[prop]) {\n          extend$1.call(obj, obj[prop], source[prop]);\n        } else {\n          obj[prop] = source[prop];\n        }\n      }\n    }\n  });\n\n  return obj;\n}\n\ninherits(PouchError, Error);\n\nfunction PouchError(opts) {\n  Error.call(this, opts.reason);\n  this.status = opts.status;\n  this.name = opts.error;\n  this.message = opts.reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError({\n  status: 401,\n  error: 'unauthorized',\n  reason: \"Name or password is incorrect.\"\n});\n\nvar MISSING_BULK_DOCS = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: \"Missing JSON list of 'docs'\"\n});\n\nvar MISSING_DOC = new PouchError({\n  status: 404,\n  error: 'not_found',\n  reason: 'missing'\n});\n\nvar REV_CONFLICT = new PouchError({\n  status: 409,\n  error: 'conflict',\n  reason: 'Document update conflict'\n});\n\nvar INVALID_ID = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: '_id field must contain a string'\n});\n\nvar MISSING_ID = new PouchError({\n  status: 412,\n  error: 'missing_id',\n  reason: '_id is required for puts'\n});\n\nvar RESERVED_ID = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: 'Only reserved document ids may start with underscore.'\n});\n\nvar NOT_OPEN = new PouchError({\n  status: 412,\n  error: 'precondition_failed',\n  reason: 'Database not open'\n});\n\nvar UNKNOWN_ERROR = new PouchError({\n  status: 500,\n  error: 'unknown_error',\n  reason: 'Database encountered an unknown error'\n});\n\nvar BAD_ARG = new PouchError({\n  status: 500,\n  error: 'badarg',\n  reason: 'Some query argument is invalid'\n});\n\nvar INVALID_REQUEST = new PouchError({\n  status: 400,\n  error: 'invalid_request',\n  reason: 'Request was invalid'\n});\n\nvar QUERY_PARSE_ERROR = new PouchError({\n  status: 400,\n  error: 'query_parse_error',\n  reason: 'Some query parameter is invalid'\n});\n\nvar DOC_VALIDATION = new PouchError({\n  status: 500,\n  error: 'doc_validation',\n  reason: 'Bad special document member'\n});\n\nvar BAD_REQUEST = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: 'Something wrong with the request'\n});\n\nvar NOT_AN_OBJECT = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: 'Document must be a JSON object'\n});\n\nvar DB_MISSING = new PouchError({\n  status: 404,\n  error: 'not_found',\n  reason: 'Database not found'\n});\n\nvar IDB_ERROR = new PouchError({\n  status: 500,\n  error: 'indexed_db_went_bad',\n  reason: 'unknown'\n});\n\nvar WSQ_ERROR = new PouchError({\n  status: 500,\n  error: 'web_sql_went_bad',\n  reason: 'unknown'\n});\n\nvar LDB_ERROR = new PouchError({\n  status: 500,\n  error: 'levelDB_went_went_bad',\n  reason: 'unknown'\n});\n\nvar FORBIDDEN = new PouchError({\n  status: 403,\n  error: 'forbidden',\n  reason: 'Forbidden by design doc validate_doc_update function'\n});\n\nvar INVALID_REV = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: 'Invalid rev format'\n});\n\nvar FILE_EXISTS = new PouchError({\n  status: 412,\n  error: 'file_exists',\n  reason: 'The database could not be created, the file already exists.'\n});\n\nvar MISSING_STUB = new PouchError({\n  status: 412,\n  error: 'missing_stub'\n});\n\nvar INVALID_URL = new PouchError({\n  status: 413,\n  error: 'invalid_url',\n  reason: 'Provided URL is invalid'\n});\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 events.EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* jshint maxlen: false */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new PouchPromise(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\n// BEGIN Math.uuid.js\n\n/*!\nMath.uuid.js (v1.4)\nhttp://www.broofa.com\nmailto:robert@broofa.com\n\nCopyright (c) 2010 Robert Kieffer\nDual licensed under the MIT and GPL licenses.\n*/\n\n/*\n * Generate a random uuid.\n *\n * USAGE: Math.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> Math.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n *\n *   // One argument - returns ID of the specified length\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. \n *   // (Radix must be <= 62)\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\nvar chars = (\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n  'abcdefghijklmnopqrstuvwxyz'\n).split('');\nfunction getValue(radix) {\n  return 0 | Math.random() * radix;\n}\nfunction uuid(len, radix) {\n  radix = radix || chars.length;\n  var out = '';\n  var i = -1;\n\n  if (len) {\n    // Compact form\n    while (++i < len) {\n      out += chars[getValue(radix)];\n    }\n    return out;\n  }\n    // rfc4122, version 4 form\n    // Fill in random data.  At i==19 set the high bits of clock sequence as\n    // per rfc4122, sec. 4.1.5\n  while (++i < 36) {\n    switch (i) {\n      case 8:\n      case 13:\n      case 18:\n      case 23:\n        out += '-';\n        break;\n      case 19:\n        out += chars[(getValue(16) & 0x3) | 0x8];\n        break;\n      default:\n        out += chars[getValue(16)];\n    }\n  }\n\n  return out;\n}\n\n// based on https://github.com/montagejs/collections\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction _Map() {\n  this.store = {};\n}\n_Map.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this.store[mangled];\n};\n_Map.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this.store[mangled] = value;\n  return true;\n};\n_Map.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this.store;\n};\n_Map.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this.store;\n  delete this.store[mangled];\n  return res;\n};\n_Map.prototype.forEach = function (cb) {\n  var keys = Object.keys(this.store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this.store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\n\nfunction _Set(array) {\n  this.store = new _Map();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\n_Set.prototype.add = function (key) {\n  return this.store.set(key, true);\n};\n_Set.prototype.has = function (key) {\n  return this.store.has(key);\n};\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var maybeStem = {};\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var numStemmed = Math.max(0, stemmed.length - depth);\n    var stemmedNode = {\n      pos: path.pos + numStemmed,\n      ids: pathToTree(stemmed, numStemmed)\n    };\n\n    for (var s = 0; s < numStemmed; s++) {\n      var rev = (path.pos + s) + '-' + stemmed[s].id;\n      maybeStem[rev] = true;\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, stemmedNode, true).tree;\n    } else {\n      result = [stemmedNode];\n    }\n  }\n\n  traverseRevTree(result, function (isLeaf, pos, revHash) {\n    // some revisions may have been removed in a branch but not in another\n    delete maybeStem[pos + '-' + revHash];\n  });\n\n  return {\n    tree: result,\n    revs: Object.keys(maybeStem)\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\nfunction evalFilter(input) {\n  return scopedEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopedEval(code, {});\n}\n\ninherits(Changes$1, events.EventEmitter);\n\nfunction tryCatchInChangeListener(self, change) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction Changes$1(db, opts, callback) {\n  events.EventEmitter.call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      if (listenerCount(self, 'error') > 0) {\n        self.emit('error', err);\n      }\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change) {\n    /* istanbul ignore if */\n    if (opts.isCancelled) {\n      return;\n    }\n    tryCatchInChangeListener(self, change);\n  };\n\n  var promise = new PouchPromise(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, {status: 'cancelled'});\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function (failed) {\n      if (failed) {\n        opts.complete(failed);\n      } else if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.doChanges(opts);\n      }\n    });\n  } else {\n    self.doChanges(opts);\n  }\n}\nChanges$1.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges$1.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, {status: 'cancelled'});\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n\n    if (this.db.type() !== 'http' && !opts.doc_ids) {\n      return this.filterChanges(opts);\n    }\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  /* istanbul ignore else */\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = getArguments(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\nChanges$1.prototype.filterChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    this.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      self.doChanges(opts);\n    });\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    if (!filterName) {\n      return self.doChanges(opts);\n    }\n    this.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      self.doChanges(opts);\n    });\n  }\n};\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// returns first element of arr satisfying callback predicate\nfunction arrayFirst(arr, callback) {\n  for (var i = 0; i < arr.length; i++) {\n    if (callback(arr[i], i) === true) {\n      return arr[i];\n    }\n  }\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      callback(err || results[0]);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev});\n    }\n    return rev;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysQuery(api, opts, callback) {\n  var keys =  ('limit' in opts) ?\n      opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  if (opts.descending) {\n    keys.reverse();\n  }\n  if (!keys.length) {\n    return api._allDocs({limit: 0}, callback);\n  }\n  var finalResults = {\n    offset: opts.skip\n  };\n  return PouchPromise.all(keys.map(function (key) {\n    var subOpts = extend$1({key: key, deleted: 'ok'}, opts);\n    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n      delete subOpts[optKey];\n    });\n    return new PouchPromise(function (resolve, reject) {\n      api._allDocs(subOpts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        finalResults.total_rows = res.total_rows;\n        resolve(res.rows[0] || {key: key, error: 'not_found'});\n      });\n    });\n  })).then(function (results) {\n    finalResults.rows = results;\n    return finalResults;\n  });\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      process.nextTick(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + 'is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\ninherits(AbstractPouchDB, events.EventEmitter);\n\nfunction AbstractPouchDB() {\n  events.EventEmitter.call(this);\n}\n\nAbstractPouchDB.prototype.post =\n  adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback));\n});\n\nAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return cb(createError(NOT_AN_OBJECT));\n  }\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, cb);\n    } else {\n      return this._putLocal(doc, cb);\n    }\n  }\n  if (typeof this._put === 'function' && opts.new_edits !== false) {\n    this._put(doc, opts, cb);\n  } else {\n    this.bulkDocs({docs: [doc]}, opts, yankError(cb));\n  }\n});\n\nAbstractPouchDB.prototype.putAttachment =\n  adapterFun('putAttachment', function (docId, attachmentId, rev,\n                                              blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n\n  function createAttachment(doc) {\n    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob,\n      revpos: ++prevrevpos\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n     // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({_id: docId});\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment =\n  adapterFun('removeAttachment', function (docId, attachmentId, rev,\n                                                 callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove =\n  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n});\n\nAbstractPouchDB.prototype.revsDiff =\n  adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new _Map();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, {missing: []});\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n      opts) {\n        var rev = pos + '-' + revHash;\n        var idx = missingForId.indexOf(rev);\n        if (idx === -1) {\n          return;\n        }\n\n        missingForId.splice(idx, 1);\n        /* istanbul ignore if */\n        if (opts.status !== 'available') {\n          addToMissing(id, rev);\n        }\n      });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev) {\n      addToMissing(id, rev);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, {missing: req[id]});\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet =\n  adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument =\n  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev) {\n      if (height[rev] > maxHeight) {\n        candidates.push(rev);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n        revs.push(rev);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact =\n  adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({opts: opts, callback: callback});\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    PouchPromise.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, {ok: true});\n    }).catch(callback);\n  }\n  self.changes(changesOpts)\n    .on('change', onChange)\n    .on('complete', onComplete)\n    .on('error', callback);\n};\n\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return cb(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, cb);\n  }\n  var leaves = [], self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return cb(null, result);\n    }\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        attachments: opts.attachments\n      }, function (err, doc) {\n        if (!err) {\n          result.push({ok: doc});\n        } else {\n          result.push({missing: leaf});\n        }\n        count--;\n        if (!count) {\n          cb(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        if (err) {\n          return cb(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n            return cb(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      return cb(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = arrayFirst(paths, function (arr) {\n        return arr.ids.map(function (x) { return x.id; })\n          .indexOf(doc._rev.split('-')[1]) !== -1;\n      });\n\n      var indexOfRev = path.ids.map(function (x) {return x.id; })\n        .indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: (path.pos + path.ids.length) - 1,\n          ids: path.ids.map(function (rev) {\n            return rev.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos =  path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev) {\n          pos--;\n          return {\n            rev: pos + '-' + rev.id,\n            status: rev.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return cb(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(doc._id, key, attachments[key], {\n          // Previously the revision handling was done in adapter.js\n          // getAttachment, however since idb-next doesnt we need to\n          // pass the rev through\n          rev: doc._rev,\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (!--count) {\n            cb(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      cb(null, doc);\n    }\n  });\n});\n\n// TODO: I dont like this, it forces an extra read for every\n// attachment read and enforces a confusing api between\n// adapter.js and the adapter implementation\nAbstractPouchDB.prototype.getAttachment =\n  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(docId, attachmentId,\n                          res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs =\n  adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt =\n      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR,\n        'Query parameter `' + incompatibleOpt +\n        '` is not compatible with multi-get'\n      ));\n      return;\n    }\n    if (this.type() !== 'http') {\n      return allDocsKeysQuery(this, opts, callback);\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return new Changes$1(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n  this._closed = true;\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self.name;\n    info.auto_compaction = !!(self.auto_compaction && self.type() !== 'http');\n    info.adapter = self.type();\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\n/* istanbul ignore next */\nAbstractPouchDB.prototype.type = function () {\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs =\n  adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function (doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  if (!opts.new_edits && this.type() !== 'http') {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase =\n  adapterFun('registerDependentDatabase', function (dependentDb,\n                                                          callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n    .then(function () {\n      callback(null, {db: depDB});\n    }).catch(callback);\n});\n\nAbstractPouchDB.prototype.destroy =\n  adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (self.type() === 'http') {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else { // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ?\n        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    PouchPromise.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while ((fun = this.queue.shift())) {\n      fun(this.failed);\n    }\n  } else {\n    while ((fun = this.queue.shift())) {\n      fun();\n    }\n  }\n};\n\nTaskQueue.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];\n    return {name: name, adapter: match[1]};\n  }\n\n  // check for browsers that have been upgraded from websql-only to websql+idb\n  var skipIdb = 'idb' in PouchDB.adapters && 'websql' in PouchDB.adapters &&\n    hasLocalStorage() &&\n    localStorage['_pouch__websqldb_' + PouchDB.prefix + name];\n\n  var adapterName;\n\n  if (opts.adapter) {\n    adapterName = opts.adapter;\n  } else if (typeof opts !== 'undefined' && opts.db) {\n    adapterName = 'leveldb';\n  } else { // automatically determine adapter\n    for (var i = 0; i < PouchDB.preferredAdapters.length; ++i) {\n      adapterName = PouchDB.preferredAdapters[i];\n      /* istanbul ignore if */\n      if (skipIdb && adapterName === 'idb') {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = PouchDB.adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (PouchDB.prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  var destructionListeners = self.constructor._destructionListeners;\n\n  function onDestroyed() {\n    self.constructor.emit('destroyed', self.name);\n  }\n\n  function onConstructorDestroyed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.emit('destroyed', self);\n  }\n\n  self.once('destroyed', onDestroyed);\n\n  // in setup.js, the constructor is primed to listen for destroy events\n  if (!destructionListeners.has(self.name)) {\n    destructionListeners.set(self.name, []);\n  }\n  destructionListeners.get(self.name).push(onConstructorDestroyed);\n}\n\ninherits(PouchDB, AbstractPouchDB);\nfunction PouchDB(name, opts) {\n  // In Node our test suite only tests this for PouchAlt unfortunately\n  /* istanbul ignore if */\n  if (!(this instanceof PouchDB)) {\n    return new PouchDB(name, opts);\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = opts.name;\n    delete opts.name;\n  }\n\n  this.__opts = opts = clone(opts);\n\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB.prefix;\n\n  if (typeof name !== 'string') {\n    throw new Error('Missing/invalid DB name');\n  }\n\n  var prefixedName = (opts.prefix || '') + name;\n  var backend = parseAdapter(prefixedName, opts);\n\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  self.name = name;\n  self._adapter = opts.adapter;\n  debug('pouchdb:adapter')('Picked adapter: ' + opts.adapter);\n\n  if (!PouchDB.adapters[opts.adapter] ||\n      !PouchDB.adapters[opts.adapter].valid()) {\n    throw new Error('Invalid Adapter: ' + opts.adapter);\n  }\n\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue();\n\n  self.adapter = opts.adapter;\n\n  PouchDB.adapters[opts.adapter].call(self, opts, function (err) {\n    if (err) {\n      return self.taskqueue.fail(err);\n    }\n    prepareForDestruction(self);\n\n    self.emit('created', self);\n    PouchDB.emit('created', self.name);\n    self.taskqueue.ready(self);\n  });\n\n}\n\nPouchDB.debug = debug;\n\nPouchDB.adapters = {};\nPouchDB.preferredAdapters = [];\n\nPouchDB.prefix = '_pouch_';\n\nvar eventEmitter = new events.EventEmitter();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n    if (typeof events.EventEmitter.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new _Map();\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    destructListeners.get(name).forEach(function (callback) {\n      callback();\n    });\n    destructListeners.delete(name);\n  });\n}\n\nsetUpEventEmitter(PouchDB);\n\nPouchDB.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0){\n    throw new Error('Invalid plugin: object passed in is empty or not an object');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB.prototype[id] = obj[id];\n    });\n  }\n  return PouchDB;\n};\n\nPouchDB.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts);\n    }\n\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = extend$1({}, defaultOpts, opts);\n    PouchDB.call(this, name, opts);\n  }\n\n  inherits(PouchAlt, PouchDB);\n\n  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();\n  Object.keys(PouchDB).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB[key];\n    }\n  });\n\n  return PouchAlt;\n};\n\n// managed automatically by set-version.js\nvar version = \"6.0.7\";\n\nPouchDB.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev) {\n  if (!/^\\d+\\-./.test(rev)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev.indexOf('-');\n  var left = rev.substring(0, idx);\n  var right = rev.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits) {\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = uuid(32, 16).toLowerCase();\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nvar atob$1 = function (str) {\n  return atob(str);\n};\n\nvar btoa$1 = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(atob$1(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(\n      new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(btoa$1(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return btoa$1(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nfunction parseBase64(data) {\n  try {\n    return atob$1(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = btoa$1(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && (((previouslyDeleted && deleted) ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$ = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$ = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new _Map();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction slowJsonParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonParse(str) {\n  // try/catch is deoptimized in V8, leading to slower\n  // times than we'd like to have. Most documents are _not_\n  // huge, and do not require a slower code path just to parse them.\n  // We can be pretty sure that a document under 50000 characters\n  // will not be so deeply nested as to throw a stack overflow error\n  // (depends on the engine and available memory, though, so this is\n  // just a hunch). 50000 was chosen based on the average length\n  // of this string in our test suite, to try to find a number that covers\n  // most of our test cases (26 over this size, 26378 under it).\n  if (str.length < 50000) {\n    return JSON.parse(str);\n  }\n  return slowJsonParse(str);\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction tryCode(fun, that, args, PouchDB) {\n  try {\n    fun.apply(that, args);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nvar taskQueue = {\n  running: false,\n  queue: []\n};\n\nfunction applyNext(PouchDB) {\n  if (taskQueue.running || !taskQueue.queue.length) {\n    return;\n  }\n  taskQueue.running = true;\n  var item = taskQueue.queue.shift();\n  item.action(function (err, res) {\n    tryCode(item.callback, this, [err, res], PouchDB);\n    taskQueue.running = false;\n    process.nextTick(function () {\n      applyNext(PouchDB);\n    });\n  });\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(btoa$1(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return PouchPromise.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return PouchPromise.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new PouchPromise(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = extend$1(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, idbChanges, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var docInfoError;\n  var docCountDelta = 0;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new _Map();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    idbChanges.notify(api._meta.name);\n    api._meta.docCount += docCountDelta;\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docCountDelta += delta;\n\n    docInfo.metadata.winningRev = winningRev;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    finishDoc(docInfo, winningRev, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: winningRev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction handleKeyRangeError(api, opts, err, callback) {\n  if (err.name === \"DataError\" && err.code === 0) {\n    // data error, start is less than end\n    return callback(null, {\n      total_rows: api._meta.docCount,\n      offset: opts.skip,\n      rows: []\n    });\n  }\n  callback(createError(IDB_ERROR, err.name, err.message));\n}\n\nfunction idbAllDocs(opts, api, idb, callback) {\n\n  function allDocsQuery(opts, callback) {\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var skip = opts.skip || 0;\n    var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n    var inclusiveEnd = opts.inclusive_end !== false;\n    var descending = 'descending' in opts && opts.descending ? 'prev' : null;\n\n    var keyRange = createKeyRange(start, end, inclusiveEnd, key, descending);\n    if (keyRange && keyRange.error) {\n      return handleKeyRangeError(api, opts, keyRange.error, callback);\n    }\n\n    var stores = [DOC_STORE, BY_SEQ_STORE];\n\n    if (opts.attachments) {\n      stores.push(ATTACH_STORE);\n    }\n    var txnResult = openTransactionSafely(idb, stores, 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var cursor = descending ?\n      docStore.openCursor(keyRange, descending) :\n      docStore.openCursor(keyRange);\n    var docIdRevIndex = seqStore.index('_doc_id_rev');\n    var results = [];\n    var docCount = 0;\n\n    // if the user specifies include_docs=true, then we don't\n    // want to block the main cursor while we're fetching the doc\n    function fetchDocAsynchronously(metadata, row, winningRev) {\n      var key = metadata.id + \"::\" + winningRev;\n      docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n        row.doc = decodeDoc(e.target.result);\n        if (opts.conflicts) {\n          row.doc._conflicts = collectConflicts(metadata);\n        }\n        fetchAttachmentsIfNecessary(row.doc, opts, txn);\n      };\n    }\n\n    function allDocsInner(cursor, winningRev, metadata) {\n      var row = {\n        id: metadata.id,\n        key: metadata.id,\n        value: {\n          rev: winningRev\n        }\n      };\n      var deleted = metadata.deleted;\n      if (opts.deleted === 'ok') {\n        results.push(row);\n        // deleted docs are okay with \"keys\" requests\n        if (deleted) {\n          row.value.deleted = true;\n          row.doc = null;\n        } else if (opts.include_docs) {\n          fetchDocAsynchronously(metadata, row, winningRev);\n        }\n      } else if (!deleted && skip-- <= 0) {\n        results.push(row);\n        if (opts.include_docs) {\n          fetchDocAsynchronously(metadata, row, winningRev);\n        }\n        if (--limit === 0) {\n          return;\n        }\n      }\n      cursor.continue();\n    }\n\n    function onGetCursor(e) {\n      docCount = api._meta.docCount; // do this within the txn for consistency\n      var cursor = e.target.result;\n      if (!cursor) {\n        return;\n      }\n      var metadata = decodeMetadata(cursor.value);\n      var winningRev = metadata.winningRev;\n\n      allDocsInner(cursor, winningRev, metadata);\n    }\n\n    function onResultsReady() {\n      callback(null, {\n        total_rows: docCount,\n        offset: opts.skip,\n        rows: results\n      });\n    }\n\n    function onTxnComplete() {\n      if (opts.attachments) {\n        postProcessAttachments(results, opts.binary).then(onResultsReady);\n      } else {\n        onResultsReady();\n      }\n    }\n\n    txn.oncomplete = onTxnComplete;\n    cursor.onsuccess = onGetCursor;\n  }\n\n  function allDocs(opts, callback) {\n\n    if (opts.limit === 0) {\n      return callback(null, {\n        total_rows: api._meta.docCount,\n        offset: opts.skip,\n        rows: []\n      });\n    }\n    allDocsQuery(opts, callback);\n  }\n\n  allDocs(opts, callback);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new PouchPromise(function (resolve) {\n    var blob = createBlob(['']);\n    txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n    txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n\n    txn.oncomplete = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nvar cachedDBs = new _Map();\nvar blobSupportPromise;\nvar idbChanges = new Changes();\nvar openReqList = new _Map();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  taskQueue.queue.push({\n    action: function (thisCallback) {\n      init(api, opts, thisCallback);\n    },\n    callback: callback\n  });\n  applyNext(api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, idbChanges, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n      if (isDeleted(metadata) && !opts.rev) {\n        err = createError(MISSING_DOC, \"deleted\");\n        return finish();\n      }\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n\n      var rev = opts.rev || metadata.winningRev;\n      var key = metadata.id + '::' + rev;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n\n    if (idb === null || !cachedDBs.has(dbName)) {\n      var error = new Error('db isn\\'t open');\n      error.id = 'idbNull';\n      return callback(error);\n    }\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var cursor = txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev');\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n      // count within the same txn for consistency\n      docCount = api._meta.docCount;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, api, idb, callback);\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = dbName + ':' + uuid();\n      idbChanges.addListener(dbName, id, api, opts);\n      idbChanges.notify(dbName);\n      return {\n        cancel: function () {\n          idbChanges.removeListener(dbName, id);\n        }\n      };\n    }\n\n    var docIds = opts.doc_ids && new _Set(opts.doc_ids);\n\n    opts.since = opts.since || 0;\n    var lastSeq = opts.since;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n\n    var results = [];\n    var numResults = 0;\n    var filter = filterChange(opts);\n    var docIdsToMetadata = new _Map();\n\n    var txn;\n    var bySeqStore;\n    var docStore;\n    var docIdRevIndex;\n\n    function onGetCursor(cursor) {\n\n      var doc = decodeDoc(cursor.value);\n      var seq = cursor.key;\n\n      if (docIds && !docIds.has(doc._id)) {\n        return cursor.continue();\n      }\n\n      var metadata;\n\n      function onGetMetadata() {\n        if (metadata.seq !== seq) {\n          // some other seq is later\n          return cursor.continue();\n        }\n\n        lastSeq = seq;\n\n        if (metadata.winningRev === doc._rev) {\n          return onGetWinningDoc(doc);\n        }\n\n        fetchWinningDoc();\n      }\n\n      function fetchWinningDoc() {\n        var docIdRev = doc._id + '::' + metadata.winningRev;\n        var req = docIdRevIndex.get(docIdRev);\n        req.onsuccess = function (e) {\n          onGetWinningDoc(decodeDoc(e.target.result));\n        };\n      }\n\n      function onGetWinningDoc(winningDoc) {\n\n        var change = opts.processChange(winningDoc, metadata, opts);\n        change.seq = metadata.seq;\n\n        var filtered = filter(change);\n        if (typeof filtered === 'object') {\n          return opts.complete(filtered);\n        }\n\n        if (filtered) {\n          numResults++;\n          if (returnDocs) {\n            results.push(change);\n          }\n          // process the attachment immediately\n          // for the benefit of live listeners\n          if (opts.attachments && opts.include_docs) {\n            fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n              postProcessAttachments([change], opts.binary).then(function () {\n                opts.onChange(change);\n              });\n            });\n          } else {\n            opts.onChange(change);\n          }\n        }\n        if (numResults !== limit) {\n          cursor.continue();\n        }\n      }\n\n      metadata = docIdsToMetadata.get(doc._id);\n      if (metadata) { // cached\n        return onGetMetadata();\n      }\n      // metadata not cached, have to go fetch it\n      docStore.get(doc._id).onsuccess = function (event) {\n        metadata = decodeMetadata(event.target.result);\n        docIdsToMetadata.set(doc._id, metadata);\n        onGetMetadata();\n      };\n    }\n\n    function onsuccess(event) {\n      var cursor = event.target.result;\n\n      if (!cursor) {\n        return;\n      }\n      onGetCursor(cursor);\n    }\n\n    function fetchChanges() {\n      var objectStores = [DOC_STORE, BY_SEQ_STORE];\n      if (opts.attachments) {\n        objectStores.push(ATTACH_STORE);\n      }\n      var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n      if (txnResult.error) {\n        return opts.complete(txnResult.error);\n      }\n      txn = txnResult.txn;\n      txn.onabort = idbError(opts.complete);\n      txn.oncomplete = onTxnComplete;\n\n      bySeqStore = txn.objectStore(BY_SEQ_STORE);\n      docStore = txn.objectStore(DOC_STORE);\n      docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n      var req;\n\n      if (opts.descending) {\n        req = bySeqStore.openCursor(null, 'prev');\n      } else {\n        req = bySeqStore.openCursor(IDBKeyRange.lowerBound(opts.since, true));\n      }\n\n      req.onsuccess = onsuccess;\n    }\n\n    fetchChanges();\n\n    function onTxnComplete() {\n\n      function finish() {\n        opts.complete(null, {\n          results: results,\n          last_seq: lastSeq\n        });\n      }\n\n      if (!opts.continuous && opts.attachments) {\n        // cannot guarantee that postProcessing was already done,\n        // so do it again\n        postProcessAttachments(results).then(finish);\n      } else {\n        finish();\n      }\n    }\n  };\n\n  api._close = function (callback) {\n    if (idb === null) {\n      return callback(createError(NOT_OPEN));\n    }\n\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    idb = null;\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev = pos + '-' + revHash;\n        if (revs.indexOf(rev) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    idbChanges.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    process.nextTick(function () {\n      callback(null, api);\n    });\n    return;\n  }\n\n  var req;\n  if (opts.storage) {\n    req = tryStorageOption(dbName, opts.storage);\n  } else {\n    req = indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var req = txn.objectStore(META_STORE).get(META_STORE);\n\n    var blobSupport = null;\n    var docCount = null;\n    var instanceId = null;\n\n    req.onsuccess = function (e) {\n\n      var checkSetupComplete = function () {\n        if (blobSupport === null || docCount === null ||\n            instanceId === null) {\n          return;\n        } else {\n          api._meta = {\n            name: dbName,\n            instanceId: instanceId,\n            blobSupport: blobSupport,\n            docCount: docCount\n          };\n\n          cachedDBs.set(dbName, {\n            idb: idb,\n            global: api._meta\n          });\n          callback(null, api);\n        }\n      };\n\n      //\n      // fetch/store the id\n      //\n\n      var meta = e.target.result || {id: META_STORE};\n      if (dbName  + '_id' in meta) {\n        instanceId = meta[dbName + '_id'];\n        checkSetupComplete();\n      } else {\n        instanceId = uuid();\n        meta[dbName + '_id'] = instanceId;\n        txn.objectStore(META_STORE).put(meta).onsuccess = function () {\n          checkSetupComplete();\n        };\n      }\n\n      //\n      // check blob support\n      //\n\n      if (!blobSupportPromise) {\n        // make sure blob support is only checked once\n        blobSupportPromise = checkBlobSupport(txn);\n      }\n\n      blobSupportPromise.then(function (val) {\n        blobSupport = val;\n        checkSetupComplete();\n      });\n\n      //\n      // count docs\n      //\n\n      var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n      index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n        docCount = e.target.result;\n        checkSetupComplete();\n      };\n\n    };\n  };\n\n  req.onerror = function () {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Issue #2533, we finally gave up on doing bug\n  // detection instead of browser sniffing. Safari brought us\n  // to our knees.\n  var isSafari = typeof openDatabase !== 'undefined' &&\n    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n    !/Chrome/.test(navigator.userAgent) &&\n    !/BlackBerry/.test(navigator.platform);\n\n  // some outdated implementations of IDB that appear on Samsung\n  // and HTC Android devices <4.4 are missing IDBKeyRange\n  return !isSafari && typeof indexedDB !== 'undefined' &&\n    typeof IDBKeyRange !== 'undefined';\n};\n\nfunction tryStorageOption(dbName, storage) {\n  try { // option only available in Firefox 26+\n    return indexedDB.open(dbName, {\n      version: ADAPTER_VERSION,\n      storage: storage\n    });\n  } catch(err) {\n      return indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n}\n\nfunction IDBPouch (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n}\n\n//\n// Parsing hex strings. Yeah.\n//\n// So basically we need this because of a bug in WebSQL:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n//\n// UTF-8 and UTF-16 are provided as separate functions\n// for meager performance improvements\n//\n\nfunction decodeUtf8(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction hexToInt(charCode) {\n  // '0'-'9' is 48-57\n  // 'A'-'F' is 65-70\n  // SQLite will only give us uppercase hex\n  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n}\n\n\n// Example:\n// pragma encoding=utf8;\n// select hex('A');\n// returns '41'\nfunction parseHexUtf8(str, start, end) {\n  var result = '';\n  while (start < end) {\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start++)) << 4) |\n        hexToInt(str.charCodeAt(start++)));\n  }\n  return result;\n}\n\n// Example:\n// pragma encoding=utf16;\n// select hex('A');\n// returns '4100'\n// notice that the 00 comes after the 41 (i.e. it's swizzled)\nfunction parseHexUtf16(str, start, end) {\n  var result = '';\n  while (start < end) {\n    // UTF-16, so swizzle the bytes\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n        (hexToInt(str.charCodeAt(start)) << 4) |\n        hexToInt(str.charCodeAt(start + 1)));\n    start += 4;\n  }\n  return result;\n}\n\nfunction parseHexString(str, encoding) {\n  if (encoding === 'UTF-8') {\n    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n  } else {\n    return parseHexUtf16(str, 0, str.length);\n  }\n}\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE$1 = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE$1 = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE$1 = quote('attach-store');\nvar LOCAL_STORE$1 = quote('local-store');\nvar META_STORE$1 = quote('metadata-store');\n// where we store many-to-many relations between attachment\n// digests and seqs\nvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\n// escapeBlob and unescapeBlob are workarounds for a websql bug:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n// The goal is to never actually insert the \\u0000 character\n// in the database.\nfunction escapeBlob(str) {\n  return str\n    .replace(/\\u0002/g, '\\u0002\\u0002')\n    .replace(/\\u0001/g, '\\u0001\\u0002')\n    .replace(/\\u0000/g, '\\u0001\\u0001');\n}\n\nfunction unescapeBlob(str) {\n  return str\n    .replace(/\\u0001\\u0001/g, '\\u0000')\n    .replace(/\\u0001\\u0002/g, '\\u0001')\n    .replace(/\\u0002\\u0002/g, '\\u0002');\n}\n\nfunction stringifyDoc(doc) {\n  // don't bother storing the id/rev. it uses lots of space,\n  // in persistent map/reduce especially\n  delete doc._id;\n  delete doc._rev;\n  return JSON.stringify(doc);\n}\n\nfunction unstringifyDoc(doc, id, rev) {\n  doc = JSON.parse(doc);\n  doc._id = id;\n  doc._rev = rev;\n  return doc;\n}\n\n// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\nfunction qMarks(num) {\n  var s = '(';\n  while (num--) {\n    s += '?';\n    if (num) {\n      s += ',';\n    }\n  }\n  return s + ')';\n}\n\nfunction select(selector, table, joiner, where, orderBy) {\n  return 'SELECT ' + selector + ' FROM ' +\n    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n    (joiner ? (' ON ' + joiner) : '') +\n    (where ? (' WHERE ' +\n    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n    (orderBy ? (' ORDER BY ' + orderBy) : '');\n}\n\nfunction compactRevs$1(revs, docId, tx) {\n\n  if (!revs.length) {\n    return;\n  }\n\n  var numDone = 0;\n  var seqs = [];\n\n  function checkDone() {\n    if (++numDone === revs.length) { // done\n      deleteOrphans();\n    }\n  }\n\n  function deleteOrphans() {\n    // find orphaned attachment digests\n\n    if (!seqs.length) {\n      return;\n    }\n\n    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\n    tx.executeSql(sql, seqs, function (tx, res) {\n\n      var digestsToCheck = [];\n      for (var i = 0; i < res.rows.length; i++) {\n        digestsToCheck.push(res.rows.item(i).digest);\n      }\n      if (!digestsToCheck.length) {\n        return;\n      }\n\n      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n        ' WHERE seq IN (' +\n        seqs.map(function () { return '?'; }).join(',') +\n        ')';\n      tx.executeSql(sql, seqs, function (tx) {\n\n        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n          ' WHERE digest IN (' +\n          digestsToCheck.map(function () { return '?'; }).join(',') +\n          ')';\n        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n          var nonOrphanedDigests = new _Set();\n          for (var i = 0; i < res.rows.length; i++) {\n            nonOrphanedDigests.add(res.rows.item(i).digest);\n          }\n          digestsToCheck.forEach(function (digest) {\n            if (nonOrphanedDigests.has(digest)) {\n              return;\n            }\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n              [digest]);\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n          });\n        });\n      });\n    });\n  }\n\n  // update by-seq and attach stores in parallel\n  revs.forEach(function (rev) {\n    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=? AND rev=?';\n\n    tx.executeSql(sql, [docId, rev], function (tx, res) {\n      if (!res.rows.length) { // already deleted\n        return checkDone();\n      }\n      var seq = res.rows.item(0).seq;\n      seqs.push(seq);\n\n      tx.executeSql(\n        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n    });\n  });\n}\n\nfunction websqlError(callback) {\n  return function (event) {\n    guardedConsole('error', 'WebSQL threw an error', event);\n    // event may actually be a SQLError object, so report is as such\n    var errorNameMatch = event && event.constructor.toString()\n        .match(/function ([^\\(]+)/);\n    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n    var errorReason = event.target || event.message;\n    callback(createError(WSQ_ERROR, errorReason, errorName));\n  };\n}\n\nfunction getSize(opts) {\n  if ('size' in opts) {\n    // triggers immediate popup in iOS, fixes #2347\n    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n    return opts.size * 1000000;\n  }\n  // In iOS, doesn't matter as long as it's <= 5000000.\n  // Except that if you request too much, our tests fail\n  // because of the native \"do you accept?\" popup.\n  // In Android <=4.3, this value is actually used as an\n  // honest-to-god ceiling for data, so we need to\n  // set it to a decently high number.\n  var isAndroid = typeof navigator !== 'undefined' &&\n    /Android/.test(navigator.userAgent);\n  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n}\n\nfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n  var newEdits = opts.new_edits;\n  var userDocs = req.docs;\n\n  // Parse the docs, give them a sequence number for the result\n  var docInfos = userDocs.map(function (doc) {\n    if (doc._id && isLocalId(doc._id)) {\n      return doc;\n    }\n    var newDoc = parseDoc(doc, newEdits);\n    return newDoc;\n  });\n\n  var docInfoErrors = docInfos.filter(function (docInfo) {\n    return docInfo.error;\n  });\n  if (docInfoErrors.length) {\n    return callback(docInfoErrors[0]);\n  }\n\n  var tx;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new _Map();\n\n  var preconditionErrored;\n  function complete() {\n    if (preconditionErrored) {\n      return callback(preconditionErrored);\n    }\n    websqlChanges.notify(api._name);\n    api._docCount = -1; // invalidate\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n      ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.item(0).cnt === 0) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        callback(err);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  function verifyAttachments(finish) {\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    function finish() {\n      var data = docInfo.data;\n      var deletedInt = newRevIsDeleted ? 1 : 0;\n\n      var id = data._id;\n      var rev = data._rev;\n      var json = stringifyDoc(data);\n      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n      var sqlArgs = [id, rev, json, deletedInt];\n\n      // map seqs to attachment digests, which\n      // we will need later during compaction\n      function insertAttachmentMappings(seq, callback) {\n        var attsAdded = 0;\n        var attsToAdd = Object.keys(data._attachments || {});\n\n        if (!attsToAdd.length) {\n          return callback();\n        }\n        function checkDone() {\n          if (++attsAdded === attsToAdd.length) {\n            callback();\n          }\n          return false; // ack handling a constraint error\n        }\n        function add(att) {\n          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n            ' (digest, seq) VALUES (?,?)';\n          var sqlArgs = [data._attachments[att].digest, seq];\n          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n          // second callback is for a constaint error, which we ignore\n          // because this docid/rev has already been associated with\n          // the digest (e.g. when new_edits == false)\n        }\n        for (var i = 0; i < attsToAdd.length; i++) {\n          add(attsToAdd[i]); // do in parallel\n        }\n      }\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        var seq = result.insertId;\n        insertAttachmentMappings(seq, function () {\n          dataWritten(tx, seq);\n        });\n      }, function () {\n        // constraint error, recover by updating instead (see #1638)\n        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n          'doc_id=? AND rev=?');\n        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n          var seq = res.rows.item(0).seq;\n          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n          var sqlArgs = [json, deletedInt, id, rev];\n          tx.executeSql(sql, sqlArgs, function (tx) {\n            insertAttachmentMappings(seq, function () {\n              dataWritten(tx, seq);\n            });\n          });\n        });\n        return false; // ack that we've handled the error\n      });\n    }\n\n    function collectResults(attachmentErr) {\n      if (!err) {\n        if (attachmentErr) {\n          err = attachmentErr;\n          callback(err);\n        } else if (recv === attachments.length) {\n          finish();\n        }\n      }\n    }\n\n    var err = null;\n    var recv = 0;\n\n    docInfo.data._id = docInfo.metadata.id;\n    docInfo.data._rev = docInfo.metadata.rev;\n    var attachments = Object.keys(docInfo.data._attachments || {});\n\n\n    if (newRevIsDeleted) {\n      docInfo.data._deleted = true;\n    }\n\n    function attachmentSaved(err) {\n      recv++;\n      collectResults(err);\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        recv++;\n        collectResults();\n      }\n    });\n\n    if (!attachments.length) {\n      finish();\n    }\n\n    function dataWritten(tx, seq) {\n      var id = docInfo.metadata.id;\n\n      var revsToCompact = docInfo.stemmedRevs || [];\n      if (isUpdate && api.auto_compaction) {\n        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n      }\n      if (revsToCompact.length) {\n        compactRevs$1(revsToCompact, id, tx);\n      }\n\n      docInfo.metadata.seq = seq;\n      delete docInfo.metadata.rev;\n\n      var sql = isUpdate ?\n      'UPDATE ' + DOC_STORE$1 +\n      ' SET json=?, max_seq=?, winningseq=' +\n      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n        : 'INSERT INTO ' + DOC_STORE$1 +\n      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n      var metadataStr = safeJsonStringify(docInfo.metadata);\n      var params = isUpdate ?\n        [metadataStr, seq, winningRev, id] :\n        [id, seq, seq, metadataStr];\n      tx.executeSql(sql, params, function () {\n        results[resultsIdx] = {\n          ok: true,\n          id: docInfo.metadata.id,\n          rev: winningRev\n        };\n        fetchedDocs.set(id, docInfo.metadata);\n        callback();\n      });\n    }\n  }\n\n  function websqlProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n                results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs(callback) {\n    if (!docInfos.length) {\n      return callback();\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        callback();\n      }\n    }\n\n    docInfos.forEach(function (docInfo) {\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        return checkDone(); // skip local docs\n      }\n      var id = docInfo.metadata.id;\n      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n      ' WHERE id = ?', [id], function (tx, result) {\n        if (result.rows.length) {\n          var metadata = safeJsonParse(result.rows.item(0).json);\n          fetchedDocs.set(id, metadata);\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function saveAttachment(digest, data, callback) {\n    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.length) { // attachment already exists\n        return callback();\n      }\n      // we could just insert before selecting and catch the error,\n      // but my hunch is that it's cheaper not to serialize the blob\n      // from JS to C if we don't have to (TODO: confirm this)\n      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n      ' (digest, body, escaped) VALUES (?,?,1)';\n      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n        callback();\n      }, function () {\n        // ignore constaint errors, means it already exists\n        callback();\n        return false; // ack we handled the error\n      });\n    });\n  }\n\n  preprocessAttachments(docInfos, 'binary', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    db.transaction(function (txn) {\n      tx = txn;\n      verifyAttachments(function (err) {\n        if (err) {\n          preconditionErrored = err;\n        } else {\n          fetchExistingDocs(websqlProcessDocs);\n        }\n      });\n    }, websqlError(callback), complete);\n  });\n}\n\nvar cachedDatabases = new _Map();\n\n// openDatabase passed in through opts (e.g. for node-websql)\nfunction openDatabaseWithOpts(opts) {\n  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n}\n\nfunction openDBSafely(opts) {\n  try {\n    return {\n      db: openDatabaseWithOpts(opts)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nfunction openDB$1(opts) {\n  var cachedResult = cachedDatabases.get(opts.name);\n  if (!cachedResult) {\n    cachedResult = openDBSafely(opts);\n    cachedDatabases.set(opts.name, cachedResult);\n  }\n  return cachedResult;\n}\n\nvar websqlChanges = new Changes();\n\nfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var attOpts = {binary: opts.binary, ctx: txn};\n    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n      doc._attachments[att] = extend$1(\n        pick(attObj, ['digest', 'content_type']),\n        { data: data }\n      );\n      checkDone();\n    });\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\nvar POUCH_VERSION = 1;\n\n// these indexes cover the ground for most allDocs queries\nvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n  BY_SEQ_STORE$1 + ' (seq, deleted)';\nvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n    BY_SEQ_STORE$1 + ' (doc_id, rev)';\nvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n  DOC_STORE$1 + ' (winningseq)';\nvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\nvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\nvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\nvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n  BY_SEQ_STORE$1 + '.json AS data, ' +\n  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n  DOC_STORE$1 + '.json AS metadata';\n\nfunction WebSqlPouch$1(opts, callback) {\n  var api = this;\n  var instanceId = null;\n  var size = getSize(opts);\n  var idRequests = [];\n  var encoding;\n\n  api._docCount = -1; // cache sqlite count(*) for performance\n  api._name = opts.name;\n\n  // extend the options here, because sqlite plugin has a ton of options\n  // and they are constantly changing, so it's more prudent to allow anything\n  var websqlOpts = extend$1({}, opts, {\n    version: POUCH_VERSION,\n    description: opts.name,\n    size: size\n  });\n  var openDBResult = openDB$1(websqlOpts);\n  if (openDBResult.error) {\n    return websqlError(callback)(openDBResult.error);\n  }\n  var db = openDBResult.db;\n  if (typeof db.readTransaction !== 'function') {\n    // doesn't exist in sqlite plugin\n    db.readTransaction = db.transaction;\n  }\n\n  function dbCreated() {\n    // note the db name in case the browser upgrades to idb\n    if (hasLocalStorage()) {\n      window.localStorage['_pouch__websqldb_' + api._name] = true;\n    }\n    callback(null, api);\n  }\n\n  // In this migration, we added the 'deleted' and 'local' columns to the\n  // by-seq and doc store tables.\n  // To preserve existing user data, we re-process all the existing JSON\n  // and add these values.\n  // Called migration2 because it corresponds to adapter version (db_version) #2\n  function runMigration2(tx, callback) {\n    // index used for the join in the allDocs query\n    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\n    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n          DOC_STORE$1 + ' (local, id)');\n\n        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\n        tx.executeSql(sql, [], function (tx, result) {\n\n          var deleted = [];\n          var local = [];\n\n          for (var i = 0; i < result.rows.length; i++) {\n            var item = result.rows.item(i);\n            var seq = item.seq;\n            var metadata = JSON.parse(item.metadata);\n            if (isDeleted(metadata)) {\n              deleted.push(seq);\n            }\n            if (isLocalId(metadata.id)) {\n              local.push(metadata.id);\n            }\n          }\n          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n            qMarks(local.length), local, function () {\n            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n              ' SET deleted = 1 WHERE seq IN ' +\n              qMarks(deleted.length), deleted, callback);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we make all the local docs unversioned\n  function runMigration3(tx, callback) {\n    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n      ' (id UNIQUE, rev, json)';\n    tx.executeSql(local, [], function () {\n      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n        BY_SEQ_STORE$1 + '.json AS data ' +\n        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n        DOC_STORE$1 + '.winningseq WHERE local = 1';\n      tx.executeSql(sql, [], function (tx, res) {\n        var rows = [];\n        for (var i = 0; i < res.rows.length; i++) {\n          rows.push(res.rows.item(i));\n        }\n        function doNext() {\n          if (!rows.length) {\n            return callback(tx);\n          }\n          var row = rows.shift();\n          var rev = JSON.parse(row.data)._rev;\n          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n              ' (id, rev, json) VALUES (?,?,?)',\n              [row.id, rev, row.data], function (tx) {\n            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n                [row.id], function (tx) {\n              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n                  [row.seq], function () {\n                doNext();\n              });\n            });\n          });\n        }\n        doNext();\n      });\n    });\n  }\n\n  // in this migration, we remove doc_id_rev and just use rev\n  function runMigration4(tx, callback) {\n\n    function updateRows(rows) {\n      function doNext() {\n        if (!rows.length) {\n          return callback(tx);\n        }\n        var row = rows.shift();\n        var doc_id_rev = parseHexString(row.hex, encoding);\n        var idx = doc_id_rev.lastIndexOf('::');\n        var doc_id = doc_id_rev.substring(0, idx);\n        var rev = doc_id_rev.substring(idx + 2);\n        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n        tx.executeSql(sql, [doc_id, rev, doc_id_rev], function () {\n          doNext();\n        });\n      }\n      doNext();\n    }\n\n    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n      tx.executeSql(sql, [], function (tx) {\n        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n          tx.executeSql(sql, [], function (tx, res) {\n            var rows = [];\n            for (var i = 0; i < res.rows.length; i++) {\n              rows.push(res.rows.item(i));\n            }\n            updateRows(rows);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we add the attach_and_seq table\n  // for issue #2818\n  function runMigration5(tx, callback) {\n\n    function migrateAttsAndSeqs(tx) {\n      // need to actually populate the table. this is the expensive part,\n      // so as an optimization, check first that this database even\n      // contains attachments\n      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n      tx.executeSql(sql, [], function (tx, res) {\n        var count = res.rows.item(0).cnt;\n        if (!count) {\n          return callback(tx);\n        }\n\n        var offset = 0;\n        var pageSize = 10;\n        function nextPage() {\n          var sql = select(\n            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n            [DOC_STORE$1, BY_SEQ_STORE$1],\n            DOC_STORE_AND_BY_SEQ_JOINER,\n            null,\n            DOC_STORE$1 + '.id '\n          );\n          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n          offset += pageSize;\n          tx.executeSql(sql, [], function (tx, res) {\n            if (!res.rows.length) {\n              return callback(tx);\n            }\n            var digestSeqs = {};\n            function addDigestSeq(digest, seq) {\n              // uniq digest/seq pairs, just in case there are dups\n              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n              if (seqs.indexOf(seq) === -1) {\n                seqs.push(seq);\n              }\n            }\n            for (var i = 0; i < res.rows.length; i++) {\n              var row = res.rows.item(i);\n              var doc = unstringifyDoc(row.data, row.id, row.rev);\n              var atts = Object.keys(doc._attachments || {});\n              for (var j = 0; j < atts.length; j++) {\n                var att = doc._attachments[atts[j]];\n                addDigestSeq(att.digest, row.seq);\n              }\n            }\n            var digestSeqPairs = [];\n            Object.keys(digestSeqs).forEach(function (digest) {\n              var seqs = digestSeqs[digest];\n              seqs.forEach(function (seq) {\n                digestSeqPairs.push([digest, seq]);\n              });\n            });\n            if (!digestSeqPairs.length) {\n              return nextPage();\n            }\n            var numDone = 0;\n            digestSeqPairs.forEach(function (pair) {\n              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n                ' (digest, seq) VALUES (?,?)';\n              tx.executeSql(sql, pair, function () {\n                if (++numDone === digestSeqPairs.length) {\n                  nextPage();\n                }\n              });\n            });\n          });\n        }\n        nextPage();\n      });\n    }\n\n    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n    tx.executeSql(attachAndRev, [], function (tx) {\n      tx.executeSql(\n        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n          tx.executeSql(\n            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n            migrateAttsAndSeqs);\n        });\n    });\n  }\n\n  // in this migration, we use escapeBlob() and unescapeBlob()\n  // instead of reading out the binary as HEX, which is slow\n  function runMigration6(tx, callback) {\n    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n    tx.executeSql(sql, [], callback);\n  }\n\n  // issue #3136, in this migration we need a \"latest seq\" as well\n  // as the \"winning seq\" in the doc store\n  function runMigration7(tx, callback) {\n    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n      ' ADD COLUMN max_seq INTEGER';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n      tx.executeSql(sql, [], function (tx) {\n        // add unique index after filling, else we'll get a constraint\n        // error when we do the ALTER TABLE\n        var sql =\n          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n          DOC_STORE$1 + ' (max_seq)';\n        tx.executeSql(sql, [], callback);\n      });\n    });\n  }\n\n  function checkEncoding(tx, cb) {\n    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n        var hex = res.rows.item(0).hex;\n        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n        cb();\n      }\n    );\n  }\n\n  function onGetInstanceId() {\n    while (idRequests.length > 0) {\n      var idCallback = idRequests.pop();\n      idCallback(null, instanceId);\n    }\n  }\n\n  function onGetVersion(tx, dbVersion) {\n    if (dbVersion === 0) {\n      // initial schema\n\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n        ' (dbid, db_version INTEGER)';\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n      // TODO: migrate winningseq to INTEGER\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n        'json, deleted TINYINT(1), doc_id, rev)';\n      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n        ' (id UNIQUE, rev, json)';\n\n      // creates\n      tx.executeSql(attach);\n      tx.executeSql(local);\n      tx.executeSql(attachAndRev, [], function () {\n        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n      });\n      tx.executeSql(doc, [], function () {\n        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n        tx.executeSql(seq, [], function () {\n          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n          tx.executeSql(meta, [], function () {\n            // mark the db version, and new dbid\n            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n              ' (db_version, dbid) VALUES (?,?)';\n            instanceId = uuid();\n            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n            tx.executeSql(initSeq, initSeqArgs, function () {\n              onGetInstanceId();\n            });\n          });\n        });\n      });\n    } else { // version > 0\n\n      var setupDone = function () {\n        var migrated = dbVersion < ADAPTER_VERSION$1;\n        if (migrated) {\n          // update the db version within this transaction\n          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n            ADAPTER_VERSION$1);\n        }\n        // notify db.id() callers\n        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n        tx.executeSql(sql, [], function (tx, result) {\n          instanceId = result.rows.item(0).dbid;\n          onGetInstanceId();\n        });\n      };\n\n      // would love to use promises here, but then websql\n      // ends the transaction early\n      var tasks = [\n        runMigration2,\n        runMigration3,\n        runMigration4,\n        runMigration5,\n        runMigration6,\n        runMigration7,\n        setupDone\n      ];\n\n      // run each migration sequentially\n      var i = dbVersion;\n      var nextMigration = function (tx) {\n        tasks[i - 1](tx, nextMigration);\n        i++;\n      };\n      nextMigration(tx);\n    }\n  }\n\n  function setup() {\n    db.transaction(function (tx) {\n      // first check the encoding\n      checkEncoding(tx, function () {\n        // then get the version\n        fetchVersion(tx);\n      });\n    }, websqlError(callback), dbCreated);\n  }\n\n  function fetchVersion(tx) {\n    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n    tx.executeSql(sql, [], function (tx, result) {\n      if (!result.rows.length) {\n        // database hasn't even been created yet (version 0)\n        onGetVersion(tx, 0);\n      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n        // table was created, but without the new db_version column,\n        // so add it.\n        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n          ' ADD COLUMN db_version INTEGER', [], function () {\n          // before version 2, this column didn't even exist\n          onGetVersion(tx, 1);\n        });\n      } else { // column exists, we can safely get it\n        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n          [], function (tx, result) {\n          var dbVersion = result.rows.item(0).db_version;\n          onGetVersion(tx, dbVersion);\n        });\n      }\n    });\n  }\n\n  setup();\n\n  api.type = function () {\n    return 'websql';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, instanceId);\n  });\n\n  api._info = function (callback) {\n    db.readTransaction(function (tx) {\n      countDocs(tx, function (docCount) {\n        var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n        tx.executeSql(sql, [], function (tx, res) {\n          var updateSeq = res.rows.item(0).seq || 0;\n          callback(null, {\n            doc_count: docCount,\n            update_seq: updateSeq,\n            websql_encoding: encoding\n          });\n        });\n      });\n    }, websqlError(callback));\n  };\n\n  api._bulkDocs = function (req, reqOpts, callback) {\n    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n  };\n\n  api._get = function (id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var tx = opts.ctx;\n    if (!tx) {\n      return db.readTransaction(function (txn) {\n        api._get(id, extend$1({ctx: txn}, opts), callback);\n      });\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n    }\n\n    var sql;\n    var sqlArgs;\n    if (opts.rev) {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n      sqlArgs = [id, opts.rev];\n    } else {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n      sqlArgs = [id];\n    }\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n      var item = results.rows.item(0);\n      metadata = safeJsonParse(item.metadata);\n      if (item.deleted && !opts.rev) {\n        err = createError(MISSING_DOC, 'deleted');\n        return finish();\n      }\n      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n      finish();\n    });\n  };\n\n  function countDocs(tx, callback) {\n\n    if (api._docCount !== -1) {\n      return callback(api._docCount);\n    }\n\n    // count the total rows\n    var sql = select(\n      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n      [DOC_STORE$1, BY_SEQ_STORE$1],\n      DOC_STORE_AND_BY_SEQ_JOINER,\n      BY_SEQ_STORE$1 + '.deleted=0');\n\n    tx.executeSql(sql, [], function (tx, result) {\n      api._docCount = result.rows.item(0).num;\n      callback(api._docCount);\n    });\n  }\n\n  api._allDocs = function (opts, callback) {\n    var results = [];\n    var totalRows;\n\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var limit = 'limit' in opts ? opts.limit : -1;\n    var offset = 'skip' in opts ? opts.skip : 0;\n    var inclusiveEnd = opts.inclusive_end !== false;\n\n    var sqlArgs = [];\n    var criteria = [];\n\n    if (key !== false) {\n      criteria.push(DOC_STORE$1 + '.id = ?');\n      sqlArgs.push(key);\n    } else if (start !== false || end !== false) {\n      if (start !== false) {\n        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n        sqlArgs.push(start);\n      }\n      if (end !== false) {\n        var comparator = descending ? '>' : '<';\n        if (inclusiveEnd) {\n          comparator += '=';\n        }\n        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n        sqlArgs.push(end);\n      }\n      if (key !== false) {\n        criteria.push(DOC_STORE$1 + '.id = ?');\n        sqlArgs.push(key);\n      }\n    }\n\n    if (opts.deleted !== 'ok') {\n      // report deleted if keys are specified\n      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n    }\n\n    db.readTransaction(function (tx) {\n\n      // first count up the total rows\n      countDocs(tx, function (count) {\n        totalRows = count;\n\n        if (limit === 0) {\n          return;\n        }\n\n        // then actually fetch the documents\n        var sql = select(\n          SELECT_DOCS,\n          [DOC_STORE$1, BY_SEQ_STORE$1],\n          DOC_STORE_AND_BY_SEQ_JOINER,\n          criteria,\n          DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n          );\n        sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            var id = metadata.id;\n            var data = unstringifyDoc(item.data, id, item.rev);\n            var winningRev = data._rev;\n            var doc = {\n              id: id,\n              key: id,\n              value: {rev: winningRev}\n            };\n            if (opts.include_docs) {\n              doc.doc = data;\n              doc.doc._rev = winningRev;\n              if (opts.conflicts) {\n                doc.doc._conflicts = collectConflicts(metadata);\n              }\n              fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n            }\n            if (item.deleted) {\n              if (opts.deleted === 'ok') {\n                doc.value.deleted = true;\n                doc.doc = null;\n              } else {\n                continue;\n              }\n            }\n            results.push(doc);\n          }\n        });\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        total_rows: totalRows,\n        offset: opts.skip,\n        rows: results\n      });\n    });\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = api._name + ':' + uuid();\n      websqlChanges.addListener(api._name, id, api, opts);\n      websqlChanges.notify(api._name);\n      return {\n        cancel: function () {\n          websqlChanges.removeListener(api._name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    var results = [];\n    var numResults = 0;\n\n    function fetchChanges() {\n\n      var selectStmt =\n        DOC_STORE$1 + '.json AS metadata, ' +\n        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\n      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\n      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\n      var criteria = ['maxSeq > ?'];\n      var sqlArgs = [opts.since];\n\n      if (opts.doc_ids) {\n        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n        sqlArgs = sqlArgs.concat(opts.doc_ids);\n      }\n\n      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\n      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\n      var filter = filterChange(opts);\n      if (!opts.view && !opts.filter) {\n        // we can just limit in the query\n        sql += ' LIMIT ' + limit;\n      }\n\n      var lastSeq = opts.since || 0;\n      db.readTransaction(function (tx) {\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          function reportChange(change) {\n            return function () {\n              opts.onChange(change);\n            };\n          }\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            lastSeq = item.maxSeq;\n\n            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n              item.winningRev);\n            var change = opts.processChange(doc, metadata, opts);\n            change.seq = item.maxSeq;\n\n            var filtered = filter(change);\n            if (typeof filtered === 'object') {\n              return opts.complete(filtered);\n            }\n\n            if (filtered) {\n              numResults++;\n              if (returnDocs) {\n                results.push(change);\n              }\n              // process the attachment immediately\n              // for the benefit of live listeners\n              if (opts.attachments && opts.include_docs) {\n                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n                  reportChange(change));\n              } else {\n                reportChange(change)();\n              }\n            }\n            if (numResults === limit) {\n              break;\n            }\n          }\n        });\n      }, websqlError(opts.complete), function () {\n        if (!opts.continuous) {\n          opts.complete(null, {\n            results: results,\n            last_seq: lastSeq\n          });\n        }\n      });\n    }\n\n    fetchChanges();\n  };\n\n  api._close = function (callback) {\n    //WebSQL databases do not need to be closed\n    callback();\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var res;\n    var tx = opts.ctx;\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n    var sql = 'SELECT escaped, ' +\n      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n      ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      // websql has a bug where \\u0000 causes early truncation in strings\n      // and blobs. to work around this, we used to use the hex() function,\n      // but that's not performant. after migration 6, we remove \\u0000\n      // and add it back in afterwards\n      var item = result.rows.item(0);\n      var data = item.escaped ? unescapeBlob(item.body) :\n        parseHexString(item.body, encoding);\n      if (opts.binary) {\n        res = binStringToBluffer(data, type);\n      } else {\n        res = btoa$1(data);\n      }\n      callback(null, res);\n    });\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          callback(createError(MISSING_DOC));\n        } else {\n          var data = safeJsonParse(result.rows.item(0).metadata);\n          callback(null, data.rev_tree);\n        }\n      });\n    });\n  };\n\n  api._doCompaction = function (docId, revs, callback) {\n    if (!revs.length) {\n      return callback();\n    }\n    db.transaction(function (tx) {\n\n      // update doc store\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        var metadata = safeJsonParse(result.rows.item(0).metadata);\n        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                           revHash, ctx, opts) {\n          var rev = pos + '-' + revHash;\n          if (revs.indexOf(rev) !== -1) {\n            opts.status = 'missing';\n          }\n        });\n\n        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n      });\n\n      compactRevs$1(revs, docId, tx);\n    }, websqlError(callback), function () {\n      callback();\n    });\n  };\n\n  api._getLocal = function (id, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n      tx.executeSql(sql, [id], function (tx, res) {\n        if (res.rows.length) {\n          var item = res.rows.item(0);\n          var doc = unstringifyDoc(item.json, id, item.rev);\n          callback(null, doc);\n        } else {\n          callback(createError(MISSING_DOC));\n        }\n      });\n    });\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    var newRev;\n    if (!oldRev) {\n      newRev = doc._rev = '0-1';\n    } else {\n      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n    var json = stringifyDoc(doc);\n\n    var ret;\n    function putLocal(tx) {\n      var sql;\n      var values;\n      if (oldRev) {\n        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n          'WHERE id=? AND rev=?';\n        values = [newRev, json, id, oldRev];\n      } else {\n        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n        values = [id, newRev, json];\n      }\n      tx.executeSql(sql, values, function (tx, res) {\n        if (res.rowsAffected) {\n          ret = {ok: true, id: id, rev: newRev};\n          if (opts.ctx) { // return immediately\n            callback(null, ret);\n          }\n        } else {\n          callback(createError(REV_CONFLICT));\n        }\n      }, function () {\n        callback(createError(REV_CONFLICT));\n        return false; // ack that we handled the error\n      });\n    }\n\n    if (opts.ctx) {\n      putLocal(opts.ctx);\n    } else {\n      db.transaction(putLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ret;\n\n    function removeLocal(tx) {\n      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n      var params = [doc._id, doc._rev];\n      tx.executeSql(sql, params, function (tx, res) {\n        if (!res.rowsAffected) {\n          return callback(createError(MISSING_DOC));\n        }\n        ret = {ok: true, id: doc._id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      });\n    }\n\n    if (opts.ctx) {\n      removeLocal(opts.ctx);\n    } else {\n      db.transaction(removeLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._destroy = function (opts, callback) {\n    websqlChanges.removeAllListeners(api._name);\n    db.transaction(function (tx) {\n      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n      stores.forEach(function (store) {\n        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n      });\n    }, websqlError(callback), function () {\n      if (hasLocalStorage()) {\n        delete window.localStorage['_pouch__websqldb_' + api._name];\n        delete window.localStorage[api._name];\n      }\n      callback(null, {'ok': true});\n    });\n  };\n}\n\nfunction canOpenTestDB() {\n  try {\n    openDatabase('_pouch_validate_websql', 1, '', 1);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n// https://github.com/pouchdb/pouchdb/issues/5079)\n// This has been fixed in latest WebKit, so we try to detect it here.\nfunction isValidWebSQL() {\n  // WKWebView UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n  // Chrome for iOS UA:\n  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n  //   Mobile/9B206 Safari/7534.48.3\n  // Firefox for iOS UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\n  // indexedDB is null on some UIWebViews and undefined in others\n  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n    // definitely not WKWebView, avoid creating an unnecessary database\n    return true;\n  }\n  // Cache the result in LocalStorage. Reason we do this is because if we\n  // call openDatabase() too many times, Safari craps out in SauceLabs and\n  // starts throwing DOM Exception 14s.\n  var hasLS = hasLocalStorage();\n  // Include user agent in the hash, so that if Safari is upgraded, we don't\n  // continually think it's broken.\n  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n  if (hasLS && localStorage[localStorageKey]) {\n    return localStorage[localStorageKey] === '1';\n  }\n  var openedTestDB = canOpenTestDB();\n  if (hasLS) {\n    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n  }\n  return openedTestDB;\n}\n\nfunction valid() {\n  if (typeof openDatabase !== 'function') {\n    return false;\n  }\n  return isValidWebSQL();\n}\n\nfunction openDB(name, version, description, size) {\n  // Traditional WebSQL API\n  return openDatabase(name, version, description, size);\n}\n\nfunction WebSQLPouch(opts, callback) {\n  var _opts = extend$1({\n    websql: openDB\n  }, opts);\n\n  WebSqlPouch$1.call(this, _opts, callback);\n}\n\nWebSQLPouch.valid = valid;\n\nWebSQLPouch.use_prefix = true;\n\nfunction WebSqlPouch (PouchDB) {\n  PouchDB.adapter('websql', WebSQLPouch, true);\n}\n\n/* global fetch */\n/* global Headers */\nfunction wrappedFetch() {\n  var wrappedPromise = {};\n\n  var promise = new PouchPromise(function (resolve, reject) {\n    wrappedPromise.resolve = resolve;\n    wrappedPromise.reject = reject;\n  });\n\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < args.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  wrappedPromise.promise = promise;\n\n  PouchPromise.resolve().then(function () {\n    return fetch.apply(null, args);\n  }).then(function (response) {\n    wrappedPromise.resolve(response);\n  }).catch(function (error) {\n    wrappedPromise.reject(error);\n  });\n\n  return wrappedPromise;\n}\n\nfunction fetchRequest(options, callback) {\n  var wrappedPromise, timer, response;\n\n  var headers = new Headers();\n\n  var fetchOptions = {\n    method: options.method,\n    credentials: 'include',\n    headers: headers\n  };\n\n  if (options.json) {\n    headers.set('Accept', 'application/json');\n    headers.set('Content-Type', options.headers['Content-Type'] ||\n      'application/json');\n  }\n\n  if (options.body && (options.body instanceof Blob)) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      fetchOptions.body = arrayBuffer;\n    });\n  } else if (options.body &&\n             options.processData &&\n             typeof options.body !== 'string') {\n    fetchOptions.body = JSON.stringify(options.body);\n  } else if ('body' in options) {\n    fetchOptions.body = options.body;\n  } else {\n    fetchOptions.body = null;\n  }\n\n  Object.keys(options.headers).forEach(function (key) {\n    if (options.headers.hasOwnProperty(key)) {\n      headers.set(key, options.headers[key]);\n    }\n  });\n\n  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\n  if (options.timeout > 0) {\n    timer = setTimeout(function () {\n      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n        options.url));\n    }, options.timeout);\n  }\n\n  wrappedPromise.promise.then(function (fetchResponse) {\n    response = {\n      statusCode: fetchResponse.status\n    };\n\n    if (options.timeout > 0) {\n      clearTimeout(timer);\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n    }\n\n    return fetchResponse.json();\n  }).then(function (result) {\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      callback(null, response, result);\n    } else {\n      callback(result, response);\n    }\n  }).catch(function (error) {\n    callback(error, response);\n  });\n\n  return {abort: wrappedPromise.reject};\n}\n\nfunction xhRequest(options, callback) {\n\n  var xhr, timer;\n  var timedout = false;\n\n  var abortReq = function () {\n    xhr.abort();\n    cleanUp();\n  };\n\n  var timeoutReq = function () {\n    timedout = true;\n    xhr.abort();\n    cleanUp();\n  };\n\n  var ret = {abort: abortReq};\n\n  var cleanUp = function () {\n    clearTimeout(timer);\n    ret.abort = function () {};\n    if (xhr) {\n      xhr.onprogress = undefined;\n      if (xhr.upload) {\n        xhr.upload.onprogress = undefined;\n      }\n      xhr.onreadystatechange = undefined;\n      xhr = undefined;\n    }\n  };\n\n  if (options.xhr) {\n    xhr = new options.xhr();\n  } else {\n    xhr = new XMLHttpRequest();\n  }\n\n  try {\n    xhr.open(options.method, options.url);\n  } catch (exception) {\n    return callback(new Error(exception.name || 'Url is invalid'));\n  }\n\n  xhr.withCredentials = ('withCredentials' in options) ?\n    options.withCredentials : true;\n\n  if (options.method === 'GET') {\n    delete options.headers['Content-Type'];\n  } else if (options.json) {\n    options.headers.Accept = 'application/json';\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n    if (options.body &&\n        options.processData &&\n        typeof options.body !== \"string\") {\n      options.body = JSON.stringify(options.body);\n    }\n  }\n\n  if (options.binary) {\n    xhr.responseType = 'arraybuffer';\n  }\n\n  if (!('body' in options)) {\n    options.body = null;\n  }\n\n  for (var key in options.headers) {\n    if (options.headers.hasOwnProperty(key)) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n  }\n\n  if (options.timeout > 0) {\n    timer = setTimeout(timeoutReq, options.timeout);\n    xhr.onprogress = function () {\n      clearTimeout(timer);\n      if(xhr.readyState !== 4) {\n        timer = setTimeout(timeoutReq, options.timeout);\n      }\n    };\n    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n      xhr.upload.onprogress = xhr.onprogress;\n    }\n  }\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    var response = {\n      statusCode: xhr.status\n    };\n\n    if (xhr.status >= 200 && xhr.status < 300) {\n      var data;\n      if (options.binary) {\n        data = createBlob([xhr.response || ''], {\n          type: xhr.getResponseHeader('Content-Type')\n        });\n      } else {\n        data = xhr.responseText;\n      }\n      callback(null, response, data);\n    } else {\n      var err = {};\n      if (timedout) {\n        err = new Error('ETIMEDOUT');\n        err.code = 'ETIMEDOUT';\n      } else if (typeof xhr.response === 'string') {\n        try {\n          err = JSON.parse(xhr.response);\n        } catch(e) {}\n      }\n      err.status = xhr.status;\n      callback(err);\n    }\n    cleanUp();\n  };\n\n  if (options.body && (options.body instanceof Blob)) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      xhr.send(arrayBuffer);\n    });\n  } else {\n    xhr.send(options.body);\n  }\n\n  return ret;\n}\n\nfunction testXhr() {\n  try {\n    new XMLHttpRequest();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nvar hasXhr = testXhr();\n\nfunction ajax$1(options, callback) {\n  if (hasXhr || options.xhr) {\n    return xhRequest(options, callback);\n  } else {\n    return fetchRequest(options, callback);\n  }\n}\n\n// the blob already has a type; do nothing\nvar res$2 = function () {};\n\nfunction defaultBody() {\n  return '';\n}\n\nfunction ajaxCore(options, callback) {\n\n  options = clone(options);\n\n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000,\n    cache: false\n  };\n\n  options = extend$1(defaultOptions, options);\n\n  function onSuccess(obj, resp, cb) {\n    if (!options.binary && options.json && typeof obj === 'string') {\n      /* istanbul ignore next */\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        return cb(e);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map(function (v) {\n        if (v.error || v.missing) {\n          return generateErrorFromResponse(v);\n        } else {\n          return v;\n        }\n      });\n    }\n    if (options.binary) {\n      res$2(obj, resp);\n    }\n    cb(null, obj, resp);\n  }\n\n  if (options.json) {\n    if (!options.binary) {\n      options.headers.Accept = 'application/json';\n    }\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n  }\n\n  if (options.binary) {\n    options.encoding = null;\n    options.json = false;\n  }\n\n  if (!options.processData) {\n    options.json = false;\n  }\n\n  return ajax$1(options, function (err, response, body) {\n\n    if (err) {\n      return callback(generateErrorFromResponse(err));\n    }\n\n    var error;\n    var content_type = response.headers && response.headers['content-type'];\n    var data = body || defaultBody();\n\n    // CouchDB doesn't always return the right content-type for JSON data, so\n    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n    if (!options.binary && (options.json || !options.processData) &&\n        typeof data !== 'object' &&\n        (/json/.test(content_type) ||\n         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n      try {\n        data = JSON.parse(data.toString());\n      } catch (e) {}\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      onSuccess(data, response, callback);\n    } else {\n      error = generateErrorFromResponse(data);\n      error.status = response.statusCode;\n      callback(error);\n    }\n  });\n}\n\nfunction ajax(opts, callback) {\n\n  // cache-buster, specifically designed to work around IE's aggressive caching\n  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n  // Also Safari caches POSTs, so we need to cache-bust those too.\n  var ua = (navigator && navigator.userAgent) ?\n    navigator.userAgent.toLowerCase() : '';\n\n  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n  var isIE = ua.indexOf('msie') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n\n  // it appears the new version of safari also caches GETs,\n  // see https://github.com/pouchdb/pouchdb/issues/5010\n  var shouldCacheBust = (isSafari ||\n    ((isIE || isEdge) && opts.method === 'GET'));\n\n  var cache = 'cache' in opts ? opts.cache : true;\n\n  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\n  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n    var hasArgs = opts.url.indexOf('?') !== -1;\n    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n  }\n\n  return ajaxCore(opts, callback);\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\n\nvar supportsBulkGetMap = {};\n\nvar log$1 = debug('pouchdb:http');\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var atts = row.doc && row.doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$1(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return PouchPromise.resolve();\n  }\n\n  return PouchPromise.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new PouchPromise(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n\n  var protocol = parseUri(opts.prefix).protocol;\n\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    var dbName = opts.name.substr(opts.prefix.length);\n    name = opts.prefix + encodeURIComponent(dbName);\n  }\n\n  // Prase the URI into all its little bits\n  var uri = parseUri(name);\n\n  // Store the user and password as a separate auth object\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  // Store the first part as the database name and remove it from the parts\n  // array\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  // Restore the path by joining all the remaining parts (all the parts\n  // except for the database name) with '/'s\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  var host = getHost(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n  var ajaxOpts = opts.ajax || {};\n\n  if (opts.auth || host.auth) {\n    var nAuth = opts.auth || host.auth;\n    var str = nAuth.username + ':' + nAuth.password;\n    var token = btoa$1(unescape(encodeURIComponent(str)));\n    ajaxOpts.headers = ajaxOpts.headers || {};\n    ajaxOpts.headers.Authorization = 'Basic ' + token;\n  }\n\n  // Not strictly necessary, but we do this because numerous tests\n  // rely on swapping ajax in and out.\n  api._ajax = ajax;\n\n  function ajax$$(userOpts, options, callback) {\n    var reqAjax = userOpts.ajax || {};\n    var reqOpts = extend$1(clone(ajaxOpts), reqAjax, options);\n    log$1(reqOpts.method + ' ' + reqOpts.url);\n    return api._ajax(reqOpts, callback);\n  }\n\n  function ajaxPromise(userOpts, opts) {\n    return new PouchPromise(function (resolve, reject) {\n      ajax$$(userOpts, opts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function adapterFun$$(name, fun) {\n    return adapterFun(name, getArguments(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function (e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    }));\n  }\n\n  var setupPromise;\n\n  function setup() {\n    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n    if (opts.skipSetup || opts.skip_setup) {\n      return PouchPromise.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    var checkExists = {method: 'GET', url: dbUrl};\n    setupPromise = ajaxPromise({}, checkExists).catch(function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n      } else {\n        return PouchPromise.reject(err);\n      }\n    }).catch(function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return PouchPromise.reject(err);\n    });\n\n    setupPromise.catch(function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  setTimeout(function () {\n    callback(null, api);\n  });\n\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$('id', function (callback) {\n    ajax$$({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n      var uuid = (result && result.uuid) ?\n        (result.uuid + host.db) : genDBUrl(host, '');\n      callback(null, uuid);\n    });\n  });\n\n  api.request = adapterFun$$('request', function (options, callback) {\n    options.url = genDBUrl(host, options.url);\n    ajax$$({}, options, callback);\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n    ajax$$(opts, {\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function () {\n      function ping() {\n        api.info(function (err, res) {\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      ajax$$({}, {\n        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n        method: 'POST',\n        body: { docs: opts.docs}\n      }, cb);\n    }\n\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments']);\n        subOpts.ajax = ajaxOpts;\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        /* istanbul ignore else */\n        if (err) {\n          var status = Math.floor(err.status / 100);\n          /* istanbul ignore else */\n          if (status === 4 || status === 5) { // 40x or 50x\n            supportsBulkGetMap[dbUrl] = false;\n            explainError(\n              err.status,\n              'PouchDB is just detecting if the remote ' +\n              'supports the _bulk_get API.'\n            );\n            doBulkGetShim();\n          } else {\n            callback(err);\n          }\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      /* istanbul ignore next */\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      ajax$$({}, {\n        method: 'GET',\n        url: genDBUrl(host, '')\n      }, function (err, res) {\n        /* istanbul ignore next */\n        if (err) {\n        return callback(err);\n        }\n        res.host = genDBUrl(host, '');\n        callback(null, res);\n      });\n    }).catch(callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    id = encodeDocId(id);\n\n    // Set the options for the ajax call\n    var options = {\n      method: 'GET',\n      url: genDBUrl(host, id + paramsToStr(params))\n    };\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetch() {\n\n        if (!filenames.length) {\n          return null;\n        }\n\n        var filename = filenames.pop();\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n          '?rev=' + doc._rev;\n        return ajaxPromise(opts, {\n          method: 'GET',\n          url: genDBUrl(host, path),\n          binary: true\n        }).then(function (blob) {\n          if (opts.binary) {\n            return blob;\n          }\n          return new PouchPromise(function (resolve) {\n            blobToBase64(blob, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return new PromisePool(fetch, 5, {promise: PouchPromise}).start();\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return PouchPromise.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    ajaxPromise(opts, options).then(function (res) {\n      return PouchPromise.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res);\n        }\n      }).then(function () {\n        callback(null, res);\n      });\n    }).catch(callback);\n  });\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$('remove',\n      function (docOrId, optsOrRev, opts, callback) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        callback = optsOrRev;\n        opts = {};\n      } else {\n        callback = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev = (doc._rev || opts.rev);\n\n    // Delete the document\n    ajax$$(opts, {\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev\n    }, callback);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment =\n    adapterFun$$('getAttachment', function (docId, attachmentId, opts,\n                                                callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n      encodeAttachmentId(attachmentId) + params;\n    ajax$$(opts, {\n      method: 'GET',\n      url: url,\n      binary: true\n    }, callback);\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =\n    adapterFun$$('removeAttachment', function (docId, attachmentId, rev,\n                                                   callback) {\n\n    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n      encodeAttachmentId(attachmentId)) + '?rev=' + rev;\n\n    ajax$$({}, {\n      method: 'DELETE',\n      url: url\n    }, callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment =\n    adapterFun$$('putAttachment', function (docId, attachmentId, rev, blob,\n                                                type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev) {\n      url += '?rev=' + rev;\n    }\n\n    if (typeof blob === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = atob$1(blob);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    var opts = {\n      headers: {'Content-Type': type},\n      method: 'PUT',\n      url: url,\n      processData: false,\n      body: blob,\n      timeout: ajaxOpts.timeout || 60000\n    };\n    // Add the attachment\n    ajax$$({}, opts, callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return PouchPromise.all(req.docs.map(preprocessAttachments$1));\n    }).then(function () {\n      // Update/create the documents\n      ajax$$(opts, {\n        method: 'POST',\n        url: genDBUrl(host, '_bulk_docs'),\n        timeout: opts.timeout,\n        body: req\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n        results.forEach(function (result) {\n          result.ok = true; // smooths out cloudant not adding this\n        });\n        callback(null, results);\n      });\n    }).catch(callback);\n  };\n\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$1(doc);\n    }).then(function () {\n      // Update/create the document\n      ajax$$(opts, {\n        method: 'PUT',\n        url: genDBUrl(host, encodeDocId(doc._id)),\n        body: doc\n      }, function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n        callback(null, result);\n      });\n    }).catch(callback);\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    // Get the document listing\n    ajaxPromise(opts, {\n      method: method,\n      url: genDBUrl(host, '_all_docs' + paramStr),\n      body: body\n    }).then(function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, res);\n    }).catch(callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n    opts.timeout = ('timeout' in opts) ? opts.timeout :\n      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n      30 * 1000;\n\n    // We give a 5 second buffer for CouchDB changes to respond with\n    // an ok timeout (if a timeout it set)\n    var params = opts.timeout ? {timeout: opts.timeout - (5 * 1000)} : {};\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    //\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    } else {\n      // Default heartbeat to 10 seconds\n      params.heartbeat = 10000;\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n\n    var xhr;\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var xhrOpts = {\n        method: method,\n        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n        timeout: opts.timeout,\n        body: body\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function () {\n        xhr = ajax$$(opts, xhrOpts, callback);\n      }).catch(callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (returnDocs) {\n              results.results.push(c);\n            }\n            opts.onChange(c);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        setTimeout(function () { fetch(lastFetchedSeq, fetched); }, 0);\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        if (xhr) {\n          xhr.abort();\n        }\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax$$(opts, {\n      method: 'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    ajax$$(options, {\n      url: genDBUrl(host, ''),\n      method: 'DELETE'\n    }, function (err, resp) {\n      if (err && err.status && err.status !== 404) {\n        return callback(err);\n      }\n      callback(null, resp);\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nfunction HttpPouch$1 (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  if (a === null) {\n    return 0;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a === b ? 0 : (a < b ? -1 : 1);\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\nfunction TaskQueue$1() {\n  this.promise = new PouchPromise(function (fulfill) {fulfill(); });\n}\nTaskQueue$1.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$1.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction createView(opts) {\n  var sourceDB = opts.db;\n  var viewName = opts.viewName;\n  var mapFun = opts.map;\n  var reduceFun = opts.reduce;\n  var temporary = opts.temporary;\n\n  // the \"undefined\" part is for backwards compatibility\n  var viewSignature = mapFun.toString() + (reduceFun && reduceFun.toString()) +\n    'undefined';\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/mrviews', diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log$2 = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopedEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log$2,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\nvar promisedCallback = function (promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      process.nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      process.nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n};\n\nvar callbackify = function (fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n};\n\n// Promise finally util similar to Q.finally\nvar fin = function (promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n};\n\nvar sequentialize = function (queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n};\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nvar uniq = function (arr) {\n  var map = {};\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    map['$' + arr[i]] = true;\n  }\n\n  var keys = Object.keys(map);\n  var output = new Array(keys.length);\n\n  for (i = 0, len = keys.length; i < len; i++) {\n    output[i] = keys[i].substring(1);\n  }\n  return output;\n};\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$1();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\nfunction tryCode$1(db, fun, args) {\n  // emit an event if there was an error thrown by a map/reduce function.\n  // putting try/catches in a single function also avoids deoptimizations.\n  try {\n    return {\n      output : fun.apply(null, args)\n    };\n  } catch (e) {\n    emitError(db, e);\n    return {error: e};\n  }\n}\n\nfunction sortByKeyThenValue(x, y) {\n  var keyCompare = collate(x.key, y.key);\n  return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n}\n\nfunction sliceResults(results, limit, skip) {\n  skip = skip || 0;\n  if (typeof limit === 'number') {\n    return results.slice(skip, limit + skip);\n  } else if (skip > 0) {\n    return results.slice(skip);\n  }\n  return results;\n}\n\nfunction rowToDocId(row) {\n  var val = row.value;\n  // Users can explicitly specify a joined doc _id, or it\n  // defaults to the doc _id that emitted the key/value.\n  var docId = (val && typeof val === 'object' && val._id) || row.id;\n  return docId;\n}\n\nfunction readAttachmentsAsBlobOrBuffer$1(res) {\n  res.rows.forEach(function (row) {\n    var atts = row.doc && row.doc._attachments;\n    if (!atts) {\n      return;\n    }\n    Object.keys(atts).forEach(function (filename) {\n      var att = atts[filename];\n      atts[filename].data = b64ToBluffer(att.data, att.content_type);\n    });\n  });\n}\n\nfunction postprocessAttachments(opts) {\n  return function (res) {\n    if (opts.include_docs && opts.attachments && opts.binary) {\n      readAttachmentsAsBlobOrBuffer$1(res);\n    }\n    return res;\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction addHttpParam(paramName, opts, params, asJson) {\n  // add an http param from opts to params, optionally json-encoded\n  var val = opts[paramName];\n  if (typeof val !== 'undefined') {\n    if (asJson) {\n      val = encodeURIComponent(JSON.stringify(val));\n    }\n    params.push(paramName + '=' + val);\n  }\n}\n\nfunction coerceInteger(integerCandidate) {\n  if (typeof integerCandidate !== 'undefined') {\n    var asNumber = Number(integerCandidate);\n    // prevents e.g. '1foo' or '1.1' being coerced to 1\n    if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n      return asNumber;\n    } else {\n      return integerCandidate;\n    }\n  }\n}\n\nfunction coerceOptions(opts) {\n  opts.group_level = coerceInteger(opts.group_level);\n  opts.limit = coerceInteger(opts.limit);\n  opts.skip = coerceInteger(opts.skip);\n  return opts;\n}\n\nfunction checkPositiveInteger(number) {\n  if (number) {\n    if (typeof number !== 'number') {\n      return  new QueryParseError('Invalid value for integer: \"' +\n      number + '\"');\n    }\n    if (number < 0) {\n      return new QueryParseError('Invalid value for positive integer: ' +\n        '\"' + number + '\"');\n    }\n  }\n}\n\nfunction checkQueryParseError(options, fun) {\n  var startkeyName = options.descending ? 'endkey' : 'startkey';\n  var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n  if (typeof options[startkeyName] !== 'undefined' &&\n    typeof options[endkeyName] !== 'undefined' &&\n    collate(options[startkeyName], options[endkeyName]) > 0) {\n    throw new QueryParseError('No rows can match your key range, ' +\n    'reverse your start_key and end_key or set {descending : true}');\n  } else if (fun.reduce && options.reduce !== false) {\n    if (options.include_docs) {\n      throw new QueryParseError('{include_docs:true} is invalid for reduce');\n    } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n      throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n      '{group: true}');\n    }\n  }\n  ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n    var error = checkPositiveInteger(options[optionName]);\n    if (error) {\n      throw error;\n    }\n  });\n}\n\nfunction httpQuery(db, fun, opts) {\n  // List of parameters to add to the PUT request\n  var params = [];\n  var body;\n  var method = 'GET';\n\n  // If opts.reduce exists and is defined, then add it to the list\n  // of parameters.\n  // If reduce=false then the results are that of only the map function\n  // not the final result of map and reduce.\n  addHttpParam('reduce', opts, params);\n  addHttpParam('include_docs', opts, params);\n  addHttpParam('attachments', opts, params);\n  addHttpParam('limit', opts, params);\n  addHttpParam('descending', opts, params);\n  addHttpParam('group', opts, params);\n  addHttpParam('group_level', opts, params);\n  addHttpParam('skip', opts, params);\n  addHttpParam('stale', opts, params);\n  addHttpParam('conflicts', opts, params);\n  addHttpParam('startkey', opts, params, true);\n  addHttpParam('start_key', opts, params, true);\n  addHttpParam('endkey', opts, params, true);\n  addHttpParam('end_key', opts, params, true);\n  addHttpParam('inclusive_end', opts, params);\n  addHttpParam('key', opts, params, true);\n\n  // Format the list of parameters into a valid URI query string\n  params = params.join('&');\n  params = params === '' ? '' : '?' + params;\n\n  // If keys are supplied, issue a POST to circumvent GET query string limits\n  // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n  if (typeof opts.keys !== 'undefined') {\n    var MAX_URL_LENGTH = 2000;\n    // according to http://stackoverflow.com/a/417184/680742,\n    // the de facto URL length limit is 2000 characters\n\n    var keysAsString =\n      'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n    if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n      // If the keys are short enough, do a GET. we do this to work around\n      // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n      params += (params[0] === '?' ? '&' : '?') + keysAsString;\n    } else {\n      method = 'POST';\n      if (typeof fun === 'string') {\n        body = {keys: opts.keys};\n      } else { // fun is {map : mapfun}, so append to this\n        fun.keys = opts.keys;\n      }\n    }\n  }\n\n  // We are referencing a query defined in the design doc\n  if (typeof fun === 'string') {\n    var parts = parseViewName(fun);\n    return db.request({\n      method: method,\n      url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // We are using a temporary view, terrible for performance, good for testing\n  body = body || {};\n  Object.keys(fun).forEach(function (key) {\n    if (Array.isArray(fun[key])) {\n      body[key] = fun[key];\n    } else {\n      body[key] = fun[key].toString();\n    }\n  });\n  return db.request({\n    method: 'POST',\n    url: '_temp_view' + params,\n    body: body\n  }).then(postprocessAttachments(opts));\n}\n\n// custom adapters can define their own api._query\n// and override the default behavior\n/* istanbul ignore next */\nfunction customQuery(db, fun, opts) {\n  return new PouchPromise(function (resolve, reject) {\n    db._query(fun, opts, function (err, res) {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n}\n\n// custom adapters can define their own api._viewCleanup\n// and override the default behavior\n/* istanbul ignore next */\nfunction customViewCleanup(db) {\n  return new PouchPromise(function (resolve, reject) {\n    db._viewCleanup(function (err, res) {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n}\n\nfunction defaultsTo(value) {\n  return function (reason) {\n    /* istanbul ignore else */\n    if (reason.status === 404) {\n      return value;\n    } else {\n      throw reason;\n    }\n  };\n}\n\n// returns a promise for a list of docs to update, based on the input docId.\n// the order doesn't matter, because post-3.2.0, bulkDocs\n// is an atomic operation in all three adapters.\nfunction getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n  var metaDocId = '_local/doc_' + docId;\n  var defaultMetaDoc = {_id: metaDocId, keys: []};\n  var docData = docIdsToChangesAndEmits[docId];\n  var indexableKeysToKeyValues = docData.indexableKeysToKeyValues;\n  var changes = docData.changes;\n\n  function getMetaDoc() {\n    if (isGenOne(changes)) {\n      // generation 1, so we can safely assume initial state\n      // for performance reasons (avoids unnecessary GETs)\n      return PouchPromise.resolve(defaultMetaDoc);\n    }\n    return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n  }\n\n  function getKeyValueDocs(metaDoc) {\n    if (!metaDoc.keys.length) {\n      // no keys, no need for a lookup\n      return PouchPromise.resolve({rows: []});\n    }\n    return view.db.allDocs({\n      keys: metaDoc.keys,\n      include_docs: true\n    });\n  }\n\n  function processKvDocs(metaDoc, kvDocsRes) {\n    var kvDocs = [];\n    var oldKeysMap = {};\n\n    for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n      var row = kvDocsRes.rows[i];\n      var doc = row.doc;\n      if (!doc) { // deleted\n        continue;\n      }\n      kvDocs.push(doc);\n      oldKeysMap[doc._id] = true;\n      doc._deleted = !indexableKeysToKeyValues[doc._id];\n      if (!doc._deleted) {\n        var keyValue = indexableKeysToKeyValues[doc._id];\n        if ('value' in keyValue) {\n          doc.value = keyValue.value;\n        }\n      }\n    }\n\n    var newKeys = Object.keys(indexableKeysToKeyValues);\n    newKeys.forEach(function (key) {\n      if (!oldKeysMap[key]) {\n        // new doc\n        var kvDoc = {\n          _id: key\n        };\n        var keyValue = indexableKeysToKeyValues[key];\n        if ('value' in keyValue) {\n          kvDoc.value = keyValue.value;\n        }\n        kvDocs.push(kvDoc);\n      }\n    });\n    metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n    kvDocs.push(metaDoc);\n\n    return kvDocs;\n  }\n\n  return getMetaDoc().then(function (metaDoc) {\n    return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n      return processKvDocs(metaDoc, kvDocsRes);\n    });\n  });\n}\n\n// updates all emitted key/value docs and metaDocs in the mrview database\n// for the given batch of documents from the source database\nfunction saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n  var seqDocId = '_local/lastSeq';\n  return view.db.get(seqDocId)\n  .catch(defaultsTo({_id: seqDocId, seq: 0}))\n  .then(function (lastSeqDoc) {\n    var docIds = Object.keys(docIdsToChangesAndEmits);\n    return PouchPromise.all(docIds.map(function (docId) {\n      return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n    })).then(function (listOfDocsToPersist) {\n      var docsToPersist = flatten(listOfDocsToPersist);\n      lastSeqDoc.seq = seq;\n      docsToPersist.push(lastSeqDoc);\n      // write all docs in a single operation, update the seq once\n      return view.db.bulkDocs({docs : docsToPersist});\n    });\n  });\n}\n\nfunction getQueue(view) {\n  var viewName = typeof view === 'string' ? view : view.name;\n  var queue = persistentQueues[viewName];\n  if (!queue) {\n    queue = persistentQueues[viewName] = new TaskQueue$1();\n  }\n  return queue;\n}\n\nfunction updateView(view) {\n  return sequentialize(getQueue(view), function () {\n    return updateViewInQueue(view);\n  })();\n}\n\nfunction updateViewInQueue(view) {\n  // bind the emit function once\n  var mapResults;\n  var doc;\n\n  function emit(key, value) {\n    var output = {id: doc._id, key: normalizeKey(key)};\n    // Don't explicitly store the value unless it's defined and non-null.\n    // This saves on storage space, because often people don't use it.\n    if (typeof value !== 'undefined' && value !== null) {\n      output.value = normalizeKey(value);\n    }\n    mapResults.push(output);\n  }\n\n  var mapFun;\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof view.mapFun === \"function\" && view.mapFun.length === 2) {\n    var origMap = view.mapFun;\n    mapFun = function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    mapFun = evalFunctionWithEval(view.mapFun.toString(), emit);\n  }\n\n  var currentSeq = view.seq || 0;\n\n  function processChange(docIdsToChangesAndEmits, seq) {\n    return function () {\n      return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n    };\n  }\n\n  var queue = new TaskQueue$1();\n  // TODO(neojski): https://github.com/daleharvey/pouchdb/issues/1521\n\n  return new PouchPromise(function (resolve, reject) {\n\n    function complete() {\n      queue.finish().then(function () {\n        view.seq = currentSeq;\n        resolve();\n      });\n    }\n\n    function processNextBatch() {\n      view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE$1\n      }).on('complete', function (response) {\n        var results = response.results;\n        if (!results.length) {\n          return complete();\n        }\n        var docIdsToChangesAndEmits = {};\n        for (var i = 0, l = results.length; i < l; i++) {\n          var change = results[i];\n          if (change.doc._id[0] !== '_') {\n            mapResults = [];\n            doc = change.doc;\n\n            if (!doc._deleted) {\n              tryCode$1(view.sourceDB, mapFun, [doc]);\n            }\n            mapResults.sort(sortByKeyThenValue);\n\n            var indexableKeysToKeyValues = {};\n            var lastKey;\n            for (var j = 0, jl = mapResults.length; j < jl; j++) {\n              var obj = mapResults[j];\n              var complexKey = [obj.key, obj.id];\n              if (collate(obj.key, lastKey) === 0) {\n                complexKey.push(j); // dup key+id, so make it unique\n              }\n              var indexableKey = toIndexableString(complexKey);\n              indexableKeysToKeyValues[indexableKey] = obj;\n              lastKey = obj.key;\n            }\n            docIdsToChangesAndEmits[change.doc._id] = {\n              indexableKeysToKeyValues: indexableKeysToKeyValues,\n              changes: change.changes\n            };\n          }\n          currentSeq = change.seq;\n        }\n        queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n        if (results.length < CHANGES_BATCH_SIZE$1) {\n          return complete();\n        }\n        return processNextBatch();\n      }).on('error', onError);\n      /* istanbul ignore next */\n      function onError(err) {\n        reject(err);\n      }\n    }\n\n    processNextBatch();\n  });\n}\n\nfunction reduceView(view, results, options) {\n  if (options.group_level === 0) {\n    delete options.group_level;\n  }\n\n  var shouldGroup = options.group || options.group_level;\n\n  var reduceFun;\n  if (builtInReduce[view.reduceFun]) {\n    reduceFun = builtInReduce[view.reduceFun];\n  } else {\n    reduceFun = evalFunctionWithEval(view.reduceFun.toString());\n  }\n\n  var groups = [];\n  var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n    options.group_level;\n  results.forEach(function (e) {\n    var last = groups[groups.length - 1];\n    var groupKey = shouldGroup ? e.key : null;\n\n    // only set group_level for array keys\n    if (shouldGroup && Array.isArray(groupKey)) {\n      groupKey = groupKey.slice(0, lvl);\n    }\n\n    if (last && collate(last.groupKey, groupKey) === 0) {\n      last.keys.push([e.key, e.id]);\n      last.values.push(e.value);\n      return;\n    }\n    groups.push({\n      keys: [[e.key, e.id]],\n      values: [e.value],\n      groupKey: groupKey\n    });\n  });\n  results = [];\n  for (var i = 0, len = groups.length; i < len; i++) {\n    var e = groups[i];\n    var reduceTry = tryCode$1(view.sourceDB, reduceFun,\n      [e.keys, e.values, false]);\n    if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n      // CouchDB returns an error if a built-in errors out\n      throw reduceTry.error;\n    }\n    results.push({\n      // CouchDB just sets the value to null if a non-built-in errors out\n      value: reduceTry.error ? null : reduceTry.output,\n      key: e.groupKey\n    });\n  }\n  // no total_rows/offset when reducing\n  return {rows: sliceResults(results, options.limit, options.skip)};\n}\n\nfunction queryView(view, opts) {\n  return sequentialize(getQueue(view), function () {\n    return queryViewInQueue(view, opts);\n  })();\n}\n\nfunction queryViewInQueue(view, opts) {\n  var totalRows;\n  var shouldReduce = view.reduceFun && opts.reduce !== false;\n  var skip = opts.skip || 0;\n  if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n    // equivalent query\n    opts.limit = 0;\n    delete opts.keys;\n  }\n\n  function fetchFromView(viewOpts) {\n    viewOpts.include_docs = true;\n    return view.db.allDocs(viewOpts).then(function (res) {\n      totalRows = res.total_rows;\n      return res.rows.map(function (result) {\n\n        // implicit migration - in older versions of PouchDB,\n        // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n        // this is tested in a migration test\n        /* istanbul ignore next */\n        if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n          var keys = Object.keys(result.doc.value).sort();\n          // this detection method is not perfect, but it's unlikely the user\n          // emitted a value which was an object with these 3 exact keys\n          var expectedKeys = ['id', 'key', 'value'];\n          if (!(keys < expectedKeys || keys > expectedKeys)) {\n            return result.doc.value;\n          }\n        }\n\n        var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n        return {\n          key: parsedKeyAndDocId[0],\n          id: parsedKeyAndDocId[1],\n          value: ('value' in result.doc ? result.doc.value : null)\n        };\n      });\n    });\n  }\n\n  function onMapResultsReady(rows) {\n    var finalResults;\n    if (shouldReduce) {\n      finalResults = reduceView(view, rows, opts);\n    } else {\n      finalResults = {\n        total_rows: totalRows,\n        offset: skip,\n        rows: rows\n      };\n    }\n    if (opts.include_docs) {\n      var docIds = uniq(rows.map(rowToDocId));\n\n      return view.sourceDB.allDocs({\n        keys: docIds,\n        include_docs: true,\n        conflicts: opts.conflicts,\n        attachments: opts.attachments,\n        binary: opts.binary\n      }).then(function (allDocsRes) {\n        var docIdsToDocs = {};\n        allDocsRes.rows.forEach(function (row) {\n          if (row.doc) {\n            docIdsToDocs['$' + row.id] = row.doc;\n          }\n        });\n        rows.forEach(function (row) {\n          var docId = rowToDocId(row);\n          var doc = docIdsToDocs['$' + docId];\n          if (doc) {\n            row.doc = doc;\n          }\n        });\n        return finalResults;\n      });\n    } else {\n      return finalResults;\n    }\n  }\n\n  if (typeof opts.keys !== 'undefined') {\n    var keys = opts.keys;\n    var fetchPromises = keys.map(function (key) {\n      var viewOpts = {\n        startkey : toIndexableString([key]),\n        endkey   : toIndexableString([key, {}])\n      };\n      return fetchFromView(viewOpts);\n    });\n    return PouchPromise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n  } else { // normal query, no 'keys'\n    var viewOpts = {\n      descending : opts.descending\n    };\n    if (opts.start_key) {\n        opts.startkey = opts.start_key;\n    }\n    if (opts.end_key) {\n        opts.endkey = opts.end_key;\n    }\n    if (typeof opts.startkey !== 'undefined') {\n      viewOpts.startkey = opts.descending ?\n        toIndexableString([opts.startkey, {}]) :\n        toIndexableString([opts.startkey]);\n    }\n    if (typeof opts.endkey !== 'undefined') {\n      var inclusiveEnd = opts.inclusive_end !== false;\n      if (opts.descending) {\n        inclusiveEnd = !inclusiveEnd;\n      }\n\n      viewOpts.endkey = toIndexableString(\n        inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);\n    }\n    if (typeof opts.key !== 'undefined') {\n      var keyStart = toIndexableString([opts.key]);\n      var keyEnd = toIndexableString([opts.key, {}]);\n      if (viewOpts.descending) {\n        viewOpts.endkey = keyStart;\n        viewOpts.startkey = keyEnd;\n      } else {\n        viewOpts.startkey = keyStart;\n        viewOpts.endkey = keyEnd;\n      }\n    }\n    if (!shouldReduce) {\n      if (typeof opts.limit === 'number') {\n        viewOpts.limit = opts.limit;\n      }\n      viewOpts.skip = skip;\n    }\n    return fetchFromView(viewOpts).then(onMapResultsReady);\n  }\n}\n\nfunction httpViewCleanup(db) {\n  return db.request({\n    method: 'POST',\n    url: '_view_cleanup'\n  });\n}\n\nfunction localViewCleanup(db) {\n  return db.get('_local/mrviews').then(function (metaDoc) {\n    var docsToViews = {};\n    Object.keys(metaDoc.views).forEach(function (fullViewName) {\n      var parts = parseViewName(fullViewName);\n      var designDocName = '_design/' + parts[0];\n      var viewName = parts[1];\n      docsToViews[designDocName] = docsToViews[designDocName] || {};\n      docsToViews[designDocName][viewName] = true;\n    });\n    var opts = {\n      keys : Object.keys(docsToViews),\n      include_docs : true\n    };\n    return db.allDocs(opts).then(function (res) {\n      var viewsToStatus = {};\n      res.rows.forEach(function (row) {\n        var ddocName = row.key.substring(8);\n        Object.keys(docsToViews[row.key]).forEach(function (viewName) {\n          var fullViewName = ddocName + '/' + viewName;\n          /* istanbul ignore if */\n          if (!metaDoc.views[fullViewName]) {\n            // new format, without slashes, to support PouchDB 2.2.0\n            // migration test in pouchdb's browser.migration.js verifies this\n            fullViewName = viewName;\n          }\n          var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n          // design doc deleted, or view function nonexistent\n          var statusIsGood = row.doc && row.doc.views &&\n            row.doc.views[viewName];\n          viewDBNames.forEach(function (viewDBName) {\n            viewsToStatus[viewDBName] =\n              viewsToStatus[viewDBName] || statusIsGood;\n          });\n        });\n      });\n      var dbsToDelete = Object.keys(viewsToStatus).filter(\n        function (viewDBName) { return !viewsToStatus[viewDBName]; });\n      var destroyPromises = dbsToDelete.map(function (viewDBName) {\n        return sequentialize(getQueue(viewDBName), function () {\n          return new db.constructor(viewDBName, db.__opts).destroy();\n        })();\n      });\n      return PouchPromise.all(destroyPromises).then(function () {\n        return {ok: true};\n      });\n    });\n  }, defaultsTo({ok: true}));\n}\n\nvar viewCleanup = callbackify(function () {\n  var db = this;\n  if (db.type() === 'http') {\n    return httpViewCleanup(db);\n  }\n  /* istanbul ignore next */\n  if (typeof db._viewCleanup === 'function') {\n    return customViewCleanup(db);\n  }\n  return localViewCleanup(db);\n});\n\nfunction queryPromised(db, fun, opts) {\n  if (db.type() === 'http') {\n    return httpQuery(db, fun, opts);\n  }\n\n  /* istanbul ignore next */\n  if (typeof db._query === 'function') {\n    return customQuery(db, fun, opts);\n  }\n\n  if (typeof fun !== 'string') {\n    // temp_view\n    checkQueryParseError(opts, fun);\n\n    var createViewOpts = {\n      db : db,\n      viewName : 'temp_view/temp_view',\n      map : fun.map,\n      reduce : fun.reduce,\n      temporary : true\n    };\n    tempViewQueue.add(function () {\n      return createView(createViewOpts).then(function (view) {\n        function cleanup() {\n          return view.db.destroy();\n        }\n        return fin(updateView(view).then(function () {\n          return queryView(view, opts);\n        }), cleanup);\n      });\n    });\n    return tempViewQueue.finish();\n  } else {\n    // persistent view\n    var fullViewName = fun;\n    var parts = parseViewName(fullViewName);\n    var designDocName = parts[0];\n    var viewName = parts[1];\n    return db.get('_design/' + designDocName).then(function (doc) {\n      var fun = doc.views && doc.views[viewName];\n\n      if (!fun || typeof fun.map !== 'string') {\n        throw new NotFoundError('ddoc ' + designDocName +\n        ' has no view named ' + viewName);\n      }\n      checkQueryParseError(opts, fun);\n\n      var createViewOpts = {\n        db : db,\n        viewName : fullViewName,\n        map : fun.map,\n        reduce : fun.reduce\n      };\n      return createView(createViewOpts).then(function (view) {\n        if (opts.stale === 'ok' || opts.stale === 'update_after') {\n          if (opts.stale === 'update_after') {\n            process.nextTick(function () {\n              updateView(view);\n            });\n          }\n          return queryView(view, opts);\n        } else { // stale not ok\n          return updateView(view).then(function () {\n            return queryView(view, opts);\n          });\n        }\n      });\n    });\n  }\n}\n\nvar query = function (fun, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts ? coerceOptions(opts) : {};\n\n  if (typeof fun === 'function') {\n    fun = {map : fun};\n  }\n\n  var db = this;\n  var promise = PouchPromise.resolve().then(function () {\n    return queryPromised(db, fun, opts);\n  });\n  promisedCallback(promise, callback);\n  return promise;\n};\n\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction isGenOne$1(rev) {\n  return /^1-/.test(rev);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return PouchPromise.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = src.type() === 'http' && target.type() !== 'http';\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return PouchPromise.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return PouchPromise.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return PouchPromise.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc).then(function (attachments) {\n            var filenames = Object.keys(remoteDoc._attachments);\n            attachments.forEach(function (attachment, i) {\n              var att = remoteDoc._attachments[filenames[i]];\n              delete att.stub;\n              delete att.length;\n              att.data = attachment;\n            });\n\n            return remoteDoc;\n          });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne$1(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return PouchPromise.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.type() === 'http') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  return updateCheckpoint(this.target, this.id, checkpoint,\n    session, this.returnValue);\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  var self = this;\n  if (this.readOnlySource) {\n    return PouchPromise.resolve(true);\n  }\n  return updateCheckpoint(this.src, this.id, checkpoint,\n    session, this.returnValue)\n    .catch(function (err) {\n      if (isForbiddenError(err)) {\n        self.readOnlySource = true;\n        return true;\n      }\n      throw err;\n    });\n};\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.readOnlySource) {\n      return PouchPromise.resolve(targetDoc.last_seq);\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.readOnlySource = true;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return PouchPromise.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds;\n    return new PouchPromise(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate$1(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n\n  result = result || {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return PouchPromise.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n      checkpointer = new Checkpointer(src, target, repId, returnValue);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          if (error.name === 'unauthorized' || error.name === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      fatalError.result = result;\n\n      if (fatalError.name === 'unauthorized' || fatalError.name === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate$1(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq;\n    pendingBatch.changes.push(change);\n    processPendingBatch(batches.length === 0 && changesOpts.live);\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.last_seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })\n        .catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, events.EventEmitter);\nfunction Replication() {\n  events.EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new PouchPromise(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicate(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate$1(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, events.EventEmitter);\nfunction sync(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? extend$1({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? extend$1({}, opts, opts.pull) : opts;\n\n  this.push = replicate(src, target, optsPush);\n  this.pull = replicate(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      self.pull.on('change', pullChange);\n      self.push.on('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.on('denied', pullDenied);\n      self.push.on('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.on('active', pullActive);\n      self.push.on('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.on('paused', pullPaused);\n      self.push.on('paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = PouchPromise.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicate;\n  PouchDB.sync = sync;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      return {\n        from: function (other, opts, callback) {\n          return self.constructor.replicate(other, self, opts, callback);\n        },\n        to: function (other, opts, callback) {\n          return self.constructor.replicate(self, other, opts, callback);\n        }\n      };\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB.plugin(IDBPouch)\n  .plugin(WebSqlPouch)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\n// Pull from src because pouchdb-node/pouchdb-browser themselves\n// are aggressively optimized and jsnext:main would normally give us this\n// aggressive bundle.\n\nmodule.exports = PouchDB;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/lib/index-browser.js\n ** module id = 20\n ** module chunks = 0\n **/","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 21\n ** module chunks = 0\n **/","/**\n * @license\n * lodash lodash.com/license | Underscore.js 1.8.3 underscorejs.org/LICENSE\n */\n;(function(){function t(t,n){return t.set(n[0],n[1]),t}function n(t,n){return t.add(n),t}function r(t,n,r){switch(r.length){case 0:return t.call(n);case 1:return t.call(n,r[0]);case 2:return t.call(n,r[0],r[1]);case 3:return t.call(n,r[0],r[1],r[2])}return t.apply(n,r)}function e(t,n,r,e){for(var u=-1,i=t?t.length:0;++u<i;){var o=t[u];n(e,o,r(o),t)}return e}function u(t,n){for(var r=-1,e=t?t.length:0;++r<e&&false!==n(t[r],r,t););return t}function i(t,n){for(var r=t?t.length:0;r--&&false!==n(t[r],r,t););\nreturn t}function o(t,n){for(var r=-1,e=t?t.length:0;++r<e;)if(!n(t[r],r,t))return false;return true}function f(t,n){for(var r=-1,e=t?t.length:0,u=0,i=[];++r<e;){var o=t[r];n(o,r,t)&&(i[u++]=o)}return i}function c(t,n){return!(!t||!t.length)&&-1<d(t,n,0)}function a(t,n,r){for(var e=-1,u=t?t.length:0;++e<u;)if(r(n,t[e]))return true;return false}function l(t,n){for(var r=-1,e=t?t.length:0,u=Array(e);++r<e;)u[r]=n(t[r],r,t);return u}function s(t,n){for(var r=-1,e=n.length,u=t.length;++r<e;)t[u+r]=n[r];return t}function h(t,n,r,e){\nvar u=-1,i=t?t.length:0;for(e&&i&&(r=t[++u]);++u<i;)r=n(r,t[u],u,t);return r}function p(t,n,r,e){var u=t?t.length:0;for(e&&u&&(r=t[--u]);u--;)r=n(r,t[u],u,t);return r}function _(t,n){for(var r=-1,e=t?t.length:0;++r<e;)if(n(t[r],r,t))return true;return false}function v(t,n,r){var e;return r(t,function(t,r,u){if(n(t,r,u))return e=r,false}),e}function g(t,n,r,e){var u=t.length;for(r+=e?1:-1;e?r--:++r<u;)if(n(t[r],r,t))return r;return-1}function d(t,n,r){if(n===n)t:{--r;for(var e=t.length;++r<e;)if(t[r]===n){t=r;\nbreak t}t=-1}else t=g(t,b,r);return t}function y(t,n,r,e){--r;for(var u=t.length;++r<u;)if(e(t[r],n))return r;return-1}function b(t){return t!==t}function x(t,n){var r=t?t.length:0;return r?k(t,n)/r:P}function j(t){return function(n){return null==n?F:n[t]}}function w(t){return function(n){return null==t?F:t[n]}}function m(t,n,r,e,u){return u(t,function(t,u,i){r=e?(e=false,t):n(r,t,u,i)}),r}function A(t,n){var r=t.length;for(t.sort(n);r--;)t[r]=t[r].c;return t}function k(t,n){for(var r,e=-1,u=t.length;++e<u;){\nvar i=n(t[e]);i!==F&&(r=r===F?i:r+i)}return r}function E(t,n){for(var r=-1,e=Array(t);++r<t;)e[r]=n(r);return e}function O(t,n){return l(n,function(n){return[n,t[n]]})}function S(t){return function(n){return t(n)}}function I(t,n){return l(n,function(n){return t[n]})}function R(t,n){return t.has(n)}function z(t,n){for(var r=-1,e=t.length;++r<e&&-1<d(n,t[r],0););return r}function W(t,n){for(var r=t.length;r--&&-1<d(n,t[r],0););return r}function B(t){return\"\\\\\"+Dt[t]}function L(t){var n=-1,r=Array(t.size);\nreturn t.forEach(function(t,e){r[++n]=[e,t]}),r}function U(t,n){return function(r){return t(n(r))}}function C(t,n){for(var r=-1,e=t.length,u=0,i=[];++r<e;){var o=t[r];o!==n&&\"__lodash_placeholder__\"!==o||(t[r]=\"__lodash_placeholder__\",i[u++]=r)}return i}function M(t){var n=-1,r=Array(t.size);return t.forEach(function(t){r[++n]=t}),r}function D(t){var n=-1,r=Array(t.size);return t.forEach(function(t){r[++n]=[t,t]}),r}function T(t){if(Wt.test(t)){for(var n=Rt.lastIndex=0;Rt.test(t);)++n;t=n}else t=tn(t);\nreturn t}function $(t){return Wt.test(t)?t.match(Rt)||[]:t.split(\"\")}var F,N=1/0,P=NaN,Z=[[\"ary\",128],[\"bind\",1],[\"bindKey\",2],[\"curry\",8],[\"curryRight\",16],[\"flip\",512],[\"partial\",32],[\"partialRight\",64],[\"rearg\",256]],q=/\\b__p\\+='';/g,V=/\\b(__p\\+=)''\\+/g,K=/(__e\\(.*?\\)|\\b__t\\))\\+'';/g,G=/&(?:amp|lt|gt|quot|#39);/g,J=/[&<>\"']/g,Y=RegExp(G.source),H=RegExp(J.source),Q=/<%-([\\s\\S]+?)%>/g,X=/<%([\\s\\S]+?)%>/g,tt=/<%=([\\s\\S]+?)%>/g,nt=/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,rt=/^\\w*$/,et=/^\\./,ut=/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g,it=/[\\\\^$.*+?()[\\]{}|]/g,ot=RegExp(it.source),ft=/^\\s+|\\s+$/g,ct=/^\\s+/,at=/\\s+$/,lt=/\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,st=/\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,ht=/,? & /,pt=/[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g,_t=/\\\\(\\\\)?/g,vt=/\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g,gt=/\\w*$/,dt=/^[-+]0x[0-9a-f]+$/i,yt=/^0b[01]+$/i,bt=/^\\[object .+?Constructor\\]$/,xt=/^0o[0-7]+$/i,jt=/^(?:0|[1-9]\\d*)$/,wt=/[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g,mt=/($^)/,At=/['\\n\\r\\u2028\\u2029\\\\]/g,kt=\"[\\\\ufe0e\\\\ufe0f]?(?:[\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\\\\u20d0-\\\\u20f0]|\\\\ud83c[\\\\udffb-\\\\udfff])?(?:\\\\u200d(?:[^\\\\ud800-\\\\udfff]|(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff])[\\\\ufe0e\\\\ufe0f]?(?:[\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\\\\u20d0-\\\\u20f0]|\\\\ud83c[\\\\udffb-\\\\udfff])?)*\",Et=\"(?:[\\\\u2700-\\\\u27bf]|(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff])\"+kt,Ot=\"(?:[^\\\\ud800-\\\\udfff][\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\\\\u20d0-\\\\u20f0]?|[\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\\\\u20d0-\\\\u20f0]|(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}|[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]|[\\\\ud800-\\\\udfff])\",St=RegExp(\"['\\u2019]\",\"g\"),It=RegExp(\"[\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\\\\u20d0-\\\\u20f0]\",\"g\"),Rt=RegExp(\"\\\\ud83c[\\\\udffb-\\\\udfff](?=\\\\ud83c[\\\\udffb-\\\\udfff])|\"+Ot+kt,\"g\"),zt=RegExp([\"[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]?[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]+(?:['\\u2019](?:d|ll|m|re|s|t|ve))?(?=[\\\\xac\\\\xb1\\\\xd7\\\\xf7\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\\\\u2000-\\\\u206f \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000]|[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]|$)|(?:[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]|[^\\\\ud800-\\\\udfff\\\\xac\\\\xb1\\\\xd7\\\\xf7\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\\\\u2000-\\\\u206f \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\d+\\\\u2700-\\\\u27bfa-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xffA-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde])+(?:['\\u2019](?:D|LL|M|RE|S|T|VE))?(?=[\\\\xac\\\\xb1\\\\xd7\\\\xf7\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\\\\u2000-\\\\u206f \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000]|[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde](?:[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]|[^\\\\ud800-\\\\udfff\\\\xac\\\\xb1\\\\xd7\\\\xf7\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\\\\u2000-\\\\u206f \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\d+\\\\u2700-\\\\u27bfa-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xffA-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde])|$)|[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]?(?:[a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff]|[^\\\\ud800-\\\\udfff\\\\xac\\\\xb1\\\\xd7\\\\xf7\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\\\\u2000-\\\\u206f \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\d+\\\\u2700-\\\\u27bfa-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xffA-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde])+(?:['\\u2019](?:d|ll|m|re|s|t|ve))?|[A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde]+(?:['\\u2019](?:D|LL|M|RE|S|T|VE))?|\\\\d+\",Et].join(\"|\"),\"g\"),Wt=RegExp(\"[\\\\u200d\\\\ud800-\\\\udfff\\\\u0300-\\\\u036f\\\\ufe20-\\\\ufe23\\\\u20d0-\\\\u20f0\\\\ufe0e\\\\ufe0f]\"),Bt=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Lt=\"Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout\".split(\" \"),Ut={};\nUt[\"[object Float32Array]\"]=Ut[\"[object Float64Array]\"]=Ut[\"[object Int8Array]\"]=Ut[\"[object Int16Array]\"]=Ut[\"[object Int32Array]\"]=Ut[\"[object Uint8Array]\"]=Ut[\"[object Uint8ClampedArray]\"]=Ut[\"[object Uint16Array]\"]=Ut[\"[object Uint32Array]\"]=true,Ut[\"[object Arguments]\"]=Ut[\"[object Array]\"]=Ut[\"[object ArrayBuffer]\"]=Ut[\"[object Boolean]\"]=Ut[\"[object DataView]\"]=Ut[\"[object Date]\"]=Ut[\"[object Error]\"]=Ut[\"[object Function]\"]=Ut[\"[object Map]\"]=Ut[\"[object Number]\"]=Ut[\"[object Object]\"]=Ut[\"[object RegExp]\"]=Ut[\"[object Set]\"]=Ut[\"[object String]\"]=Ut[\"[object WeakMap]\"]=false;\nvar Ct={};Ct[\"[object Arguments]\"]=Ct[\"[object Array]\"]=Ct[\"[object ArrayBuffer]\"]=Ct[\"[object DataView]\"]=Ct[\"[object Boolean]\"]=Ct[\"[object Date]\"]=Ct[\"[object Float32Array]\"]=Ct[\"[object Float64Array]\"]=Ct[\"[object Int8Array]\"]=Ct[\"[object Int16Array]\"]=Ct[\"[object Int32Array]\"]=Ct[\"[object Map]\"]=Ct[\"[object Number]\"]=Ct[\"[object Object]\"]=Ct[\"[object RegExp]\"]=Ct[\"[object Set]\"]=Ct[\"[object String]\"]=Ct[\"[object Symbol]\"]=Ct[\"[object Uint8Array]\"]=Ct[\"[object Uint8ClampedArray]\"]=Ct[\"[object Uint16Array]\"]=Ct[\"[object Uint32Array]\"]=true,\nCt[\"[object Error]\"]=Ct[\"[object Function]\"]=Ct[\"[object WeakMap]\"]=false;var Mt,Dt={\"\\\\\":\"\\\\\",\"'\":\"'\",\"\\n\":\"n\",\"\\r\":\"r\",\"\\u2028\":\"u2028\",\"\\u2029\":\"u2029\"},Tt=parseFloat,$t=parseInt,Ft=typeof global==\"object\"&&global&&global.Object===Object&&global,Nt=typeof self==\"object\"&&self&&self.Object===Object&&self,Pt=Ft||Nt||Function(\"return this\")(),Zt=typeof exports==\"object\"&&exports&&!exports.nodeType&&exports,qt=Zt&&typeof module==\"object\"&&module&&!module.nodeType&&module,Vt=qt&&qt.exports===Zt,Kt=Vt&&Ft.h;\nt:{try{Mt=Kt&&Kt.g(\"util\");break t}catch(t){}Mt=void 0}var Gt=Mt&&Mt.isArrayBuffer,Jt=Mt&&Mt.isDate,Yt=Mt&&Mt.isMap,Ht=Mt&&Mt.isRegExp,Qt=Mt&&Mt.isSet,Xt=Mt&&Mt.isTypedArray,tn=j(\"length\"),nn=w({\"\\xc0\":\"A\",\"\\xc1\":\"A\",\"\\xc2\":\"A\",\"\\xc3\":\"A\",\"\\xc4\":\"A\",\"\\xc5\":\"A\",\"\\xe0\":\"a\",\"\\xe1\":\"a\",\"\\xe2\":\"a\",\"\\xe3\":\"a\",\"\\xe4\":\"a\",\"\\xe5\":\"a\",\"\\xc7\":\"C\",\"\\xe7\":\"c\",\"\\xd0\":\"D\",\"\\xf0\":\"d\",\"\\xc8\":\"E\",\"\\xc9\":\"E\",\"\\xca\":\"E\",\"\\xcb\":\"E\",\"\\xe8\":\"e\",\"\\xe9\":\"e\",\"\\xea\":\"e\",\"\\xeb\":\"e\",\"\\xcc\":\"I\",\"\\xcd\":\"I\",\"\\xce\":\"I\",\"\\xcf\":\"I\",\n\"\\xec\":\"i\",\"\\xed\":\"i\",\"\\xee\":\"i\",\"\\xef\":\"i\",\"\\xd1\":\"N\",\"\\xf1\":\"n\",\"\\xd2\":\"O\",\"\\xd3\":\"O\",\"\\xd4\":\"O\",\"\\xd5\":\"O\",\"\\xd6\":\"O\",\"\\xd8\":\"O\",\"\\xf2\":\"o\",\"\\xf3\":\"o\",\"\\xf4\":\"o\",\"\\xf5\":\"o\",\"\\xf6\":\"o\",\"\\xf8\":\"o\",\"\\xd9\":\"U\",\"\\xda\":\"U\",\"\\xdb\":\"U\",\"\\xdc\":\"U\",\"\\xf9\":\"u\",\"\\xfa\":\"u\",\"\\xfb\":\"u\",\"\\xfc\":\"u\",\"\\xdd\":\"Y\",\"\\xfd\":\"y\",\"\\xff\":\"y\",\"\\xc6\":\"Ae\",\"\\xe6\":\"ae\",\"\\xde\":\"Th\",\"\\xfe\":\"th\",\"\\xdf\":\"ss\",\"\\u0100\":\"A\",\"\\u0102\":\"A\",\"\\u0104\":\"A\",\"\\u0101\":\"a\",\"\\u0103\":\"a\",\"\\u0105\":\"a\",\"\\u0106\":\"C\",\"\\u0108\":\"C\",\"\\u010a\":\"C\",\"\\u010c\":\"C\",\n\"\\u0107\":\"c\",\"\\u0109\":\"c\",\"\\u010b\":\"c\",\"\\u010d\":\"c\",\"\\u010e\":\"D\",\"\\u0110\":\"D\",\"\\u010f\":\"d\",\"\\u0111\":\"d\",\"\\u0112\":\"E\",\"\\u0114\":\"E\",\"\\u0116\":\"E\",\"\\u0118\":\"E\",\"\\u011a\":\"E\",\"\\u0113\":\"e\",\"\\u0115\":\"e\",\"\\u0117\":\"e\",\"\\u0119\":\"e\",\"\\u011b\":\"e\",\"\\u011c\":\"G\",\"\\u011e\":\"G\",\"\\u0120\":\"G\",\"\\u0122\":\"G\",\"\\u011d\":\"g\",\"\\u011f\":\"g\",\"\\u0121\":\"g\",\"\\u0123\":\"g\",\"\\u0124\":\"H\",\"\\u0126\":\"H\",\"\\u0125\":\"h\",\"\\u0127\":\"h\",\"\\u0128\":\"I\",\"\\u012a\":\"I\",\"\\u012c\":\"I\",\"\\u012e\":\"I\",\"\\u0130\":\"I\",\"\\u0129\":\"i\",\"\\u012b\":\"i\",\"\\u012d\":\"i\",\"\\u012f\":\"i\",\n\"\\u0131\":\"i\",\"\\u0134\":\"J\",\"\\u0135\":\"j\",\"\\u0136\":\"K\",\"\\u0137\":\"k\",\"\\u0138\":\"k\",\"\\u0139\":\"L\",\"\\u013b\":\"L\",\"\\u013d\":\"L\",\"\\u013f\":\"L\",\"\\u0141\":\"L\",\"\\u013a\":\"l\",\"\\u013c\":\"l\",\"\\u013e\":\"l\",\"\\u0140\":\"l\",\"\\u0142\":\"l\",\"\\u0143\":\"N\",\"\\u0145\":\"N\",\"\\u0147\":\"N\",\"\\u014a\":\"N\",\"\\u0144\":\"n\",\"\\u0146\":\"n\",\"\\u0148\":\"n\",\"\\u014b\":\"n\",\"\\u014c\":\"O\",\"\\u014e\":\"O\",\"\\u0150\":\"O\",\"\\u014d\":\"o\",\"\\u014f\":\"o\",\"\\u0151\":\"o\",\"\\u0154\":\"R\",\"\\u0156\":\"R\",\"\\u0158\":\"R\",\"\\u0155\":\"r\",\"\\u0157\":\"r\",\"\\u0159\":\"r\",\"\\u015a\":\"S\",\"\\u015c\":\"S\",\"\\u015e\":\"S\",\n\"\\u0160\":\"S\",\"\\u015b\":\"s\",\"\\u015d\":\"s\",\"\\u015f\":\"s\",\"\\u0161\":\"s\",\"\\u0162\":\"T\",\"\\u0164\":\"T\",\"\\u0166\":\"T\",\"\\u0163\":\"t\",\"\\u0165\":\"t\",\"\\u0167\":\"t\",\"\\u0168\":\"U\",\"\\u016a\":\"U\",\"\\u016c\":\"U\",\"\\u016e\":\"U\",\"\\u0170\":\"U\",\"\\u0172\":\"U\",\"\\u0169\":\"u\",\"\\u016b\":\"u\",\"\\u016d\":\"u\",\"\\u016f\":\"u\",\"\\u0171\":\"u\",\"\\u0173\":\"u\",\"\\u0174\":\"W\",\"\\u0175\":\"w\",\"\\u0176\":\"Y\",\"\\u0177\":\"y\",\"\\u0178\":\"Y\",\"\\u0179\":\"Z\",\"\\u017b\":\"Z\",\"\\u017d\":\"Z\",\"\\u017a\":\"z\",\"\\u017c\":\"z\",\"\\u017e\":\"z\",\"\\u0132\":\"IJ\",\"\\u0133\":\"ij\",\"\\u0152\":\"Oe\",\"\\u0153\":\"oe\",\"\\u0149\":\"'n\",\n\"\\u017f\":\"s\"}),rn=w({\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#39;\"}),en=w({\"&amp;\":\"&\",\"&lt;\":\"<\",\"&gt;\":\">\",\"&quot;\":'\"',\"&#39;\":\"'\"}),un=function w(kt){function Et(t){return fi.call(t)}function Ot(t){if(vu(t)&&!nf(t)&&!(t instanceof Dt)){if(t instanceof Mt)return t;if(ui.call(t,\"__wrapped__\"))return De(t)}return new Mt(t)}function Rt(){}function Mt(t,n){this.__wrapped__=t,this.__actions__=[],this.__chain__=!!n,this.__index__=0,this.__values__=F}function Dt(t){this.__wrapped__=t,this.__actions__=[],\nthis.__dir__=1,this.__filtered__=false,this.__iteratees__=[],this.__takeCount__=4294967295,this.__views__=[]}function Ft(t){var n=-1,r=t?t.length:0;for(this.clear();++n<r;){var e=t[n];this.set(e[0],e[1])}}function Nt(t){var n=-1,r=t?t.length:0;for(this.clear();++n<r;){var e=t[n];this.set(e[0],e[1])}}function Zt(t){var n=-1,r=t?t.length:0;for(this.clear();++n<r;){var e=t[n];this.set(e[0],e[1])}}function qt(t){var n=-1,r=t?t.length:0;for(this.__data__=new Zt;++n<r;)this.add(t[n])}function Kt(t){this.size=(this.__data__=new Nt(t)).size;\n}function tn(t,n){var r,e=nf(t),u=!e&&tf(t),i=!e&&!u&&ef(t),o=!e&&!u&&!i&&af(t),u=(e=e||u||i||o)?E(t.length,Hu):[],f=u.length;for(r in t)!n&&!ui.call(t,r)||e&&(\"length\"==r||i&&(\"offset\"==r||\"parent\"==r)||o&&(\"buffer\"==r||\"byteLength\"==r||\"byteOffset\"==r)||me(r,f))||u.push(r);return u}function on(t){var n=t.length;return n?t[cr(0,n-1)]:F}function fn(t,n){return Le(Cr(t),dn(n,0,t.length))}function cn(t){return Le(Cr(t))}function an(t,n,r,e){return t===F||fu(t,ti[r])&&!ui.call(e,r)?n:t}function ln(t,n,r){\n(r===F||fu(t[n],r))&&(r!==F||n in t)||vn(t,n,r)}function sn(t,n,r){var e=t[n];ui.call(t,n)&&fu(e,r)&&(r!==F||n in t)||vn(t,n,r)}function hn(t,n){for(var r=t.length;r--;)if(fu(t[r][0],n))return r;return-1}function pn(t,n,r,e){return to(t,function(t,u,i){n(e,t,r(t),i)}),e}function _n(t,n){return t&&Mr(n,Iu(n),t)}function vn(t,n,r){\"__proto__\"==n&&xi?xi(t,n,{configurable:true,enumerable:true,value:r,writable:true}):t[n]=r}function gn(t,n){for(var r=-1,e=null==t,u=n.length,i=Zu(u);++r<u;)i[r]=e?F:Ou(t,n[r]);\nreturn i}function dn(t,n,r){return t===t&&(r!==F&&(t=t<=r?t:r),n!==F&&(t=t>=n?t:n)),t}function yn(t,n,r,e,i,o,f){var c;if(e&&(c=o?e(t,i,o,f):e(t)),c!==F)return c;if(!_u(t))return t;if(i=nf(t)){if(c=be(t),!n)return Cr(t,c)}else{var a=Et(t),l=\"[object Function]\"==a||\"[object GeneratorFunction]\"==a;if(ef(t))return Rr(t,n);if(\"[object Object]\"==a||\"[object Arguments]\"==a||l&&!o){if(c=xe(l?{}:t),!n)return Dr(t,_n(c,t))}else{if(!Ct[a])return o?t:{};c=je(t,a,yn,n)}}if(f||(f=new Kt),o=f.get(t))return o;f.set(t,c);\nvar s=i?F:(r?se:Iu)(t);return u(s||t,function(u,i){s&&(i=u,u=t[i]),sn(c,i,yn(u,n,r,e,i,t,f))}),c}function bn(t){var n=Iu(t);return function(r){return xn(r,t,n)}}function xn(t,n,r){var e=r.length;if(null==t)return!e;for(t=Ju(t);e--;){var u=r[e],i=n[u],o=t[u];if(o===F&&!(u in t)||!i(o))return false}return true}function jn(t,n,r){if(typeof t!=\"function\")throw new Qu(\"Expected a function\");return po(function(){t.apply(F,r)},n)}function wn(t,n,r,e){var u=-1,i=c,o=true,f=t.length,s=[],h=n.length;if(!f)return s;r&&(n=l(n,S(r))),\ne?(i=a,o=false):200<=n.length&&(i=R,o=false,n=new qt(n));t:for(;++u<f;){var p=t[u],_=r?r(p):p,p=e||0!==p?p:0;if(o&&_===_){for(var v=h;v--;)if(n[v]===_)continue t;s.push(p)}else i(n,_,e)||s.push(p)}return s}function mn(t,n){var r=true;return to(t,function(t,e,u){return r=!!n(t,e,u)}),r}function An(t,n,r){for(var e=-1,u=t.length;++e<u;){var i=t[e],o=n(i);if(null!=o&&(f===F?o===o&&!bu(o):r(o,f)))var f=o,c=i}return c}function kn(t,n){var r=[];return to(t,function(t,e,u){n(t,e,u)&&r.push(t)}),r}function En(t,n,r,e,u){\nvar i=-1,o=t.length;for(r||(r=we),u||(u=[]);++i<o;){var f=t[i];0<n&&r(f)?1<n?En(f,n-1,r,e,u):s(u,f):e||(u[u.length]=f)}return u}function On(t,n){return t&&ro(t,n,Iu)}function Sn(t,n){return t&&eo(t,n,Iu)}function In(t,n){return f(n,function(n){return su(t[n])})}function Rn(t,n){n=ke(n,t)?[n]:Sr(n);for(var r=0,e=n.length;null!=t&&r<e;)t=t[Ue(n[r++])];return r&&r==e?t:F}function zn(t,n,r){return n=n(t),nf(t)?n:s(n,r(t))}function Wn(t,n){return t>n}function Bn(t,n){return null!=t&&ui.call(t,n)}function Ln(t,n){\nreturn null!=t&&n in Ju(t)}function Un(t,n,r){for(var e=r?a:c,u=t[0].length,i=t.length,o=i,f=Zu(i),s=1/0,h=[];o--;){var p=t[o];o&&n&&(p=l(p,S(n))),s=Wi(p.length,s),f[o]=!r&&(n||120<=u&&120<=p.length)?new qt(o&&p):F}var p=t[0],_=-1,v=f[0];t:for(;++_<u&&h.length<s;){var g=p[_],d=n?n(g):g,g=r||0!==g?g:0;if(v?!R(v,d):!e(h,d,r)){for(o=i;--o;){var y=f[o];if(y?!R(y,d):!e(t[o],d,r))continue t}v&&v.push(d),h.push(g)}}return h}function Cn(t,n,r){var e={};return On(t,function(t,u,i){n(e,r(t),u,i)}),e}function Mn(t,n,e){\nreturn ke(n,t)||(n=Sr(n),t=ze(t,n),n=Pe(n)),n=null==t?t:t[Ue(n)],null==n?F:r(n,t,e)}function Dn(t){return vu(t)&&\"[object Arguments]\"==fi.call(t)}function Tn(t){return vu(t)&&\"[object ArrayBuffer]\"==fi.call(t)}function $n(t){return vu(t)&&\"[object Date]\"==fi.call(t)}function Fn(t,n,r,e,u){if(t===n)n=true;else if(null==t||null==n||!_u(t)&&!vu(n))n=t!==t&&n!==n;else t:{var i=nf(t),o=nf(n),f=\"[object Array]\",c=\"[object Array]\";i||(f=Et(t),f=\"[object Arguments]\"==f?\"[object Object]\":f),o||(c=Et(n),c=\"[object Arguments]\"==c?\"[object Object]\":c);\nvar a=\"[object Object]\"==f,o=\"[object Object]\"==c;if((c=f==c)&&ef(t)){if(!ef(n)){n=false;break t}i=true,a=false}if(c&&!a)u||(u=new Kt),n=i||af(t)?ce(t,n,Fn,r,e,u):ae(t,n,f,Fn,r,e,u);else{if(!(2&e)&&(i=a&&ui.call(t,\"__wrapped__\"),f=o&&ui.call(n,\"__wrapped__\"),i||f)){t=i?t.value():t,n=f?n.value():n,u||(u=new Kt),n=Fn(t,n,r,e,u);break t}if(c)n:if(u||(u=new Kt),i=2&e,f=Iu(t),o=f.length,c=Iu(n).length,o==c||i){for(a=o;a--;){var l=f[a];if(!(i?l in n:ui.call(n,l))){n=false;break n}}if((c=u.get(t))&&u.get(n))n=c==n;else{\nc=true,u.set(t,n),u.set(n,t);for(var s=i;++a<o;){var l=f[a],h=t[l],p=n[l];if(r)var _=i?r(p,h,l,n,t,u):r(h,p,l,t,n,u);if(_===F?h!==p&&!Fn(h,p,r,e,u):!_){c=false;break}s||(s=\"constructor\"==l)}c&&!s&&(r=t.constructor,e=n.constructor,r!=e&&\"constructor\"in t&&\"constructor\"in n&&!(typeof r==\"function\"&&r instanceof r&&typeof e==\"function\"&&e instanceof e)&&(c=false)),u.delete(t),u.delete(n),n=c}}else n=false;else n=false}}return n}function Nn(t){return vu(t)&&\"[object Map]\"==Et(t)}function Pn(t,n,r,e){var u=r.length,i=u,o=!e;\nif(null==t)return!i;for(t=Ju(t);u--;){var f=r[u];if(o&&f[2]?f[1]!==t[f[0]]:!(f[0]in t))return false}for(;++u<i;){var f=r[u],c=f[0],a=t[c],l=f[1];if(o&&f[2]){if(a===F&&!(c in t))return false}else{if(f=new Kt,e)var s=e(a,l,c,t,n,f);if(s===F?!Fn(l,a,e,3,f):!s)return false}}return true}function Zn(t){return!(!_u(t)||ri&&ri in t)&&(su(t)?ai:bt).test(Ce(t))}function qn(t){return _u(t)&&\"[object RegExp]\"==fi.call(t)}function Vn(t){return vu(t)&&\"[object Set]\"==Et(t)}function Kn(t){return vu(t)&&pu(t.length)&&!!Ut[fi.call(t)];\n}function Gn(t){return typeof t==\"function\"?t:null==t?Mu:typeof t==\"object\"?nf(t)?Xn(t[0],t[1]):Qn(t):Fu(t)}function Jn(t){if(!Oe(t))return Ri(t);var n,r=[];for(n in Ju(t))ui.call(t,n)&&\"constructor\"!=n&&r.push(n);return r}function Yn(t,n){return t<n}function Hn(t,n){var r=-1,e=cu(t)?Zu(t.length):[];return to(t,function(t,u,i){e[++r]=n(t,u,i)}),e}function Qn(t){var n=ge(t);return 1==n.length&&n[0][2]?Se(n[0][0],n[0][1]):function(r){return r===t||Pn(r,t,n)}}function Xn(t,n){return ke(t)&&n===n&&!_u(n)?Se(Ue(t),n):function(r){\nvar e=Ou(r,t);return e===F&&e===n?Su(r,t):Fn(n,e,F,3)}}function tr(t,n,r,e,u){t!==n&&ro(n,function(i,o){if(_u(i)){u||(u=new Kt);var f=u,c=t[o],a=n[o],l=f.get(a);if(l)ln(t,o,l);else{var l=e?e(c,a,o+\"\",t,n,f):F,s=l===F;if(s){var h=nf(a),p=!h&&ef(a),_=!h&&!p&&af(a),l=a;h||p||_?nf(c)?l=c:au(c)?l=Cr(c):p?(s=false,l=Rr(a,true)):_?(s=false,l=Wr(a,true)):l=[]:du(a)||tf(a)?(l=c,tf(c)?l=ku(c):(!_u(c)||r&&su(c))&&(l=xe(a))):s=false}s&&(f.set(a,l),tr(l,a,r,e,f),f.delete(a)),ln(t,o,l)}}else f=e?e(t[o],i,o+\"\",t,n,u):F,f===F&&(f=i),\nln(t,o,f)},Ru)}function nr(t,n){var r=t.length;if(r)return n+=0>n?r:0,me(n,r)?t[n]:F}function rr(t,n,r){var e=-1;return n=l(n.length?n:[Mu],S(_e())),t=Hn(t,function(t){return{a:l(n,function(n){return n(t)}),b:++e,c:t}}),A(t,function(t,n){var e;t:{e=-1;for(var u=t.a,i=n.a,o=u.length,f=r.length;++e<o;){var c=Br(u[e],i[e]);if(c){e=e>=f?c:c*(\"desc\"==r[e]?-1:1);break t}}e=t.b-n.b}return e})}function er(t,n){return t=Ju(t),ur(t,n,function(n,r){return r in t})}function ur(t,n,r){for(var e=-1,u=n.length,i={};++e<u;){\nvar o=n[e],f=t[o];r(f,o)&&vn(i,o,f)}return i}function ir(t){return function(n){return Rn(n,t)}}function or(t,n,r,e){var u=e?y:d,i=-1,o=n.length,f=t;for(t===n&&(n=Cr(n)),r&&(f=l(t,S(r)));++i<o;)for(var c=0,a=n[i],a=r?r(a):a;-1<(c=u(f,a,c,e));)f!==t&&yi.call(f,c,1),yi.call(t,c,1);return t}function fr(t,n){for(var r=t?n.length:0,e=r-1;r--;){var u=n[r];if(r==e||u!==i){var i=u;if(me(u))yi.call(t,u,1);else if(ke(u,t))delete t[Ue(u)];else{var u=Sr(u),o=ze(t,u);null!=o&&delete o[Ue(Pe(u))]}}}}function cr(t,n){\nreturn t+ki(Ui()*(n-t+1))}function ar(t,n){var r=\"\";if(!t||1>n||9007199254740991<n)return r;do n%2&&(r+=t),(n=ki(n/2))&&(t+=t);while(n);return r}function lr(t,n){return _o(Re(t,n,Mu),t+\"\")}function sr(t){return on(Wu(t))}function hr(t,n){var r=Wu(t);return Le(r,dn(n,0,r.length))}function pr(t,n,r,e){if(!_u(t))return t;n=ke(n,t)?[n]:Sr(n);for(var u=-1,i=n.length,o=i-1,f=t;null!=f&&++u<i;){var c=Ue(n[u]),a=r;if(u!=o){var l=f[c],a=e?e(l,c,f):F;a===F&&(a=_u(l)?l:me(n[u+1])?[]:{})}sn(f,c,a),f=f[c]}return t;\n}function _r(t){return Le(Wu(t))}function vr(t,n,r){var e=-1,u=t.length;for(0>n&&(n=-n>u?0:u+n),r=r>u?u:r,0>r&&(r+=u),u=n>r?0:r-n>>>0,n>>>=0,r=Zu(u);++e<u;)r[e]=t[e+n];return r}function gr(t,n){var r;return to(t,function(t,e,u){return r=n(t,e,u),!r}),!!r}function dr(t,n,r){var e=0,u=t?t.length:e;if(typeof n==\"number\"&&n===n&&2147483647>=u){for(;e<u;){var i=e+u>>>1,o=t[i];null!==o&&!bu(o)&&(r?o<=n:o<n)?e=i+1:u=i}return u}return yr(t,n,Mu,r)}function yr(t,n,r,e){n=r(n);for(var u=0,i=t?t.length:0,o=n!==n,f=null===n,c=bu(n),a=n===F;u<i;){\nvar l=ki((u+i)/2),s=r(t[l]),h=s!==F,p=null===s,_=s===s,v=bu(s);(o?e||_:a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):p||v?0:e?s<=n:s<n)?u=l+1:i=l}return Wi(i,4294967294)}function br(t,n){for(var r=-1,e=t.length,u=0,i=[];++r<e;){var o=t[r],f=n?n(o):o;if(!r||!fu(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function xr(t){return typeof t==\"number\"?t:bu(t)?P:+t}function jr(t){if(typeof t==\"string\")return t;if(nf(t))return l(t,jr)+\"\";if(bu(t))return Qi?Qi.call(t):\"\";var n=t+\"\";return\"0\"==n&&1/t==-N?\"-0\":n;\n}function wr(t,n,r){var e=-1,u=c,i=t.length,o=true,f=[],l=f;if(r)o=false,u=a;else if(200<=i){if(u=n?null:fo(t))return M(u);o=false,u=R,l=new qt}else l=n?[]:f;t:for(;++e<i;){var s=t[e],h=n?n(s):s,s=r||0!==s?s:0;if(o&&h===h){for(var p=l.length;p--;)if(l[p]===h)continue t;n&&l.push(h),f.push(s)}else u(l,h,r)||(l!==f&&l.push(h),f.push(s))}return f}function mr(t,n,r,e){for(var u=t.length,i=e?u:-1;(e?i--:++i<u)&&n(t[i],i,t););return r?vr(t,e?0:i,e?i+1:u):vr(t,e?i+1:0,e?u:i)}function Ar(t,n){var r=t;return r instanceof Dt&&(r=r.value()),\nh(n,function(t,n){return n.func.apply(n.thisArg,s([t],n.args))},r)}function kr(t,n,r){for(var e=-1,u=t.length;++e<u;)var i=i?s(wn(i,t[e],n,r),wn(t[e],i,n,r)):t[e];return i&&i.length?wr(i,n,r):[]}function Er(t,n,r){for(var e=-1,u=t.length,i=n.length,o={};++e<u;)r(o,t[e],e<i?n[e]:F);return o}function Or(t){return au(t)?t:[]}function Sr(t){return nf(t)?t:vo(t)}function Ir(t,n,r){var e=t.length;return r=r===F?e:r,!n&&r>=e?t:vr(t,n,r)}function Rr(t,n){if(n)return t.slice();var r=t.length,r=pi?pi(r):new t.constructor(r);\nreturn t.copy(r),r}function zr(t){var n=new t.constructor(t.byteLength);return new hi(n).set(new hi(t)),n}function Wr(t,n){return new t.constructor(n?zr(t.buffer):t.buffer,t.byteOffset,t.length)}function Br(t,n){if(t!==n){var r=t!==F,e=null===t,u=t===t,i=bu(t),o=n!==F,f=null===n,c=n===n,a=bu(n);if(!f&&!a&&!i&&t>n||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&t<n||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Lr(t,n,r,e){var u=-1,i=t.length,o=r.length,f=-1,c=n.length,a=zi(i-o,0),l=Zu(c+a);\nfor(e=!e;++f<c;)l[f]=n[f];for(;++u<o;)(e||u<i)&&(l[r[u]]=t[u]);for(;a--;)l[f++]=t[u++];return l}function Ur(t,n,r,e){var u=-1,i=t.length,o=-1,f=r.length,c=-1,a=n.length,l=zi(i-f,0),s=Zu(l+a);for(e=!e;++u<l;)s[u]=t[u];for(l=u;++c<a;)s[l+c]=n[c];for(;++o<f;)(e||u<i)&&(s[l+r[o]]=t[u++]);return s}function Cr(t,n){var r=-1,e=t.length;for(n||(n=Zu(e));++r<e;)n[r]=t[r];return n}function Mr(t,n,r,e){var u=!r;r||(r={});for(var i=-1,o=n.length;++i<o;){var f=n[i],c=e?e(r[f],t[f],f,r,t):F;c===F&&(c=t[f]),u?vn(r,f,c):sn(r,f,c);\n}return r}function Dr(t,n){return Mr(t,ao(t),n)}function Tr(t,n){return function(r,u){var i=nf(r)?e:pn,o=n?n():{};return i(r,t,_e(u,2),o)}}function $r(t){return lr(function(n,r){var e=-1,u=r.length,i=1<u?r[u-1]:F,o=2<u?r[2]:F,i=3<t.length&&typeof i==\"function\"?(u--,i):F;for(o&&Ae(r[0],r[1],o)&&(i=3>u?F:i,u=1),n=Ju(n);++e<u;)(o=r[e])&&t(n,o,e,i);return n})}function Fr(t,n){return function(r,e){if(null==r)return r;if(!cu(r))return t(r,e);for(var u=r.length,i=n?u:-1,o=Ju(r);(n?i--:++i<u)&&false!==e(o[i],i,o););\nreturn r}}function Nr(t){return function(n,r,e){var u=-1,i=Ju(n);e=e(n);for(var o=e.length;o--;){var f=e[t?o:++u];if(false===r(i[f],f,i))break}return n}}function Pr(t,n,r){function e(){return(this&&this!==Pt&&this instanceof e?i:t).apply(u?r:this,arguments)}var u=1&n,i=Vr(t);return e}function Zr(t){return function(n){n=Eu(n);var r=Wt.test(n)?$(n):F,e=r?r[0]:n.charAt(0);return n=r?Ir(r,1).join(\"\"):n.slice(1),e[t]()+n}}function qr(t){return function(n){return h(Uu(Lu(n).replace(St,\"\")),t,\"\")}}function Vr(t){\nreturn function(){var n=arguments;switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3]);case 5:return new t(n[0],n[1],n[2],n[3],n[4]);case 6:return new t(n[0],n[1],n[2],n[3],n[4],n[5]);case 7:return new t(n[0],n[1],n[2],n[3],n[4],n[5],n[6])}var r=Xi(t.prototype),n=t.apply(r,n);return _u(n)?n:r}}function Kr(t,n,e){function u(){for(var o=arguments.length,f=Zu(o),c=o,a=pe(u);c--;)f[c]=arguments[c];\nreturn c=3>o&&f[0]!==a&&f[o-1]!==a?[]:C(f,a),o-=c.length,o<e?ue(t,n,Yr,u.placeholder,F,f,c,F,F,e-o):r(this&&this!==Pt&&this instanceof u?i:t,this,f)}var i=Vr(t);return u}function Gr(t){return function(n,r,e){var u=Ju(n);if(!cu(n)){var i=_e(r,3);n=Iu(n),r=function(t){return i(u[t],t,u)}}return r=t(n,r,e),-1<r?u[i?n[r]:r]:F}}function Jr(t){return le(function(n){var r=n.length,e=r,u=Mt.prototype.thru;for(t&&n.reverse();e--;){var i=n[e];if(typeof i!=\"function\")throw new Qu(\"Expected a function\");if(u&&!o&&\"wrapper\"==he(i))var o=new Mt([],true);\n}for(e=o?e:r;++e<r;)var i=n[e],u=he(i),f=\"wrapper\"==u?co(i):F,o=f&&Ee(f[0])&&424==f[1]&&!f[4].length&&1==f[9]?o[he(f[0])].apply(o,f[3]):1==i.length&&Ee(i)?o[u]():o.thru(i);return function(){var t=arguments,e=t[0];if(o&&1==t.length&&nf(e)&&200<=e.length)return o.plant(e).value();for(var u=0,t=r?n[u].apply(this,t):e;++u<r;)t=n[u].call(this,t);return t}})}function Yr(t,n,r,e,u,i,o,f,c,a){function l(){for(var d=arguments.length,y=Zu(d),b=d;b--;)y[b]=arguments[b];if(_){var x,j=pe(l),b=y.length;for(x=0;b--;)y[b]===j&&++x;\n}if(e&&(y=Lr(y,e,u,_)),i&&(y=Ur(y,i,o,_)),d-=x,_&&d<a)return j=C(y,j),ue(t,n,Yr,l.placeholder,r,y,j,f,c,a-d);if(j=h?r:this,b=p?j[t]:t,d=y.length,f){x=y.length;for(var w=Wi(f.length,x),m=Cr(y);w--;){var A=f[w];y[w]=me(A,x)?m[A]:F}}else v&&1<d&&y.reverse();return s&&c<d&&(y.length=c),this&&this!==Pt&&this instanceof l&&(b=g||Vr(b)),b.apply(j,y)}var s=128&n,h=1&n,p=2&n,_=24&n,v=512&n,g=p?F:Vr(t);return l}function Hr(t,n){return function(r,e){return Cn(r,t,n(e))}}function Qr(t,n){return function(r,e){\nvar u;if(r===F&&e===F)return n;if(r!==F&&(u=r),e!==F){if(u===F)return e;typeof r==\"string\"||typeof e==\"string\"?(r=jr(r),e=jr(e)):(r=xr(r),e=xr(e)),u=t(r,e)}return u}}function Xr(t){return le(function(n){return n=l(n,S(_e())),lr(function(e){var u=this;return t(n,function(t){return r(t,u,e)})})})}function te(t,n){n=n===F?\" \":jr(n);var r=n.length;return 2>r?r?ar(n,t):n:(r=ar(n,Ai(t/T(n))),Wt.test(n)?Ir($(r),0,t).join(\"\"):r.slice(0,t))}function ne(t,n,e,u){function i(){for(var n=-1,c=arguments.length,a=-1,l=u.length,s=Zu(l+c),h=this&&this!==Pt&&this instanceof i?f:t;++a<l;)s[a]=u[a];\nfor(;c--;)s[a++]=arguments[++n];return r(h,o?e:this,s)}var o=1&n,f=Vr(t);return i}function re(t){return function(n,r,e){e&&typeof e!=\"number\"&&Ae(n,r,e)&&(r=e=F),n=ju(n),r===F?(r=n,n=0):r=ju(r),e=e===F?n<r?1:-1:ju(e);var u=-1;r=zi(Ai((r-n)/(e||1)),0);for(var i=Zu(r);r--;)i[t?r:++u]=n,n+=e;return i}}function ee(t){return function(n,r){return typeof n==\"string\"&&typeof r==\"string\"||(n=Au(n),r=Au(r)),t(n,r)}}function ue(t,n,r,e,u,i,o,f,c,a){var l=8&n,s=l?o:F;o=l?F:o;var h=l?i:F;return i=l?F:i,n=(n|(l?32:64))&~(l?64:32),\n4&n||(n&=-4),u=[t,n,u,h,s,i,o,f,c,a],r=r.apply(F,u),Ee(t)&&ho(r,u),r.placeholder=e,We(r,t,n)}function ie(t){var n=Gu[t];return function(t,r){if(t=Au(t),r=Wi(wu(r),292)){var e=(Eu(t)+\"e\").split(\"e\"),e=n(e[0]+\"e\"+(+e[1]+r)),e=(Eu(e)+\"e\").split(\"e\");return+(e[0]+\"e\"+(+e[1]-r))}return n(t)}}function oe(t){return function(n){var r=Et(n);return\"[object Map]\"==r?L(n):\"[object Set]\"==r?D(n):O(n,t(n))}}function fe(t,n,r,e,u,i,o,f){var c=2&n;if(!c&&typeof t!=\"function\")throw new Qu(\"Expected a function\");var a=e?e.length:0;\nif(a||(n&=-97,e=u=F),o=o===F?o:zi(wu(o),0),f=f===F?f:wu(f),a-=u?u.length:0,64&n){var l=e,s=u;e=u=F}var h=c?F:co(t);return i=[t,n,r,e,u,l,s,i,o,f],h&&(r=i[1],t=h[1],n=r|t,e=128==t&&8==r||128==t&&256==r&&i[7].length<=h[8]||384==t&&h[7].length<=h[8]&&8==r,131>n||e)&&(1&t&&(i[2]=h[2],n|=1&r?0:4),(r=h[3])&&(e=i[3],i[3]=e?Lr(e,r,h[4]):r,i[4]=e?C(i[3],\"__lodash_placeholder__\"):h[4]),(r=h[5])&&(e=i[5],i[5]=e?Ur(e,r,h[6]):r,i[6]=e?C(i[5],\"__lodash_placeholder__\"):h[6]),(r=h[7])&&(i[7]=r),128&t&&(i[8]=null==i[8]?h[8]:Wi(i[8],h[8])),\nnull==i[9]&&(i[9]=h[9]),i[0]=h[0],i[1]=n),t=i[0],n=i[1],r=i[2],e=i[3],u=i[4],f=i[9]=null==i[9]?c?0:t.length:zi(i[9]-a,0),!f&&24&n&&(n&=-25),We((h?uo:ho)(n&&1!=n?8==n||16==n?Kr(t,n,f):32!=n&&33!=n||u.length?Yr.apply(F,i):ne(t,n,r,e):Pr(t,n,r),i),t,n)}function ce(t,n,r,e,u,i){var o=2&u,f=t.length,c=n.length;if(f!=c&&!(o&&c>f))return false;if((c=i.get(t))&&i.get(n))return c==n;var c=-1,a=true,l=1&u?new qt:F;for(i.set(t,n),i.set(n,t);++c<f;){var s=t[c],h=n[c];if(e)var p=o?e(h,s,c,n,t,i):e(s,h,c,t,n,i);if(p!==F){\nif(p)continue;a=false;break}if(l){if(!_(n,function(t,n){if(!R(l,n)&&(s===t||r(s,t,e,u,i)))return l.push(n)})){a=false;break}}else if(s!==h&&!r(s,h,e,u,i)){a=false;break}}return i.delete(t),i.delete(n),a}function ae(t,n,r,e,u,i,o){switch(r){case\"[object DataView]\":if(t.byteLength!=n.byteLength||t.byteOffset!=n.byteOffset)break;t=t.buffer,n=n.buffer;case\"[object ArrayBuffer]\":if(t.byteLength!=n.byteLength||!e(new hi(t),new hi(n)))break;return true;case\"[object Boolean]\":case\"[object Date]\":case\"[object Number]\":\nreturn fu(+t,+n);case\"[object Error]\":return t.name==n.name&&t.message==n.message;case\"[object RegExp]\":case\"[object String]\":return t==n+\"\";case\"[object Map]\":var f=L;case\"[object Set]\":if(f||(f=M),t.size!=n.size&&!(2&i))break;return(r=o.get(t))?r==n:(i|=1,o.set(t,n),n=ce(f(t),f(n),e,u,i,o),o.delete(t),n);case\"[object Symbol]\":if(Hi)return Hi.call(t)==Hi.call(n)}return false}function le(t){return _o(Re(t,F,Fe),t+\"\")}function se(t){return zn(t,Iu,ao)}function he(t){for(var n=t.name+\"\",r=Zi[n],e=ui.call(Zi,n)?r.length:0;e--;){\nvar u=r[e],i=u.func;if(null==i||i==t)return u.name}return n}function pe(t){return(ui.call(Ot,\"placeholder\")?Ot:t).placeholder}function _e(){var t=Ot.iteratee||Du,t=t===Du?Gn:t;return arguments.length?t(arguments[0],arguments[1]):t}function ve(t,n){var r=t.__data__,e=typeof n;return(\"string\"==e||\"number\"==e||\"symbol\"==e||\"boolean\"==e?\"__proto__\"!==n:null===n)?r[typeof n==\"string\"?\"string\":\"hash\"]:r.map}function ge(t){for(var n=Iu(t),r=n.length;r--;){var e=n[r],u=t[e];n[r]=[e,u,u===u&&!_u(u)]}return n;\n}function de(t,n){var r=null==t?F:t[n];return Zn(r)?r:F}function ye(t,n,r){n=ke(n,t)?[n]:Sr(n);for(var e=-1,u=n.length,i=false;++e<u;){var o=Ue(n[e]);if(!(i=null!=t&&r(t,o)))break;t=t[o]}return i||++e!=u?i:(u=t?t.length:0,!!u&&pu(u)&&me(o,u)&&(nf(t)||tf(t)))}function be(t){var n=t.length,r=t.constructor(n);return n&&\"string\"==typeof t[0]&&ui.call(t,\"index\")&&(r.index=t.index,r.input=t.input),r}function xe(t){return typeof t.constructor!=\"function\"||Oe(t)?{}:Xi(_i(t))}function je(r,e,u,i){var o=r.constructor;\nswitch(e){case\"[object ArrayBuffer]\":return zr(r);case\"[object Boolean]\":case\"[object Date]\":return new o(+r);case\"[object DataView]\":return e=i?zr(r.buffer):r.buffer,new r.constructor(e,r.byteOffset,r.byteLength);case\"[object Float32Array]\":case\"[object Float64Array]\":case\"[object Int8Array]\":case\"[object Int16Array]\":case\"[object Int32Array]\":case\"[object Uint8Array]\":case\"[object Uint8ClampedArray]\":case\"[object Uint16Array]\":case\"[object Uint32Array]\":return Wr(r,i);case\"[object Map]\":return e=i?u(L(r),true):L(r),\nh(e,t,new r.constructor);case\"[object Number]\":case\"[object String]\":return new o(r);case\"[object RegExp]\":return e=new r.constructor(r.source,gt.exec(r)),e.lastIndex=r.lastIndex,e;case\"[object Set]\":return e=i?u(M(r),true):M(r),h(e,n,new r.constructor);case\"[object Symbol]\":return Hi?Ju(Hi.call(r)):{}}}function we(t){return nf(t)||tf(t)||!!(bi&&t&&t[bi])}function me(t,n){return n=null==n?9007199254740991:n,!!n&&(typeof t==\"number\"||jt.test(t))&&-1<t&&0==t%1&&t<n}function Ae(t,n,r){if(!_u(r))return false;\nvar e=typeof n;return!!(\"number\"==e?cu(r)&&me(n,r.length):\"string\"==e&&n in r)&&fu(r[n],t)}function ke(t,n){if(nf(t))return false;var r=typeof t;return!(\"number\"!=r&&\"symbol\"!=r&&\"boolean\"!=r&&null!=t&&!bu(t))||(rt.test(t)||!nt.test(t)||null!=n&&t in Ju(n))}function Ee(t){var n=he(t),r=Ot[n];return typeof r==\"function\"&&n in Dt.prototype&&(t===r||(n=co(r),!!n&&t===n[0]))}function Oe(t){var n=t&&t.constructor;return t===(typeof n==\"function\"&&n.prototype||ti)}function Se(t,n){return function(r){return null!=r&&(r[t]===n&&(n!==F||t in Ju(r)));\n}}function Ie(t,n,r,e,u,i){return _u(t)&&_u(n)&&(i.set(n,t),tr(t,n,F,Ie,i),i.delete(n)),t}function Re(t,n,e){return n=zi(n===F?t.length-1:n,0),function(){for(var u=arguments,i=-1,o=zi(u.length-n,0),f=Zu(o);++i<o;)f[i]=u[n+i];for(i=-1,o=Zu(n+1);++i<n;)o[i]=u[i];return o[n]=e(f),r(t,this,o)}}function ze(t,n){return 1==n.length?t:Rn(t,vr(n,0,-1))}function We(t,n,r){var e=n+\"\";n=_o;var u,i=Me;return u=(u=e.match(st))?u[1].split(ht):[],r=i(u,r),(i=r.length)&&(u=i-1,r[u]=(1<i?\"& \":\"\")+r[u],r=r.join(2<i?\", \":\" \"),\ne=e.replace(lt,\"{\\n/* [wrapped with \"+r+\"] */\\n\")),n(t,e)}function Be(t){var n=0,r=0;return function(){var e=Bi(),u=16-(e-r);if(r=e,0<u){if(500<=++n)return arguments[0]}else n=0;return t.apply(F,arguments)}}function Le(t,n){var r=-1,e=t.length,u=e-1;for(n=n===F?e:n;++r<n;){var e=cr(r,u),i=t[e];t[e]=t[r],t[r]=i}return t.length=n,t}function Ue(t){if(typeof t==\"string\"||bu(t))return t;var n=t+\"\";return\"0\"==n&&1/t==-N?\"-0\":n}function Ce(t){if(null!=t){try{return ei.call(t)}catch(t){}return t+\"\"}return\"\";\n}function Me(t,n){return u(Z,function(r){var e=\"_.\"+r[0];n&r[1]&&!c(t,e)&&t.push(e)}),t.sort()}function De(t){if(t instanceof Dt)return t.clone();var n=new Mt(t.__wrapped__,t.__chain__);return n.__actions__=Cr(t.__actions__),n.__index__=t.__index__,n.__values__=t.__values__,n}function Te(t,n,r){var e=t?t.length:0;return e?(r=null==r?0:wu(r),0>r&&(r=zi(e+r,0)),g(t,_e(n,3),r)):-1}function $e(t,n,r){var e=t?t.length:0;if(!e)return-1;var u=e-1;return r!==F&&(u=wu(r),u=0>r?zi(e+u,0):Wi(u,e-1)),g(t,_e(n,3),u,true);\n}function Fe(t){return t&&t.length?En(t,1):[]}function Ne(t){return t&&t.length?t[0]:F}function Pe(t){var n=t?t.length:0;return n?t[n-1]:F}function Ze(t,n){return t&&t.length&&n&&n.length?or(t,n):t}function qe(t){return t?Ci.call(t):t}function Ve(t){if(!t||!t.length)return[];var n=0;return t=f(t,function(t){if(au(t))return n=zi(t.length,n),true}),E(n,function(n){return l(t,j(n))})}function Ke(t,n){if(!t||!t.length)return[];var e=Ve(t);return null==n?e:l(e,function(t){return r(n,F,t)})}function Ge(t){\nreturn t=Ot(t),t.__chain__=true,t}function Je(t,n){return n(t)}function Ye(){return this}function He(t,n){return(nf(t)?u:to)(t,_e(n,3))}function Qe(t,n){return(nf(t)?i:no)(t,_e(n,3))}function Xe(t,n){return(nf(t)?l:Hn)(t,_e(n,3))}function tu(t,n,r){return n=r?F:n,n=t&&null==n?t.length:n,fe(t,128,F,F,F,F,n)}function nu(t,n){var r;if(typeof n!=\"function\")throw new Qu(\"Expected a function\");return t=wu(t),function(){return 0<--t&&(r=n.apply(this,arguments)),1>=t&&(n=F),r}}function ru(t,n,r){return n=r?F:n,\nt=fe(t,8,F,F,F,F,F,n),t.placeholder=ru.placeholder,t}function eu(t,n,r){return n=r?F:n,t=fe(t,16,F,F,F,F,F,n),t.placeholder=eu.placeholder,t}function uu(t,n,r){function e(n){var r=c,e=a;return c=a=F,_=n,s=t.apply(e,r)}function u(t){var r=t-p;return t-=_,p===F||r>=n||0>r||g&&t>=l}function i(){var t=Po();if(u(t))return o(t);var r,e=po;r=t-_,t=n-(t-p),r=g?Wi(t,l-r):t,h=e(i,r)}function o(t){return h=F,d&&c?e(t):(c=a=F,s)}function f(){var t=Po(),r=u(t);if(c=arguments,a=this,p=t,r){if(h===F)return _=t=p,\nh=po(i,n),v?e(t):s;if(g)return h=po(i,n),e(p)}return h===F&&(h=po(i,n)),s}var c,a,l,s,h,p,_=0,v=false,g=false,d=true;if(typeof t!=\"function\")throw new Qu(\"Expected a function\");return n=Au(n)||0,_u(r)&&(v=!!r.leading,l=(g=\"maxWait\"in r)?zi(Au(r.maxWait)||0,n):l,d=\"trailing\"in r?!!r.trailing:d),f.cancel=function(){h!==F&&oo(h),_=0,c=p=a=h=F},f.flush=function(){return h===F?s:o(Po())},f}function iu(t,n){function r(){var e=arguments,u=n?n.apply(this,e):e[0],i=r.cache;return i.has(u)?i.get(u):(e=t.apply(this,e),\nr.cache=i.set(u,e)||i,e)}if(typeof t!=\"function\"||n&&typeof n!=\"function\")throw new Qu(\"Expected a function\");return r.cache=new(iu.Cache||Zt),r}function ou(t){if(typeof t!=\"function\")throw new Qu(\"Expected a function\");return function(){var n=arguments;switch(n.length){case 0:return!t.call(this);case 1:return!t.call(this,n[0]);case 2:return!t.call(this,n[0],n[1]);case 3:return!t.call(this,n[0],n[1],n[2])}return!t.apply(this,n)}}function fu(t,n){return t===n||t!==t&&n!==n}function cu(t){return null!=t&&pu(t.length)&&!su(t);\n}function au(t){return vu(t)&&cu(t)}function lu(t){return!!vu(t)&&(\"[object Error]\"==fi.call(t)||typeof t.message==\"string\"&&typeof t.name==\"string\")}function su(t){return t=_u(t)?fi.call(t):\"\",\"[object Function]\"==t||\"[object GeneratorFunction]\"==t||\"[object Proxy]\"==t}function hu(t){return typeof t==\"number\"&&t==wu(t)}function pu(t){return typeof t==\"number\"&&-1<t&&0==t%1&&9007199254740991>=t}function _u(t){var n=typeof t;return null!=t&&(\"object\"==n||\"function\"==n)}function vu(t){return null!=t&&typeof t==\"object\";\n}function gu(t){return typeof t==\"number\"||vu(t)&&\"[object Number]\"==fi.call(t)}function du(t){return!(!vu(t)||\"[object Object]\"!=fi.call(t))&&(t=_i(t),null===t||(t=ui.call(t,\"constructor\")&&t.constructor,typeof t==\"function\"&&t instanceof t&&ei.call(t)==oi))}function yu(t){return typeof t==\"string\"||!nf(t)&&vu(t)&&\"[object String]\"==fi.call(t)}function bu(t){return typeof t==\"symbol\"||vu(t)&&\"[object Symbol]\"==fi.call(t)}function xu(t){if(!t)return[];if(cu(t))return yu(t)?$(t):Cr(t);if(vi&&t[vi]){t=t[vi]();\nfor(var n,r=[];!(n=t.next()).done;)r.push(n.value);return r}return n=Et(t),(\"[object Map]\"==n?L:\"[object Set]\"==n?M:Wu)(t)}function ju(t){return t?(t=Au(t),t===N||t===-N?1.7976931348623157e308*(0>t?-1:1):t===t?t:0):0===t?t:0}function wu(t){t=ju(t);var n=t%1;return t===t?n?t-n:t:0}function mu(t){return t?dn(wu(t),0,4294967295):0}function Au(t){if(typeof t==\"number\")return t;if(bu(t))return P;if(_u(t)&&(t=typeof t.valueOf==\"function\"?t.valueOf():t,t=_u(t)?t+\"\":t),typeof t!=\"string\")return 0===t?t:+t;\nt=t.replace(ft,\"\");var n=yt.test(t);return n||xt.test(t)?$t(t.slice(2),n?2:8):dt.test(t)?P:+t}function ku(t){return Mr(t,Ru(t))}function Eu(t){return null==t?\"\":jr(t)}function Ou(t,n,r){return t=null==t?F:Rn(t,n),t===F?r:t}function Su(t,n){return null!=t&&ye(t,n,Ln)}function Iu(t){return cu(t)?tn(t):Jn(t)}function Ru(t){if(cu(t))t=tn(t,true);else if(_u(t)){var n,r=Oe(t),e=[];for(n in t)(\"constructor\"!=n||!r&&ui.call(t,n))&&e.push(n);t=e}else{if(n=[],null!=t)for(r in Ju(t))n.push(r);t=n}return t}function zu(t,n){\nreturn null==t?{}:ur(t,zn(t,Ru,lo),_e(n))}function Wu(t){return t?I(t,Iu(t)):[]}function Bu(t){return Uf(Eu(t).toLowerCase())}function Lu(t){return(t=Eu(t))&&t.replace(wt,nn).replace(It,\"\")}function Uu(t,n,r){return t=Eu(t),n=r?F:n,n===F?Bt.test(t)?t.match(zt)||[]:t.match(pt)||[]:t.match(n)||[]}function Cu(t){return function(){return t}}function Mu(t){return t}function Du(t){return Gn(typeof t==\"function\"?t:yn(t,true))}function Tu(t,n,r){var e=Iu(n),i=In(n,e);null!=r||_u(n)&&(i.length||!e.length)||(r=n,\nn=t,t=this,i=In(n,Iu(n)));var o=!(_u(r)&&\"chain\"in r&&!r.chain),f=su(t);return u(i,function(r){var e=n[r];t[r]=e,f&&(t.prototype[r]=function(){var n=this.__chain__;if(o||n){var r=t(this.__wrapped__);return(r.__actions__=Cr(this.__actions__)).push({func:e,args:arguments,thisArg:t}),r.__chain__=n,r}return e.apply(t,s([this.value()],arguments))})}),t}function $u(){}function Fu(t){return ke(t)?j(Ue(t)):ir(t)}function Nu(){return[]}function Pu(){return false}kt=kt?un.defaults(Pt.Object(),kt,un.pick(Pt,Lt)):Pt;\nvar Zu=kt.Array,qu=kt.Date,Vu=kt.Error,Ku=kt.Function,Gu=kt.Math,Ju=kt.Object,Yu=kt.RegExp,Hu=kt.String,Qu=kt.TypeError,Xu=Zu.prototype,ti=Ju.prototype,ni=kt[\"__core-js_shared__\"],ri=function(){var t=/[^.]+$/.exec(ni&&ni.keys&&ni.keys.IE_PROTO||\"\");return t?\"Symbol(src)_1.\"+t:\"\"}(),ei=Ku.prototype.toString,ui=ti.hasOwnProperty,ii=0,oi=ei.call(Ju),fi=ti.toString,ci=Pt._,ai=Yu(\"^\"+ei.call(ui).replace(it,\"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g,\"$1.*?\")+\"$\"),li=Vt?kt.Buffer:F,si=kt.Symbol,hi=kt.Uint8Array,pi=li?li.f:F,_i=U(Ju.getPrototypeOf,Ju),vi=si?si.iterator:F,gi=Ju.create,di=ti.propertyIsEnumerable,yi=Xu.splice,bi=si?si.isConcatSpreadable:F,xi=function(){\ntry{var t=de(Ju,\"defineProperty\");return t({},\"\",{}),t}catch(t){}}(),ji=kt.clearTimeout!==Pt.clearTimeout&&kt.clearTimeout,wi=qu&&qu.now!==Pt.Date.now&&qu.now,mi=kt.setTimeout!==Pt.setTimeout&&kt.setTimeout,Ai=Gu.ceil,ki=Gu.floor,Ei=Ju.getOwnPropertySymbols,Oi=li?li.isBuffer:F,Si=kt.isFinite,Ii=Xu.join,Ri=U(Ju.keys,Ju),zi=Gu.max,Wi=Gu.min,Bi=qu.now,Li=kt.parseInt,Ui=Gu.random,Ci=Xu.reverse,Mi=de(kt,\"DataView\"),Di=de(kt,\"Map\"),Ti=de(kt,\"Promise\"),$i=de(kt,\"Set\"),Fi=de(kt,\"WeakMap\"),Ni=de(Ju,\"create\"),Pi=Fi&&new Fi,Zi={},qi=Ce(Mi),Vi=Ce(Di),Ki=Ce(Ti),Gi=Ce($i),Ji=Ce(Fi),Yi=si?si.prototype:F,Hi=Yi?Yi.valueOf:F,Qi=Yi?Yi.toString:F,Xi=function(){\nfunction t(){}return function(n){return _u(n)?gi?gi(n):(t.prototype=n,n=new t,t.prototype=F,n):{}}}();Ot.templateSettings={escape:Q,evaluate:X,interpolate:tt,variable:\"\",imports:{_:Ot}},Ot.prototype=Rt.prototype,Ot.prototype.constructor=Ot,Mt.prototype=Xi(Rt.prototype),Mt.prototype.constructor=Mt,Dt.prototype=Xi(Rt.prototype),Dt.prototype.constructor=Dt,Ft.prototype.clear=function(){this.__data__=Ni?Ni(null):{},this.size=0},Ft.prototype.delete=function(t){return t=this.has(t)&&delete this.__data__[t],\nthis.size-=t?1:0,t},Ft.prototype.get=function(t){var n=this.__data__;return Ni?(t=n[t],\"__lodash_hash_undefined__\"===t?F:t):ui.call(n,t)?n[t]:F},Ft.prototype.has=function(t){var n=this.__data__;return Ni?n[t]!==F:ui.call(n,t)},Ft.prototype.set=function(t,n){var r=this.__data__;return this.size+=this.has(t)?0:1,r[t]=Ni&&n===F?\"__lodash_hash_undefined__\":n,this},Nt.prototype.clear=function(){this.__data__=[],this.size=0},Nt.prototype.delete=function(t){var n=this.__data__;return t=hn(n,t),!(0>t)&&(t==n.length-1?n.pop():yi.call(n,t,1),\n--this.size,true)},Nt.prototype.get=function(t){var n=this.__data__;return t=hn(n,t),0>t?F:n[t][1]},Nt.prototype.has=function(t){return-1<hn(this.__data__,t)},Nt.prototype.set=function(t,n){var r=this.__data__,e=hn(r,t);return 0>e?(++this.size,r.push([t,n])):r[e][1]=n,this},Zt.prototype.clear=function(){this.size=0,this.__data__={hash:new Ft,map:new(Di||Nt),string:new Ft}},Zt.prototype.delete=function(t){return t=ve(this,t).delete(t),this.size-=t?1:0,t},Zt.prototype.get=function(t){return ve(this,t).get(t);\n},Zt.prototype.has=function(t){return ve(this,t).has(t)},Zt.prototype.set=function(t,n){var r=ve(this,t),e=r.size;return r.set(t,n),this.size+=r.size==e?0:1,this},qt.prototype.add=qt.prototype.push=function(t){return this.__data__.set(t,\"__lodash_hash_undefined__\"),this},qt.prototype.has=function(t){return this.__data__.has(t)},Kt.prototype.clear=function(){this.__data__=new Nt,this.size=0},Kt.prototype.delete=function(t){var n=this.__data__;return t=n.delete(t),this.size=n.size,t},Kt.prototype.get=function(t){\nreturn this.__data__.get(t)},Kt.prototype.has=function(t){return this.__data__.has(t)},Kt.prototype.set=function(t,n){var r=this.__data__;if(r instanceof Nt){var e=r.__data__;if(!Di||199>e.length)return e.push([t,n]),this.size=++r.size,this;r=this.__data__=new Zt(e)}return r.set(t,n),this.size=r.size,this};var to=Fr(On),no=Fr(Sn,true),ro=Nr(),eo=Nr(true),uo=Pi?function(t,n){return Pi.set(t,n),t}:Mu,io=xi?function(t,n){return xi(t,\"toString\",{configurable:true,enumerable:false,value:Cu(n),writable:true})}:Mu,oo=ji||function(t){\nreturn Pt.clearTimeout(t)},fo=$i&&1/M(new $i([,-0]))[1]==N?function(t){return new $i(t)}:$u,co=Pi?function(t){return Pi.get(t)}:$u,ao=Ei?U(Ei,Ju):Nu,lo=Ei?function(t){for(var n=[];t;)s(n,ao(t)),t=_i(t);return n}:Nu;(Mi&&\"[object DataView]\"!=Et(new Mi(new ArrayBuffer(1)))||Di&&\"[object Map]\"!=Et(new Di)||Ti&&\"[object Promise]\"!=Et(Ti.resolve())||$i&&\"[object Set]\"!=Et(new $i)||Fi&&\"[object WeakMap]\"!=Et(new Fi))&&(Et=function(t){var n=fi.call(t);if(t=(t=\"[object Object]\"==n?t.constructor:F)?Ce(t):F)switch(t){\ncase qi:return\"[object DataView]\";case Vi:return\"[object Map]\";case Ki:return\"[object Promise]\";case Gi:return\"[object Set]\";case Ji:return\"[object WeakMap]\"}return n});var so=ni?su:Pu,ho=Be(uo),po=mi||function(t,n){return Pt.setTimeout(t,n)},_o=Be(io),vo=function(t){t=iu(t,function(t){return 500===n.size&&n.clear(),t});var n=t.cache;return t}(function(t){t=Eu(t);var n=[];return et.test(t)&&n.push(\"\"),t.replace(ut,function(t,r,e,u){n.push(e?u.replace(_t,\"$1\"):r||t)}),n}),go=lr(function(t,n){return au(t)?wn(t,En(n,1,au,true)):[];\n}),yo=lr(function(t,n){var r=Pe(n);return au(r)&&(r=F),au(t)?wn(t,En(n,1,au,true),_e(r,2)):[]}),bo=lr(function(t,n){var r=Pe(n);return au(r)&&(r=F),au(t)?wn(t,En(n,1,au,true),F,r):[]}),xo=lr(function(t){var n=l(t,Or);return n.length&&n[0]===t[0]?Un(n):[]}),jo=lr(function(t){var n=Pe(t),r=l(t,Or);return n===Pe(r)?n=F:r.pop(),r.length&&r[0]===t[0]?Un(r,_e(n,2)):[]}),wo=lr(function(t){var n=Pe(t),r=l(t,Or);return n===Pe(r)?n=F:r.pop(),r.length&&r[0]===t[0]?Un(r,F,n):[]}),mo=lr(Ze),Ao=le(function(t,n){var r=t?t.length:0,e=gn(t,n);\nreturn fr(t,l(n,function(t){return me(t,r)?+t:t}).sort(Br)),e}),ko=lr(function(t){return wr(En(t,1,au,true))}),Eo=lr(function(t){var n=Pe(t);return au(n)&&(n=F),wr(En(t,1,au,true),_e(n,2))}),Oo=lr(function(t){var n=Pe(t);return au(n)&&(n=F),wr(En(t,1,au,true),F,n)}),So=lr(function(t,n){return au(t)?wn(t,n):[]}),Io=lr(function(t){return kr(f(t,au))}),Ro=lr(function(t){var n=Pe(t);return au(n)&&(n=F),kr(f(t,au),_e(n,2))}),zo=lr(function(t){var n=Pe(t);return au(n)&&(n=F),kr(f(t,au),F,n)}),Wo=lr(Ve),Bo=lr(function(t){\nvar n=t.length,n=1<n?t[n-1]:F,n=typeof n==\"function\"?(t.pop(),n):F;return Ke(t,n)}),Lo=le(function(t){function n(n){return gn(n,t)}var r=t.length,e=r?t[0]:0,u=this.__wrapped__;return!(1<r||this.__actions__.length)&&u instanceof Dt&&me(e)?(u=u.slice(e,+e+(r?1:0)),u.__actions__.push({func:Je,args:[n],thisArg:F}),new Mt(u,this.__chain__).thru(function(t){return r&&!t.length&&t.push(F),t})):this.thru(n)}),Uo=Tr(function(t,n,r){ui.call(t,r)?++t[r]:vn(t,r,1)}),Co=Gr(Te),Mo=Gr($e),Do=Tr(function(t,n,r){\nui.call(t,r)?t[r].push(n):vn(t,r,[n])}),To=lr(function(t,n,e){var u=-1,i=typeof n==\"function\",o=ke(n),f=cu(t)?Zu(t.length):[];return to(t,function(t){var c=i?n:o&&null!=t?t[n]:F;f[++u]=c?r(c,t,e):Mn(t,n,e)}),f}),$o=Tr(function(t,n,r){vn(t,r,n)}),Fo=Tr(function(t,n,r){t[r?0:1].push(n)},function(){return[[],[]]}),No=lr(function(t,n){if(null==t)return[];var r=n.length;return 1<r&&Ae(t,n[0],n[1])?n=[]:2<r&&Ae(n[0],n[1],n[2])&&(n=[n[0]]),rr(t,En(n,1),[])}),Po=wi||function(){return Pt.Date.now()},Zo=lr(function(t,n,r){\nvar e=1;if(r.length)var u=C(r,pe(Zo)),e=32|e;return fe(t,e,n,r,u)}),qo=lr(function(t,n,r){var e=3;if(r.length)var u=C(r,pe(qo)),e=32|e;return fe(n,e,t,r,u)}),Vo=lr(function(t,n){return jn(t,1,n)}),Ko=lr(function(t,n,r){return jn(t,Au(n)||0,r)});iu.Cache=Zt;var Go=lr(function(t,n){n=1==n.length&&nf(n[0])?l(n[0],S(_e())):l(En(n,1),S(_e()));var e=n.length;return lr(function(u){for(var i=-1,o=Wi(u.length,e);++i<o;)u[i]=n[i].call(this,u[i]);return r(t,this,u)})}),Jo=lr(function(t,n){return fe(t,32,F,n,C(n,pe(Jo)));\n}),Yo=lr(function(t,n){return fe(t,64,F,n,C(n,pe(Yo)))}),Ho=le(function(t,n){return fe(t,256,F,F,F,n)}),Qo=ee(Wn),Xo=ee(function(t,n){return t>=n}),tf=Dn(function(){return arguments}())?Dn:function(t){return vu(t)&&ui.call(t,\"callee\")&&!di.call(t,\"callee\")},nf=Zu.isArray,rf=Gt?S(Gt):Tn,ef=Oi||Pu,uf=Jt?S(Jt):$n,of=Yt?S(Yt):Nn,ff=Ht?S(Ht):qn,cf=Qt?S(Qt):Vn,af=Xt?S(Xt):Kn,lf=ee(Yn),sf=ee(function(t,n){return t<=n}),hf=$r(function(t,n){if(Oe(n)||cu(n))Mr(n,Iu(n),t);else for(var r in n)ui.call(n,r)&&sn(t,r,n[r]);\n}),pf=$r(function(t,n){Mr(n,Ru(n),t)}),_f=$r(function(t,n,r,e){Mr(n,Ru(n),t,e)}),vf=$r(function(t,n,r,e){Mr(n,Iu(n),t,e)}),gf=le(gn),df=lr(function(t){return t.push(F,an),r(_f,F,t)}),yf=lr(function(t){return t.push(F,Ie),r(mf,F,t)}),bf=Hr(function(t,n,r){t[n]=r},Cu(Mu)),xf=Hr(function(t,n,r){ui.call(t,n)?t[n].push(r):t[n]=[r]},_e),jf=lr(Mn),wf=$r(function(t,n,r){tr(t,n,r)}),mf=$r(function(t,n,r,e){tr(t,n,r,e)}),Af=le(function(t,n){return null==t?{}:(n=l(n,Ue),er(t,wn(zn(t,Ru,lo),n)))}),kf=le(function(t,n){\nreturn null==t?{}:er(t,l(n,Ue))}),Ef=oe(Iu),Of=oe(Ru),Sf=qr(function(t,n,r){return n=n.toLowerCase(),t+(r?Bu(n):n)}),If=qr(function(t,n,r){return t+(r?\"-\":\"\")+n.toLowerCase()}),Rf=qr(function(t,n,r){return t+(r?\" \":\"\")+n.toLowerCase()}),zf=Zr(\"toLowerCase\"),Wf=qr(function(t,n,r){return t+(r?\"_\":\"\")+n.toLowerCase()}),Bf=qr(function(t,n,r){return t+(r?\" \":\"\")+Uf(n)}),Lf=qr(function(t,n,r){return t+(r?\" \":\"\")+n.toUpperCase()}),Uf=Zr(\"toUpperCase\"),Cf=lr(function(t,n){try{return r(t,F,n)}catch(t){return lu(t)?t:new Vu(t);\n}}),Mf=le(function(t,n){return u(n,function(n){n=Ue(n),vn(t,n,Zo(t[n],t))}),t}),Df=Jr(),Tf=Jr(true),$f=lr(function(t,n){return function(r){return Mn(r,t,n)}}),Ff=lr(function(t,n){return function(r){return Mn(t,r,n)}}),Nf=Xr(l),Pf=Xr(o),Zf=Xr(_),qf=re(),Vf=re(true),Kf=Qr(function(t,n){return t+n},0),Gf=ie(\"ceil\"),Jf=Qr(function(t,n){return t/n},1),Yf=ie(\"floor\"),Hf=Qr(function(t,n){return t*n},1),Qf=ie(\"round\"),Xf=Qr(function(t,n){return t-n},0);return Ot.after=function(t,n){if(typeof n!=\"function\")throw new Qu(\"Expected a function\");\nreturn t=wu(t),function(){if(1>--t)return n.apply(this,arguments)}},Ot.ary=tu,Ot.assign=hf,Ot.assignIn=pf,Ot.assignInWith=_f,Ot.assignWith=vf,Ot.at=gf,Ot.before=nu,Ot.bind=Zo,Ot.bindAll=Mf,Ot.bindKey=qo,Ot.castArray=function(){if(!arguments.length)return[];var t=arguments[0];return nf(t)?t:[t]},Ot.chain=Ge,Ot.chunk=function(t,n,r){if(n=(r?Ae(t,n,r):n===F)?1:zi(wu(n),0),r=t?t.length:0,!r||1>n)return[];for(var e=0,u=0,i=Zu(Ai(r/n));e<r;)i[u++]=vr(t,e,e+=n);return i},Ot.compact=function(t){for(var n=-1,r=t?t.length:0,e=0,u=[];++n<r;){\nvar i=t[n];i&&(u[e++]=i)}return u},Ot.concat=function(){var t=arguments.length;if(!t)return[];for(var n=Zu(t-1),r=arguments[0];t--;)n[t-1]=arguments[t];return s(nf(r)?Cr(r):[r],En(n,1))},Ot.cond=function(t){var n=t?t.length:0,e=_e();return t=n?l(t,function(t){if(\"function\"!=typeof t[1])throw new Qu(\"Expected a function\");return[e(t[0]),t[1]]}):[],lr(function(e){for(var u=-1;++u<n;){var i=t[u];if(r(i[0],this,e))return r(i[1],this,e)}})},Ot.conforms=function(t){return bn(yn(t,true))},Ot.constant=Cu,Ot.countBy=Uo,\nOt.create=function(t,n){var r=Xi(t);return n?_n(r,n):r},Ot.curry=ru,Ot.curryRight=eu,Ot.debounce=uu,Ot.defaults=df,Ot.defaultsDeep=yf,Ot.defer=Vo,Ot.delay=Ko,Ot.difference=go,Ot.differenceBy=yo,Ot.differenceWith=bo,Ot.drop=function(t,n,r){var e=t?t.length:0;return e?(n=r||n===F?1:wu(n),vr(t,0>n?0:n,e)):[]},Ot.dropRight=function(t,n,r){var e=t?t.length:0;return e?(n=r||n===F?1:wu(n),n=e-n,vr(t,0,0>n?0:n)):[]},Ot.dropRightWhile=function(t,n){return t&&t.length?mr(t,_e(n,3),true,true):[]},Ot.dropWhile=function(t,n){\nreturn t&&t.length?mr(t,_e(n,3),true):[]},Ot.fill=function(t,n,r,e){var u=t?t.length:0;if(!u)return[];for(r&&typeof r!=\"number\"&&Ae(t,n,r)&&(r=0,e=u),u=t.length,r=wu(r),0>r&&(r=-r>u?0:u+r),e=e===F||e>u?u:wu(e),0>e&&(e+=u),e=r>e?0:mu(e);r<e;)t[r++]=n;return t},Ot.filter=function(t,n){return(nf(t)?f:kn)(t,_e(n,3))},Ot.flatMap=function(t,n){return En(Xe(t,n),1)},Ot.flatMapDeep=function(t,n){return En(Xe(t,n),N)},Ot.flatMapDepth=function(t,n,r){return r=r===F?1:wu(r),En(Xe(t,n),r)},Ot.flatten=Fe,Ot.flattenDeep=function(t){\nreturn t&&t.length?En(t,N):[]},Ot.flattenDepth=function(t,n){return t&&t.length?(n=n===F?1:wu(n),En(t,n)):[]},Ot.flip=function(t){return fe(t,512)},Ot.flow=Df,Ot.flowRight=Tf,Ot.fromPairs=function(t){for(var n=-1,r=t?t.length:0,e={};++n<r;){var u=t[n];e[u[0]]=u[1]}return e},Ot.functions=function(t){return null==t?[]:In(t,Iu(t))},Ot.functionsIn=function(t){return null==t?[]:In(t,Ru(t))},Ot.groupBy=Do,Ot.initial=function(t){return t&&t.length?vr(t,0,-1):[]},Ot.intersection=xo,Ot.intersectionBy=jo,Ot.intersectionWith=wo,\nOt.invert=bf,Ot.invertBy=xf,Ot.invokeMap=To,Ot.iteratee=Du,Ot.keyBy=$o,Ot.keys=Iu,Ot.keysIn=Ru,Ot.map=Xe,Ot.mapKeys=function(t,n){var r={};return n=_e(n,3),On(t,function(t,e,u){vn(r,n(t,e,u),t)}),r},Ot.mapValues=function(t,n){var r={};return n=_e(n,3),On(t,function(t,e,u){vn(r,e,n(t,e,u))}),r},Ot.matches=function(t){return Qn(yn(t,true))},Ot.matchesProperty=function(t,n){return Xn(t,yn(n,true))},Ot.memoize=iu,Ot.merge=wf,Ot.mergeWith=mf,Ot.method=$f,Ot.methodOf=Ff,Ot.mixin=Tu,Ot.negate=ou,Ot.nthArg=function(t){\nreturn t=wu(t),lr(function(n){return nr(n,t)})},Ot.omit=Af,Ot.omitBy=function(t,n){return zu(t,ou(_e(n)))},Ot.once=function(t){return nu(2,t)},Ot.orderBy=function(t,n,r,e){return null==t?[]:(nf(n)||(n=null==n?[]:[n]),r=e?F:r,nf(r)||(r=null==r?[]:[r]),rr(t,n,r))},Ot.over=Nf,Ot.overArgs=Go,Ot.overEvery=Pf,Ot.overSome=Zf,Ot.partial=Jo,Ot.partialRight=Yo,Ot.partition=Fo,Ot.pick=kf,Ot.pickBy=zu,Ot.property=Fu,Ot.propertyOf=function(t){return function(n){return null==t?F:Rn(t,n)}},Ot.pull=mo,Ot.pullAll=Ze,\nOt.pullAllBy=function(t,n,r){return t&&t.length&&n&&n.length?or(t,n,_e(r,2)):t},Ot.pullAllWith=function(t,n,r){return t&&t.length&&n&&n.length?or(t,n,F,r):t},Ot.pullAt=Ao,Ot.range=qf,Ot.rangeRight=Vf,Ot.rearg=Ho,Ot.reject=function(t,n){return(nf(t)?f:kn)(t,ou(_e(n,3)))},Ot.remove=function(t,n){var r=[];if(!t||!t.length)return r;var e=-1,u=[],i=t.length;for(n=_e(n,3);++e<i;){var o=t[e];n(o,e,t)&&(r.push(o),u.push(e))}return fr(t,u),r},Ot.rest=function(t,n){if(typeof t!=\"function\")throw new Qu(\"Expected a function\");\nreturn n=n===F?n:wu(n),lr(t,n)},Ot.reverse=qe,Ot.sampleSize=function(t,n,r){return n=(r?Ae(t,n,r):n===F)?1:wu(n),(nf(t)?fn:hr)(t,n)},Ot.set=function(t,n,r){return null==t?t:pr(t,n,r)},Ot.setWith=function(t,n,r,e){return e=typeof e==\"function\"?e:F,null==t?t:pr(t,n,r,e)},Ot.shuffle=function(t){return(nf(t)?cn:_r)(t)},Ot.slice=function(t,n,r){var e=t?t.length:0;return e?(r&&typeof r!=\"number\"&&Ae(t,n,r)?(n=0,r=e):(n=null==n?0:wu(n),r=r===F?e:wu(r)),vr(t,n,r)):[]},Ot.sortBy=No,Ot.sortedUniq=function(t){\nreturn t&&t.length?br(t):[]},Ot.sortedUniqBy=function(t,n){return t&&t.length?br(t,_e(n,2)):[]},Ot.split=function(t,n,r){return r&&typeof r!=\"number\"&&Ae(t,n,r)&&(n=r=F),r=r===F?4294967295:r>>>0,r?(t=Eu(t))&&(typeof n==\"string\"||null!=n&&!ff(n))&&(n=jr(n),!n&&Wt.test(t))?Ir($(t),0,r):t.split(n,r):[]},Ot.spread=function(t,n){if(typeof t!=\"function\")throw new Qu(\"Expected a function\");return n=n===F?0:zi(wu(n),0),lr(function(e){var u=e[n];return e=Ir(e,0,n),u&&s(e,u),r(t,this,e)})},Ot.tail=function(t){\nvar n=t?t.length:0;return n?vr(t,1,n):[]},Ot.take=function(t,n,r){return t&&t.length?(n=r||n===F?1:wu(n),vr(t,0,0>n?0:n)):[]},Ot.takeRight=function(t,n,r){var e=t?t.length:0;return e?(n=r||n===F?1:wu(n),n=e-n,vr(t,0>n?0:n,e)):[]},Ot.takeRightWhile=function(t,n){return t&&t.length?mr(t,_e(n,3),false,true):[]},Ot.takeWhile=function(t,n){return t&&t.length?mr(t,_e(n,3)):[]},Ot.tap=function(t,n){return n(t),t},Ot.throttle=function(t,n,r){var e=true,u=true;if(typeof t!=\"function\")throw new Qu(\"Expected a function\");\nreturn _u(r)&&(e=\"leading\"in r?!!r.leading:e,u=\"trailing\"in r?!!r.trailing:u),uu(t,n,{leading:e,maxWait:n,trailing:u})},Ot.thru=Je,Ot.toArray=xu,Ot.toPairs=Ef,Ot.toPairsIn=Of,Ot.toPath=function(t){return nf(t)?l(t,Ue):bu(t)?[t]:Cr(vo(t))},Ot.toPlainObject=ku,Ot.transform=function(t,n,r){var e=nf(t),i=e||ef(t)||af(t);if(n=_e(n,4),null==r){var o=t&&t.constructor;r=i?e?new o:[]:_u(t)&&su(o)?Xi(_i(t)):{}}return(i?u:On)(t,function(t,e,u){return n(r,t,e,u)}),r},Ot.unary=function(t){return tu(t,1)},Ot.union=ko,\nOt.unionBy=Eo,Ot.unionWith=Oo,Ot.uniq=function(t){return t&&t.length?wr(t):[]},Ot.uniqBy=function(t,n){return t&&t.length?wr(t,_e(n,2)):[]},Ot.uniqWith=function(t,n){return t&&t.length?wr(t,F,n):[]},Ot.unset=function(t,n){var r;if(null==t)r=true;else{r=t;var e=n,e=ke(e,r)?[e]:Sr(e);r=ze(r,e),e=Ue(Pe(e)),r=!(null!=r&&ui.call(r,e))||delete r[e]}return r},Ot.unzip=Ve,Ot.unzipWith=Ke,Ot.update=function(t,n,r){return null==t?t:pr(t,n,(typeof r==\"function\"?r:Mu)(Rn(t,n)),void 0)},Ot.updateWith=function(t,n,r,e){\nreturn e=typeof e==\"function\"?e:F,null!=t&&(t=pr(t,n,(typeof r==\"function\"?r:Mu)(Rn(t,n)),e)),t},Ot.values=Wu,Ot.valuesIn=function(t){return null==t?[]:I(t,Ru(t))},Ot.without=So,Ot.words=Uu,Ot.wrap=function(t,n){return n=null==n?Mu:n,Jo(n,t)},Ot.xor=Io,Ot.xorBy=Ro,Ot.xorWith=zo,Ot.zip=Wo,Ot.zipObject=function(t,n){return Er(t||[],n||[],sn)},Ot.zipObjectDeep=function(t,n){return Er(t||[],n||[],pr)},Ot.zipWith=Bo,Ot.entries=Ef,Ot.entriesIn=Of,Ot.extend=pf,Ot.extendWith=_f,Tu(Ot,Ot),Ot.add=Kf,Ot.attempt=Cf,\nOt.camelCase=Sf,Ot.capitalize=Bu,Ot.ceil=Gf,Ot.clamp=function(t,n,r){return r===F&&(r=n,n=F),r!==F&&(r=Au(r),r=r===r?r:0),n!==F&&(n=Au(n),n=n===n?n:0),dn(Au(t),n,r)},Ot.clone=function(t){return yn(t,false,true)},Ot.cloneDeep=function(t){return yn(t,true,true)},Ot.cloneDeepWith=function(t,n){return yn(t,true,true,n)},Ot.cloneWith=function(t,n){return yn(t,false,true,n)},Ot.conformsTo=function(t,n){return null==n||xn(t,n,Iu(n))},Ot.deburr=Lu,Ot.defaultTo=function(t,n){return null==t||t!==t?n:t},Ot.divide=Jf,Ot.endsWith=function(t,n,r){\nt=Eu(t),n=jr(n);var e=t.length,e=r=r===F?e:dn(wu(r),0,e);return r-=n.length,0<=r&&t.slice(r,e)==n},Ot.eq=fu,Ot.escape=function(t){return(t=Eu(t))&&H.test(t)?t.replace(J,rn):t},Ot.escapeRegExp=function(t){return(t=Eu(t))&&ot.test(t)?t.replace(it,\"\\\\$&\"):t},Ot.every=function(t,n,r){var e=nf(t)?o:mn;return r&&Ae(t,n,r)&&(n=F),e(t,_e(n,3))},Ot.find=Co,Ot.findIndex=Te,Ot.findKey=function(t,n){return v(t,_e(n,3),On)},Ot.findLast=Mo,Ot.findLastIndex=$e,Ot.findLastKey=function(t,n){return v(t,_e(n,3),Sn);\n},Ot.floor=Yf,Ot.forEach=He,Ot.forEachRight=Qe,Ot.forIn=function(t,n){return null==t?t:ro(t,_e(n,3),Ru)},Ot.forInRight=function(t,n){return null==t?t:eo(t,_e(n,3),Ru)},Ot.forOwn=function(t,n){return t&&On(t,_e(n,3))},Ot.forOwnRight=function(t,n){return t&&Sn(t,_e(n,3))},Ot.get=Ou,Ot.gt=Qo,Ot.gte=Xo,Ot.has=function(t,n){return null!=t&&ye(t,n,Bn)},Ot.hasIn=Su,Ot.head=Ne,Ot.identity=Mu,Ot.includes=function(t,n,r,e){return t=cu(t)?t:Wu(t),r=r&&!e?wu(r):0,e=t.length,0>r&&(r=zi(e+r,0)),yu(t)?r<=e&&-1<t.indexOf(n,r):!!e&&-1<d(t,n,r);\n},Ot.indexOf=function(t,n,r){var e=t?t.length:0;return e?(r=null==r?0:wu(r),0>r&&(r=zi(e+r,0)),d(t,n,r)):-1},Ot.inRange=function(t,n,r){return n=ju(n),r===F?(r=n,n=0):r=ju(r),t=Au(t),t>=Wi(n,r)&&t<zi(n,r)},Ot.invoke=jf,Ot.isArguments=tf,Ot.isArray=nf,Ot.isArrayBuffer=rf,Ot.isArrayLike=cu,Ot.isArrayLikeObject=au,Ot.isBoolean=function(t){return true===t||false===t||vu(t)&&\"[object Boolean]\"==fi.call(t)},Ot.isBuffer=ef,Ot.isDate=uf,Ot.isElement=function(t){return null!=t&&1===t.nodeType&&vu(t)&&!du(t)},Ot.isEmpty=function(t){\nif(cu(t)&&(nf(t)||typeof t==\"string\"||typeof t.splice==\"function\"||ef(t)||af(t)||tf(t)))return!t.length;var n=Et(t);if(\"[object Map]\"==n||\"[object Set]\"==n)return!t.size;if(Oe(t))return!Jn(t).length;for(var r in t)if(ui.call(t,r))return false;return true},Ot.isEqual=function(t,n){return Fn(t,n)},Ot.isEqualWith=function(t,n,r){var e=(r=typeof r==\"function\"?r:F)?r(t,n):F;return e===F?Fn(t,n,r):!!e},Ot.isError=lu,Ot.isFinite=function(t){return typeof t==\"number\"&&Si(t)},Ot.isFunction=su,Ot.isInteger=hu,Ot.isLength=pu,\nOt.isMap=of,Ot.isMatch=function(t,n){return t===n||Pn(t,n,ge(n))},Ot.isMatchWith=function(t,n,r){return r=typeof r==\"function\"?r:F,Pn(t,n,ge(n),r)},Ot.isNaN=function(t){return gu(t)&&t!=+t},Ot.isNative=function(t){if(so(t))throw new Vu(\"Unsupported core-js use. Try https://github.com/es-shims.\");return Zn(t)},Ot.isNil=function(t){return null==t},Ot.isNull=function(t){return null===t},Ot.isNumber=gu,Ot.isObject=_u,Ot.isObjectLike=vu,Ot.isPlainObject=du,Ot.isRegExp=ff,Ot.isSafeInteger=function(t){return hu(t)&&-9007199254740991<=t&&9007199254740991>=t;\n},Ot.isSet=cf,Ot.isString=yu,Ot.isSymbol=bu,Ot.isTypedArray=af,Ot.isUndefined=function(t){return t===F},Ot.isWeakMap=function(t){return vu(t)&&\"[object WeakMap]\"==Et(t)},Ot.isWeakSet=function(t){return vu(t)&&\"[object WeakSet]\"==fi.call(t)},Ot.join=function(t,n){return t?Ii.call(t,n):\"\"},Ot.kebabCase=If,Ot.last=Pe,Ot.lastIndexOf=function(t,n,r){var e=t?t.length:0;if(!e)return-1;var u=e;if(r!==F&&(u=wu(r),u=0>u?zi(e+u,0):Wi(u,e-1)),n===n){for(r=u+1;r--&&t[r]!==n;);t=r}else t=g(t,b,u,true);return t},\nOt.lowerCase=Rf,Ot.lowerFirst=zf,Ot.lt=lf,Ot.lte=sf,Ot.max=function(t){return t&&t.length?An(t,Mu,Wn):F},Ot.maxBy=function(t,n){return t&&t.length?An(t,_e(n,2),Wn):F},Ot.mean=function(t){return x(t,Mu)},Ot.meanBy=function(t,n){return x(t,_e(n,2))},Ot.min=function(t){return t&&t.length?An(t,Mu,Yn):F},Ot.minBy=function(t,n){return t&&t.length?An(t,_e(n,2),Yn):F},Ot.stubArray=Nu,Ot.stubFalse=Pu,Ot.stubObject=function(){return{}},Ot.stubString=function(){return\"\"},Ot.stubTrue=function(){return true},Ot.multiply=Hf,\nOt.nth=function(t,n){return t&&t.length?nr(t,wu(n)):F},Ot.noConflict=function(){return Pt._===this&&(Pt._=ci),this},Ot.noop=$u,Ot.now=Po,Ot.pad=function(t,n,r){t=Eu(t);var e=(n=wu(n))?T(t):0;return!n||e>=n?t:(n=(n-e)/2,te(ki(n),r)+t+te(Ai(n),r))},Ot.padEnd=function(t,n,r){t=Eu(t);var e=(n=wu(n))?T(t):0;return n&&e<n?t+te(n-e,r):t},Ot.padStart=function(t,n,r){t=Eu(t);var e=(n=wu(n))?T(t):0;return n&&e<n?te(n-e,r)+t:t},Ot.parseInt=function(t,n,r){return r||null==n?n=0:n&&(n=+n),Li(Eu(t).replace(ct,\"\"),n||0);\n},Ot.random=function(t,n,r){if(r&&typeof r!=\"boolean\"&&Ae(t,n,r)&&(n=r=F),r===F&&(typeof n==\"boolean\"?(r=n,n=F):typeof t==\"boolean\"&&(r=t,t=F)),t===F&&n===F?(t=0,n=1):(t=ju(t),n===F?(n=t,t=0):n=ju(n)),t>n){var e=t;t=n,n=e}return r||t%1||n%1?(r=Ui(),Wi(t+r*(n-t+Tt(\"1e-\"+((r+\"\").length-1))),n)):cr(t,n)},Ot.reduce=function(t,n,r){var e=nf(t)?h:m,u=3>arguments.length;return e(t,_e(n,4),r,u,to)},Ot.reduceRight=function(t,n,r){var e=nf(t)?p:m,u=3>arguments.length;return e(t,_e(n,4),r,u,no)},Ot.repeat=function(t,n,r){\nreturn n=(r?Ae(t,n,r):n===F)?1:wu(n),ar(Eu(t),n)},Ot.replace=function(){var t=arguments,n=Eu(t[0]);return 3>t.length?n:n.replace(t[1],t[2])},Ot.result=function(t,n,r){n=ke(n,t)?[n]:Sr(n);var e=-1,u=n.length;for(u||(t=F,u=1);++e<u;){var i=null==t?F:t[Ue(n[e])];i===F&&(e=u,i=r),t=su(i)?i.call(t):i}return t},Ot.round=Qf,Ot.runInContext=w,Ot.sample=function(t){return(nf(t)?on:sr)(t)},Ot.size=function(t){if(null==t)return 0;if(cu(t))return yu(t)?T(t):t.length;var n=Et(t);return\"[object Map]\"==n||\"[object Set]\"==n?t.size:Jn(t).length;\n},Ot.snakeCase=Wf,Ot.some=function(t,n,r){var e=nf(t)?_:gr;return r&&Ae(t,n,r)&&(n=F),e(t,_e(n,3))},Ot.sortedIndex=function(t,n){return dr(t,n)},Ot.sortedIndexBy=function(t,n,r){return yr(t,n,_e(r,2))},Ot.sortedIndexOf=function(t,n){var r=t?t.length:0;if(r){var e=dr(t,n);if(e<r&&fu(t[e],n))return e}return-1},Ot.sortedLastIndex=function(t,n){return dr(t,n,true)},Ot.sortedLastIndexBy=function(t,n,r){return yr(t,n,_e(r,2),true)},Ot.sortedLastIndexOf=function(t,n){if(t&&t.length){var r=dr(t,n,true)-1;if(fu(t[r],n))return r;\n}return-1},Ot.startCase=Bf,Ot.startsWith=function(t,n,r){return t=Eu(t),r=dn(wu(r),0,t.length),n=jr(n),t.slice(r,r+n.length)==n},Ot.subtract=Xf,Ot.sum=function(t){return t&&t.length?k(t,Mu):0},Ot.sumBy=function(t,n){return t&&t.length?k(t,_e(n,2)):0},Ot.template=function(t,n,r){var e=Ot.templateSettings;r&&Ae(t,n,r)&&(n=F),t=Eu(t),n=_f({},n,e,an),r=_f({},n.imports,e.imports,an);var u,i,o=Iu(r),f=I(r,o),c=0;r=n.interpolate||mt;var a=\"__p+='\";r=Yu((n.escape||mt).source+\"|\"+r.source+\"|\"+(r===tt?vt:mt).source+\"|\"+(n.evaluate||mt).source+\"|$\",\"g\");\nvar l=\"sourceURL\"in n?\"//# sourceURL=\"+n.sourceURL+\"\\n\":\"\";if(t.replace(r,function(n,r,e,o,f,l){return e||(e=o),a+=t.slice(c,l).replace(At,B),r&&(u=true,a+=\"'+__e(\"+r+\")+'\"),f&&(i=true,a+=\"';\"+f+\";\\n__p+='\"),e&&(a+=\"'+((__t=(\"+e+\"))==null?'':__t)+'\"),c=l+n.length,n}),a+=\"';\",(n=n.variable)||(a=\"with(obj){\"+a+\"}\"),a=(i?a.replace(q,\"\"):a).replace(V,\"$1\").replace(K,\"$1;\"),a=\"function(\"+(n||\"obj\")+\"){\"+(n?\"\":\"obj||(obj={});\")+\"var __t,__p=''\"+(u?\",__e=_.escape\":\"\")+(i?\",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}\":\";\")+a+\"return __p}\",\nn=Cf(function(){return Ku(o,l+\"return \"+a).apply(F,f)}),n.source=a,lu(n))throw n;return n},Ot.times=function(t,n){if(t=wu(t),1>t||9007199254740991<t)return[];var r=4294967295,e=Wi(t,4294967295);for(n=_e(n),t-=4294967295,e=E(e,n);++r<t;)n(r);return e},Ot.toFinite=ju,Ot.toInteger=wu,Ot.toLength=mu,Ot.toLower=function(t){return Eu(t).toLowerCase()},Ot.toNumber=Au,Ot.toSafeInteger=function(t){return dn(wu(t),-9007199254740991,9007199254740991)},Ot.toString=Eu,Ot.toUpper=function(t){return Eu(t).toUpperCase();\n},Ot.trim=function(t,n,r){return(t=Eu(t))&&(r||n===F)?t.replace(ft,\"\"):t&&(n=jr(n))?(t=$(t),r=$(n),n=z(t,r),r=W(t,r)+1,Ir(t,n,r).join(\"\")):t},Ot.trimEnd=function(t,n,r){return(t=Eu(t))&&(r||n===F)?t.replace(at,\"\"):t&&(n=jr(n))?(t=$(t),n=W(t,$(n))+1,Ir(t,0,n).join(\"\")):t},Ot.trimStart=function(t,n,r){return(t=Eu(t))&&(r||n===F)?t.replace(ct,\"\"):t&&(n=jr(n))?(t=$(t),n=z(t,$(n)),Ir(t,n).join(\"\")):t},Ot.truncate=function(t,n){var r=30,e=\"...\";if(_u(n))var u=\"separator\"in n?n.separator:u,r=\"length\"in n?wu(n.length):r,e=\"omission\"in n?jr(n.omission):e;\nt=Eu(t);var i=t.length;if(Wt.test(t))var o=$(t),i=o.length;if(r>=i)return t;if(i=r-T(e),1>i)return e;if(r=o?Ir(o,0,i).join(\"\"):t.slice(0,i),u===F)return r+e;if(o&&(i+=r.length-i),ff(u)){if(t.slice(i).search(u)){var f=r;for(u.global||(u=Yu(u.source,Eu(gt.exec(u))+\"g\")),u.lastIndex=0;o=u.exec(f);)var c=o.index;r=r.slice(0,c===F?i:c)}}else t.indexOf(jr(u),i)!=i&&(u=r.lastIndexOf(u),-1<u&&(r=r.slice(0,u)));return r+e},Ot.unescape=function(t){return(t=Eu(t))&&Y.test(t)?t.replace(G,en):t},Ot.uniqueId=function(t){\nvar n=++ii;return Eu(t)+n},Ot.upperCase=Lf,Ot.upperFirst=Uf,Ot.each=He,Ot.eachRight=Qe,Ot.first=Ne,Tu(Ot,function(){var t={};return On(Ot,function(n,r){ui.call(Ot.prototype,r)||(t[r]=n)}),t}(),{chain:false}),Ot.VERSION=\"4.16.4\",u(\"bind bindKey curry curryRight partial partialRight\".split(\" \"),function(t){Ot[t].placeholder=Ot}),u([\"drop\",\"take\"],function(t,n){Dt.prototype[t]=function(r){var e=this.__filtered__;if(e&&!n)return new Dt(this);r=r===F?1:zi(wu(r),0);var u=this.clone();return e?u.__takeCount__=Wi(r,u.__takeCount__):u.__views__.push({\nsize:Wi(r,4294967295),type:t+(0>u.__dir__?\"Right\":\"\")}),u},Dt.prototype[t+\"Right\"]=function(n){return this.reverse()[t](n).reverse()}}),u([\"filter\",\"map\",\"takeWhile\"],function(t,n){var r=n+1,e=1==r||3==r;Dt.prototype[t]=function(t){var n=this.clone();return n.__iteratees__.push({iteratee:_e(t,3),type:r}),n.__filtered__=n.__filtered__||e,n}}),u([\"head\",\"last\"],function(t,n){var r=\"take\"+(n?\"Right\":\"\");Dt.prototype[t]=function(){return this[r](1).value()[0]}}),u([\"initial\",\"tail\"],function(t,n){var r=\"drop\"+(n?\"\":\"Right\");\nDt.prototype[t]=function(){return this.__filtered__?new Dt(this):this[r](1)}}),Dt.prototype.compact=function(){return this.filter(Mu)},Dt.prototype.find=function(t){return this.filter(t).head()},Dt.prototype.findLast=function(t){return this.reverse().find(t)},Dt.prototype.invokeMap=lr(function(t,n){return typeof t==\"function\"?new Dt(this):this.map(function(r){return Mn(r,t,n)})}),Dt.prototype.reject=function(t){return this.filter(ou(_e(t)))},Dt.prototype.slice=function(t,n){t=wu(t);var r=this;return r.__filtered__&&(0<t||0>n)?new Dt(r):(0>t?r=r.takeRight(-t):t&&(r=r.drop(t)),\nn!==F&&(n=wu(n),r=0>n?r.dropRight(-n):r.take(n-t)),r)},Dt.prototype.takeRightWhile=function(t){return this.reverse().takeWhile(t).reverse()},Dt.prototype.toArray=function(){return this.take(4294967295)},On(Dt.prototype,function(t,n){var r=/^(?:filter|find|map|reject)|While$/.test(n),e=/^(?:head|last)$/.test(n),u=Ot[e?\"take\"+(\"last\"==n?\"Right\":\"\"):n],i=e||/^find/.test(n);u&&(Ot.prototype[n]=function(){function n(t){return t=u.apply(Ot,s([t],f)),e&&h?t[0]:t}var o=this.__wrapped__,f=e?[1]:arguments,c=o instanceof Dt,a=f[0],l=c||nf(o);\nl&&r&&typeof a==\"function\"&&1!=a.length&&(c=l=false);var h=this.__chain__,p=!!this.__actions__.length,a=i&&!h,c=c&&!p;return!i&&l?(o=c?o:new Dt(this),o=t.apply(o,f),o.__actions__.push({func:Je,args:[n],thisArg:F}),new Mt(o,h)):a&&c?t.apply(this,f):(o=this.thru(n),a?e?o.value()[0]:o.value():o)})}),u(\"pop push shift sort splice unshift\".split(\" \"),function(t){var n=Xu[t],r=/^(?:push|sort|unshift)$/.test(t)?\"tap\":\"thru\",e=/^(?:pop|shift)$/.test(t);Ot.prototype[t]=function(){var t=arguments;if(e&&!this.__chain__){\nvar u=this.value();return n.apply(nf(u)?u:[],t)}return this[r](function(r){return n.apply(nf(r)?r:[],t)})}}),On(Dt.prototype,function(t,n){var r=Ot[n];if(r){var e=r.name+\"\";(Zi[e]||(Zi[e]=[])).push({name:n,func:r})}}),Zi[Yr(F,2).name]=[{name:\"wrapper\",func:F}],Dt.prototype.clone=function(){var t=new Dt(this.__wrapped__);return t.__actions__=Cr(this.__actions__),t.__dir__=this.__dir__,t.__filtered__=this.__filtered__,t.__iteratees__=Cr(this.__iteratees__),t.__takeCount__=this.__takeCount__,t.__views__=Cr(this.__views__),\nt},Dt.prototype.reverse=function(){if(this.__filtered__){var t=new Dt(this);t.__dir__=-1,t.__filtered__=true}else t=this.clone(),t.__dir__*=-1;return t},Dt.prototype.value=function(){var t,n=this.__wrapped__.value(),r=this.__dir__,e=nf(n),u=0>r,i=e?n.length:0;t=i;for(var o=this.__views__,f=0,c=-1,a=o.length;++c<a;){var l=o[c],s=l.size;switch(l.type){case\"drop\":f+=s;break;case\"dropRight\":t-=s;break;case\"take\":t=Wi(t,f+s);break;case\"takeRight\":f=zi(f,t-s)}}if(t={start:f,end:t},o=t.start,f=t.end,t=f-o,\nu=u?f:o-1,o=this.__iteratees__,f=o.length,c=0,a=Wi(t,this.__takeCount__),!e||200>i||i==t&&a==t)return Ar(n,this.__actions__);e=[];t:for(;t--&&c<a;){for(u+=r,i=-1,l=n[u];++i<f;){var h=o[i],s=h.type,h=(0,h.iteratee)(l);if(2==s)l=h;else if(!h){if(1==s)continue t;break t}}e[c++]=l}return e},Ot.prototype.at=Lo,Ot.prototype.chain=function(){return Ge(this)},Ot.prototype.commit=function(){return new Mt(this.value(),this.__chain__)},Ot.prototype.next=function(){this.__values__===F&&(this.__values__=xu(this.value()));\nvar t=this.__index__>=this.__values__.length;return{done:t,value:t?F:this.__values__[this.__index__++]}},Ot.prototype.plant=function(t){for(var n,r=this;r instanceof Rt;){var e=De(r);e.__index__=0,e.__values__=F,n?u.__wrapped__=e:n=e;var u=e,r=r.__wrapped__}return u.__wrapped__=t,n},Ot.prototype.reverse=function(){var t=this.__wrapped__;return t instanceof Dt?(this.__actions__.length&&(t=new Dt(this)),t=t.reverse(),t.__actions__.push({func:Je,args:[qe],thisArg:F}),new Mt(t,this.__chain__)):this.thru(qe);\n},Ot.prototype.toJSON=Ot.prototype.valueOf=Ot.prototype.value=function(){return Ar(this.__wrapped__,this.__actions__)},Ot.prototype.first=Ot.prototype.head,vi&&(Ot.prototype[vi]=Ye),Ot}();typeof define==\"function\"&&typeof define.amd==\"object\"&&define.amd?(Pt._=un, define(function(){return un})):qt?((qt.exports=un)._=un,Zt._=un):Pt._=un}).call(this);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lodash.min.js\n ** module id = 45\n ** module chunks = 0\n **/","/**\r\n * adds a bindGlobal method to Mousetrap that allows you to\r\n * bind specific keyboard shortcuts that will still work\r\n * inside a text input field\r\n *\r\n * usage:\r\n * Mousetrap.bindGlobal('ctrl+s', _saveChanges);\r\n */\r\n/* global Mousetrap:true */\r\n(function(Mousetrap) {\r\n    var _globalCallbacks = {};\r\n    var _originalStopCallback = Mousetrap.prototype.stopCallback;\r\n\r\n    Mousetrap.prototype.stopCallback = function(e, element, combo, sequence) {\r\n        var self = this;\r\n\r\n        if (self.paused) {\r\n            return true;\r\n        }\r\n\r\n        if (_globalCallbacks[combo] || _globalCallbacks[sequence]) {\r\n            return false;\r\n        }\r\n\r\n        return _originalStopCallback.call(self, e, element, combo);\r\n    };\r\n\r\n    Mousetrap.prototype.bindGlobal = function(keys, callback, action) {\r\n        var self = this;\r\n        self.bind(keys, callback, action);\r\n\r\n        if (keys instanceof Array) {\r\n            for (var i = 0; i < keys.length; i++) {\r\n                _globalCallbacks[keys[i]] = true;\r\n            }\r\n            return;\r\n        }\r\n\r\n        _globalCallbacks[keys] = true;\r\n    };\r\n\t\r\n\tMousetrap.prototype.unbindGlobal = function(keys, action) {\r\n\t\tvar self = this;\r\n\t\tself.unbind(keys, action);\r\n\r\n\t\tif (keys instanceof Array) {\r\n\t\t\tfor (var i = 0; i < keys.length; i++) {\r\n\t\t\t\t_globalCallbacks[keys[i]] = false;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t_globalCallbacks[keys] = false;\r\n\t};\r\n\r\n    Mousetrap.init();\r\n}) (Mousetrap);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mousetrap-global-bind/mousetrap-global-bind.js\n ** module id = 46\n ** module chunks = 0\n **/","/*global define:false */\n/**\n * Copyright 2016 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.0\n * @url craig.is/killing/mice\n */\n(function(window, document, undefined) {\n\n    // Check if mousetrap is used inside browser, if not, return\n    if (!window) {\n        return;\n    }\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n        8: 'backspace',\n        9: 'tab',\n        13: 'enter',\n        16: 'shift',\n        17: 'ctrl',\n        18: 'alt',\n        20: 'capslock',\n        27: 'esc',\n        32: 'space',\n        33: 'pageup',\n        34: 'pagedown',\n        35: 'end',\n        36: 'home',\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n        45: 'ins',\n        46: 'del',\n        91: 'meta',\n        93: 'meta',\n        224: 'meta'\n    };\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    var _KEYCODE_MAP = {\n        106: '*',\n        107: '+',\n        109: '-',\n        110: '.',\n        111 : '/',\n        186: ';',\n        187: '=',\n        188: ',',\n        189: '-',\n        190: '.',\n        191: '/',\n        192: '`',\n        219: '[',\n        220: '\\\\',\n        221: ']',\n        222: '\\''\n    };\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    var _SHIFT_MAP = {\n        '~': '`',\n        '!': '1',\n        '@': '2',\n        '#': '3',\n        '$': '4',\n        '%': '5',\n        '^': '6',\n        '&': '7',\n        '*': '8',\n        '(': '9',\n        ')': '0',\n        '_': '-',\n        '+': '=',\n        ':': ';',\n        '\\\"': '\\'',\n        '<': ',',\n        '>': '.',\n        '?': '/',\n        '|': '\\\\'\n    };\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    var _SPECIAL_ALIASES = {\n        'option': 'alt',\n        'command': 'meta',\n        'return': 'enter',\n        'escape': 'esc',\n        'plus': '+',\n        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    };\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    var _REVERSE_MAP;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n        _MAP[i + 96] = i;\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            var character = String.fromCharCode(e.which);\n\n            // if the shift key is not pressed then it is safe to assume\n            // that we want the character to be lowercase.  this means if\n            // you accidentally have caps lock on then your key bindings\n            // will continue to work\n            //\n            // the only side effect that might not be desired is if you\n            // bind something like 'A' cause you want to trigger an\n            // event when capital A is pressed caps lock will no longer\n            // trigger the event.  shift+a will though.\n            if (!e.shiftKey) {\n                character = character.toLowerCase();\n            }\n\n            return character;\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n\n        // with keydown and keyup events the character seems to always\n        // come in as an uppercase character whether you are pressing shift\n        // or not.  we should make sure it is always lowercase for comparisons\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n            return;\n        }\n\n        e.returnValue = false;\n    }\n\n    /**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n            return;\n        }\n\n        e.cancelBubble = true;\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */\n    function _keysFromString(combination) {\n        if (combination === '+') {\n            return ['+'];\n        }\n\n        combination = combination.replace(/\\+{2}/g, '+plus');\n        return combination.split('+');\n    }\n\n    /**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */\n    function _getKeyInfo(combination, action) {\n        var keys;\n        var key;\n        var i;\n        var modifiers = [];\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = _keysFromString(combination);\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        return {\n            key: key,\n            modifiers: modifiers,\n            action: action\n        };\n    }\n\n    function _belongsTo(element, ancestor) {\n        if (element === null || element === document) {\n            return false;\n        }\n\n        if (element === ancestor) {\n            return true;\n        }\n\n        return _belongsTo(element.parentNode, ancestor);\n    }\n\n    function Mousetrap(targetElement) {\n        var self = this;\n\n        targetElement = targetElement || document;\n\n        if (!(self instanceof Mousetrap)) {\n            return new Mousetrap(targetElement);\n        }\n\n        /**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */\n        self.target = targetElement;\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        self._callbacks = {};\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        self._directMap = {};\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        var _sequenceLevels = {};\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        var _resetTimer;\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        var _ignoreNextKeyup = false;\n\n        /**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */\n        var _ignoreNextKeypress = false;\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        var _nextExpectedAction = false;\n\n        /**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */\n        function _resetSequences(doNotReset) {\n            doNotReset = doNotReset || {};\n\n            var activeSequences = false,\n                key;\n\n            for (key in _sequenceLevels) {\n                if (doNotReset[key]) {\n                    activeSequences = true;\n                    continue;\n                }\n                _sequenceLevels[key] = 0;\n            }\n\n            if (!activeSequences) {\n                _nextExpectedAction = false;\n            }\n        }\n\n        /**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */\n        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n            var i;\n            var callback;\n            var matches = [];\n            var action = e.type;\n\n            // if there are no events related to this keycode\n            if (!self._callbacks[character]) {\n                return [];\n            }\n\n            // if a modifier key is coming up on its own we should allow it\n            if (action == 'keyup' && _isModifier(character)) {\n                modifiers = [character];\n            }\n\n            // loop through all callbacks for the key that was pressed\n            // and see if any of them match\n            for (i = 0; i < self._callbacks[character].length; ++i) {\n                callback = self._callbacks[character][i];\n\n                // if a sequence name is not specified, but this is a sequence at\n                // the wrong level then move onto the next match\n                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n                    continue;\n                }\n\n                // if the action we are looking for doesn't match the action we got\n                // then we should keep going\n                if (action != callback.action) {\n                    continue;\n                }\n\n                // if this is a keypress event and the meta key and control key\n                // are not pressed that means that we need to only look at the\n                // character, otherwise check the modifiers as well\n                //\n                // chrome will not fire a keypress if meta or control is down\n                // safari will fire a keypress if meta or meta+shift is down\n                // firefox will fire a keypress if meta or control is down\n                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                    // when you bind a combination or sequence a second time it\n                    // should overwrite the first one.  if a sequenceName or\n                    // combination is specified in this call it does just that\n                    //\n                    // @todo make deleting its own method?\n                    var deleteCombo = !sequenceName && callback.combo == combination;\n                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n                    if (deleteCombo || deleteSequence) {\n                        self._callbacks[character].splice(i, 1);\n                    }\n\n                    matches.push(callback);\n                }\n            }\n\n            return matches;\n        }\n\n        /**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */\n        function _fireCallback(callback, e, combo, sequence) {\n\n            // if this event should not happen stop here\n            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n                return;\n            }\n\n            if (callback(e, combo) === false) {\n                _preventDefault(e);\n                _stopPropagation(e);\n            }\n        }\n\n        /**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */\n        self._handleKey = function(character, modifiers, e) {\n            var callbacks = _getMatches(character, modifiers, e);\n            var i;\n            var doNotReset = {};\n            var maxLevel = 0;\n            var processedSequenceCallback = false;\n\n            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n            for (i = 0; i < callbacks.length; ++i) {\n                if (callbacks[i].seq) {\n                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n                }\n            }\n\n            // loop through matching callbacks for this key event\n            for (i = 0; i < callbacks.length; ++i) {\n\n                // fire for all sequence callbacks\n                // this is because if for example you have multiple sequences\n                // bound such as \"g i\" and \"g t\" they both need to fire the\n                // callback for matching g cause otherwise you can only ever\n                // match the first one\n                if (callbacks[i].seq) {\n\n                    // only fire callbacks for the maxLevel to prevent\n                    // subsequences from also firing\n                    //\n                    // for example 'a option b' should not cause 'option b' to fire\n                    // even though 'option b' is part of the other sequence\n                    //\n                    // any sequences that do not match here will be discarded\n                    // below by the _resetSequences call\n                    if (callbacks[i].level != maxLevel) {\n                        continue;\n                    }\n\n                    processedSequenceCallback = true;\n\n                    // keep a list of which sequences were matches for later\n                    doNotReset[callbacks[i].seq] = 1;\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n                    continue;\n                }\n\n                // if there were no sequence matches but we are still here\n                // that means this is a regular match so we should fire that\n                if (!processedSequenceCallback) {\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n                }\n            }\n\n            // if the key you pressed matches the type of sequence without\n            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n            // reset all sequences that were not matched by this event\n            //\n            // this is so, for example, if you have the sequence \"h a t\" and you\n            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n            // cause the sequence to reset\n            //\n            // modifier keys are ignored because you can have a sequence\n            // that contains modifiers such as \"enter ctrl+space\" and in most\n            // cases the modifier key will be pressed before the next key\n            //\n            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n            //\n            // the \"keydown\" is expected when there is a modifier, but the\n            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n            // after and that causes the sequence to reset\n            //\n            // we ignore keypresses in a sequence that directly follow a keydown\n            // for the same character\n            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n                _resetSequences(doNotReset);\n            }\n\n            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n        };\n\n        /**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        function _handleKeyEvent(e) {\n\n            // normalize e.which for key events\n            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n            if (typeof e.which !== 'number') {\n                e.which = e.keyCode;\n            }\n\n            var character = _characterFromEvent(e);\n\n            // no character found then stop\n            if (!character) {\n                return;\n            }\n\n            // need to use === for the character check because the character can be 0\n            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n                _ignoreNextKeyup = false;\n                return;\n            }\n\n            self.handleKey(character, _eventModifiers(e), e);\n        }\n\n        /**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */\n        function _resetSequenceTimer() {\n            clearTimeout(_resetTimer);\n            _resetTimer = setTimeout(_resetSequences, 1000);\n        }\n\n        /**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */\n        function _bindSequence(combo, keys, callback, action) {\n\n            // start off by adding a sequence level record for this combination\n            // and setting the level to 0\n            _sequenceLevels[combo] = 0;\n\n            /**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */\n            function _increaseSequence(nextAction) {\n                return function() {\n                    _nextExpectedAction = nextAction;\n                    ++_sequenceLevels[combo];\n                    _resetSequenceTimer();\n                };\n            }\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            function _callbackAndReset(e) {\n                _fireCallback(callback, e, combo);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignoreNextKeyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            }\n\n            // loop through keys one at a time and bind the appropriate callback\n            // function.  for any key leading up to the final one it should\n            // increase the sequence. after the final, it should reset all sequences\n            //\n            // if an action is specified in the original bind call then that will\n            // be used throughout.  otherwise we will pass the action that the\n            // next key in the sequence should match.  this allows a sequence\n            // to mix and match keypress and keydown events depending on which\n            // ones are better suited to the key provided\n            for (var i = 0; i < keys.length; ++i) {\n                var isFinal = i + 1 === keys.length;\n                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n            }\n        }\n\n        /**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */\n        function _bindSingle(combination, callback, action, sequenceName, level) {\n\n            // store a direct mapped reference for use with Mousetrap.trigger\n            self._directMap[combination + ':' + action] = callback;\n\n            // make sure multiple spaces in a row become a single space\n            combination = combination.replace(/\\s+/g, ' ');\n\n            var sequence = combination.split(' ');\n            var info;\n\n            // if this pattern is a sequence of keys then run through this method\n            // to reprocess each pattern one key at a time\n            if (sequence.length > 1) {\n                _bindSequence(combination, sequence, callback, action);\n                return;\n            }\n\n            info = _getKeyInfo(combination, action);\n\n            // make sure to initialize array if this is the first time\n            // a callback is added for this key\n            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n            // remove an existing match if there is one\n            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n            // add this call back to the array\n            // if it is a sequence put it at the beginning\n            // if not put it at the end\n            //\n            // this is important because the way these are processed expects\n            // the sequence ones to come first\n            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n                callback: callback,\n                modifiers: info.modifiers,\n                action: info.action,\n                seq: sequenceName,\n                level: level,\n                combo: combination\n            });\n        }\n\n        /**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */\n        self._bindMultiple = function(combinations, callback, action) {\n            for (var i = 0; i < combinations.length; ++i) {\n                _bindSingle(combinations[i], callback, action);\n            }\n        };\n\n        // start!\n        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n    }\n\n    /**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */\n    Mousetrap.prototype.bind = function(keys, callback, action) {\n        var self = this;\n        keys = keys instanceof Array ? keys : [keys];\n        self._bindMultiple.call(self, keys, callback, action);\n        return self;\n    };\n\n    /**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */\n    Mousetrap.prototype.unbind = function(keys, action) {\n        var self = this;\n        return self.bind.call(self, keys, function() {}, action);\n    };\n\n    /**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */\n    Mousetrap.prototype.trigger = function(keys, action) {\n        var self = this;\n        if (self._directMap[keys + ':' + action]) {\n            self._directMap[keys + ':' + action]({}, keys);\n        }\n        return self;\n    };\n\n    /**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */\n    Mousetrap.prototype.reset = function() {\n        var self = this;\n        self._callbacks = {};\n        self._directMap = {};\n        return self;\n    };\n\n    /**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */\n    Mousetrap.prototype.stopCallback = function(e, element) {\n        var self = this;\n\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n            return false;\n        }\n\n        if (_belongsTo(element, self.target)) {\n            return false;\n        }\n\n        // stop for input, select, and textarea\n        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n    };\n\n    /**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */\n    Mousetrap.prototype.handleKey = function() {\n        var self = this;\n        return self._handleKey.apply(self, arguments);\n    };\n\n    /**\n     * allow custom key mappings\n     */\n    Mousetrap.addKeycodes = function(object) {\n        for (var key in object) {\n            if (object.hasOwnProperty(key)) {\n                _MAP[key] = object[key];\n            }\n        }\n        _REVERSE_MAP = null;\n    };\n\n    /**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */\n    Mousetrap.init = function() {\n        var documentMousetrap = Mousetrap(document);\n        for (var method in documentMousetrap) {\n            if (method.charAt(0) !== '_') {\n                Mousetrap[method] = (function(method) {\n                    return function() {\n                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n                    };\n                } (method));\n            }\n        }\n    };\n\n    Mousetrap.init();\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose as a common js module\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Mousetrap;\n    }\n\n    // expose mousetrap as an AMD module\n    if (typeof define === 'function' && define.amd) {\n        define(function() {\n            return Mousetrap;\n        });\n    }\n}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mousetrap/mousetrap.js\n ** module id = 47\n ** module chunks = 0\n **/","'use strict';\n\nvar upsert = require('./upsert');\nvar utils = require('./utils');\nvar Promise = utils.Promise;\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\nmodule.exports = function (opts) {\n  var sourceDB = opts.db;\n  var viewName = opts.viewName;\n  var mapFun = opts.map;\n  var reduceFun = opts.reduce;\n  var temporary = opts.temporary;\n  var pluginName = opts.pluginName;\n\n  // the \"undefined\" part is for backwards compatibility\n  var viewSignature = stringify(mapFun) + stringify(reduceFun) +\n    'undefined';\n\n  if (!temporary && sourceDB._cachedViews) {\n    var cachedView = sourceDB._cachedViews[viewSignature];\n    if (cachedView) {\n      return Promise.resolve(cachedView);\n    }\n  }\n\n  return sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : utils.MD5(viewSignature));\n\n    // save the view name in the source PouchDB so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + pluginName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db, \n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (!temporary) {\n            sourceDB._cachedViews = sourceDB._cachedViews || {};\n            sourceDB._cachedViews[viewSignature] = view;\n            view.db.on('destroyed', function () {\n              delete sourceDB._cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/abstract-mapreduce/create-view.js\n ** module id = 48\n ** module chunks = 0\n **/","'use strict';\n\nvar pouchCollate = require('pouchdb-collate');\nvar TaskQueue = require('./taskqueue');\nvar collate = pouchCollate.collate;\nvar toIndexableString = pouchCollate.toIndexableString;\nvar normalizeKey = pouchCollate.normalizeKey;\nvar createView = require('./create-view');\nvar log;\n/* istanbul ignore else */\nif ((typeof console !== 'undefined') && (typeof console.log === 'function')) {\n  log = Function.prototype.bind.call(console.log, console);\n} else {\n  log = function () {};\n}\nvar utils = require('./utils');\nvar Promise = utils.Promise;\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue();\nvar CHANGES_BATCH_SIZE = 50;\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\nutils.inherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\nutils.inherits(NotFoundError, Error);\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction sortByKeyThenValue(x, y) {\n  var keyCompare = collate(x.key, y.key);\n  return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n}\n\nfunction sliceResults(results, limit, skip) {\n  skip = skip || 0;\n  if (typeof limit === 'number') {\n    return results.slice(skip, limit + skip);\n  } else if (skip > 0) {\n    return results.slice(skip);\n  }\n  return results;\n}\n\nfunction rowToDocId(row) {\n  var val = row.value;\n  // Users can explicitly specify a joined doc _id, or it\n  // defaults to the doc _id that emitted the key/value.\n  var docId = (val && typeof val === 'object' && val._id) || row.id;\n  return docId;\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    console.error(\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    console.error(e);\n  }\n}\n\nfunction tryCode(db, fun, args) {\n  // emit an event if there was an error thrown by a map/reduce function.\n  // putting try/catches in a single function also avoids deoptimizations.\n  try {\n    return {\n      output : fun.apply(null, args)\n    };\n  } catch (e) {\n    emitError(db, e);\n    return {error: e};\n  }\n}\n\nfunction checkQueryParseError(options, fun) {\n  var startkeyName = options.descending ? 'endkey' : 'startkey';\n  var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n  if (typeof options[startkeyName] !== 'undefined' &&\n    typeof options[endkeyName] !== 'undefined' &&\n    collate(options[startkeyName], options[endkeyName]) > 0) {\n    throw new QueryParseError('No rows can match your key range, reverse your ' +\n    'start_key and end_key or set {descending : true}');\n  } else if (fun.reduce && options.reduce !== false) {\n    if (options.include_docs) {\n      throw new QueryParseError('{include_docs:true} is invalid for reduce');\n    } else if (options.keys && options.keys.length > 1 &&\n      !options.group && !options.group_level) {\n      throw new QueryParseError('Multi-key fetches for reduce views must use {group: true}');\n    }\n  }\n  if (options.group_level) {\n    if (typeof options.group_level !== 'number') {\n      throw new QueryParseError('Invalid value for integer: \"' + options.group_level + '\"');\n    }\n    if (options.group_level < 0) {\n      throw new QueryParseError('Invalid value for positive integer: ' +\n      '\"' + options.group_level + '\"');\n    }\n  }\n}\n\nfunction defaultsTo(value) {\n  return function (reason) {\n    /* istanbul ignore else */\n    if (reason.status === 404) {\n      return value;\n    } else {\n      throw reason;\n    }\n  };\n}\n\nfunction createIndexer(def) {\n\n  var pluginName = def.name;\n  var mapper = def.mapper;\n  var reducer = def.reducer;\n  var ddocValidator = def.ddocValidator;\n\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits[docId];\n    var indexableKeysToKeyValues = docData.indexableKeysToKeyValues;\n    var changes = docData.changes;\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKvDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeysMap = {};\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeysMap[doc._id] = true;\n        doc._deleted = !indexableKeysToKeyValues[doc._id];\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues[doc._id];\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n\n      var newKeys = Object.keys(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeysMap[key]) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues[key];\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = utils.uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKvDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n    .catch(defaultsTo({_id: seqDocId, seq: 0}))\n    .then(function (lastSeqDoc) {\n      var docIds = Object.keys(docIdsToChangesAndEmits);\n      return Promise.all(docIds.map(function (docId) {\n        return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n      })).then(function (listOfDocsToPersist) {\n        var docsToPersist = utils.flatten(listOfDocsToPersist);\n        lastSeqDoc.seq = seq;\n        docsToPersist.push(lastSeqDoc);\n        // write all docs in a single operation, update the seq once\n        return view.db.bulkDocs({docs : docsToPersist});\n      });\n    });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return utils.sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue();\n\n    return new Promise(function (resolve, reject) {\n\n      function complete() {\n        queue.finish().then(function () {\n          view.seq = currentSeq;\n          resolve();\n        });\n      }\n\n      function processNextBatch() {\n        view.sourceDB.changes({\n          conflicts: true,\n          include_docs: true,\n          style: 'all_docs',\n          since: currentSeq,\n          limit: CHANGES_BATCH_SIZE\n        }).on('complete', function (response) {\n          var results = response.results;\n          if (!results.length) {\n            return complete();\n          }\n          var docIdsToChangesAndEmits = {};\n          for (var i = 0, l = results.length; i < l; i++) {\n            var change = results[i];\n            if (change.doc._id[0] !== '_') {\n              mapResults = [];\n              doc = change.doc;\n\n              if (!doc._deleted) {\n                tryCode(view.sourceDB, mapFun, [doc]);\n              }\n              mapResults.sort(sortByKeyThenValue);\n\n              var indexableKeysToKeyValues = {};\n              var lastKey;\n              for (var j = 0, jl = mapResults.length; j < jl; j++) {\n                var obj = mapResults[j];\n                var complexKey = [obj.key, obj.id];\n                if (collate(obj.key, lastKey) === 0) {\n                  complexKey.push(j); // dup key+id, so make it unique\n                }\n                var indexableKey = toIndexableString(complexKey);\n                indexableKeysToKeyValues[indexableKey] = obj;\n                lastKey = obj.key;\n              }\n              docIdsToChangesAndEmits[change.doc._id] = {\n                indexableKeysToKeyValues: indexableKeysToKeyValues,\n                changes: change.changes\n              };\n            }\n            currentSeq = change.seq;\n          }\n          queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n          if (results.length < CHANGES_BATCH_SIZE) {\n            return complete();\n          }\n          return processNextBatch();\n        }).on('error', onError);\n        /* istanbul ignore next */\n        function onError(err) {\n          reject(err);\n        }\n      }\n\n      processNextBatch();\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var key = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(key) && typeof lvl === 'number') {\n        key = key.length > lvl ? key.slice(0, lvl) : key;\n      }\n\n      if (last && collate(last.key[0][0], key) === 0) {\n        last.key.push([key, e.id]);\n        last.value.push(e.value);\n        return;\n      }\n      groups.push({key: [\n        [key, e.id]\n      ], value: [e.value]});\n    });\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryCode(view.sourceDB, reduceFun, [e.key, e.value, false]);\n      // TODO: can't do instanceof BuiltInError because this class is buried\n      // in mapreduce.js\n      if (reduceTry.error && /BuiltInError/.test(reduceTry.error.constructor)) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      // CouchDB just sets the value to null if a non-built-in errors out\n      e.value = reduceTry.error ? null : reduceTry.output;\n      e.key = e.key[0][0];\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(groups, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return utils.sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n              result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = pouchCollate.parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      if (opts.include_docs) {\n        var docIds = utils.uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = {};\n          allDocsRes.rows.forEach(function (row) {\n            if (row.doc) {\n              docIdsToDocs['$' + row.id] = row.doc;\n            }\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs['$' + docId];\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    var flatten = function (array) {\n      return array.reduce(function (prev, cur) {\n        return prev.concat(cur);\n      });\n    };\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        return fetchFromView(viewOpts);\n      });\n      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      if (typeof opts.startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([opts.startkey, {}]) :\n          toIndexableString([opts.startkey]);\n      }\n      if (typeof opts.endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + pluginName).then(function (metaDoc) {\n      var docsToViews = {};\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        docsToViews[designDocName] = docsToViews[designDocName] || {};\n        docsToViews[designDocName][viewName] = true;\n      });\n      var opts = {\n        keys : Object.keys(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8);\n          Object.keys(docsToViews[row.key]).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views && row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] = viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(function (viewDBName) {\n          return !viewsToStatus[viewDBName];\n        });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return utils.sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return Promise.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      var createViewOpts = {\n        db : db,\n        viewName : 'temp_view/temp_view',\n        map : fun.map,\n        reduce : fun.reduce,\n        temporary : true,\n        pluginName: pluginName\n      };\n      tempViewQueue.add(function () {\n        return createView(createViewOpts).then(function (view) {\n          function cleanup() {\n            return view.db.destroy();\n          }\n          return utils.fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), cleanup);\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewOpts = {\n          db : db,\n          viewName : fullViewName,\n          map : fun.map,\n          reduce : fun.reduce,\n          pluginName: pluginName\n        };\n        return createView(createViewOpts).then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              process.nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  var query = function (fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = utils.extend(true, {}, opts);\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    utils.promisedCallback(promise, callback);\n    return promise;\n  };\n\n  var viewCleanup = utils.callbackify(function () {\n    var db = this;\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: query,\n    viewCleanup: viewCleanup\n  };\n}\n\nmodule.exports = createIndexer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/abstract-mapreduce/index.js\n ** module id = 49\n ** module chunks = 0\n **/","'use strict';\n/*\n * Simple task queue to sequentialize actions. Assumes callbacks will eventually fire (once).\n */\n\nvar Promise = require('./utils').Promise;\n\nfunction TaskQueue() {\n  this.promise = new Promise(function (fulfill) {fulfill(); });\n}\nTaskQueue.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue.prototype.finish = function () {\n  return this.promise;\n};\n\nmodule.exports = TaskQueue;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/abstract-mapreduce/taskqueue.js\n ** module id = 50\n ** module chunks = 0\n **/","'use strict';\n\nvar massageCreateIndexRequest = require('../../massageCreateIndexRequest');\n\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n\n  db.request({\n    method: 'POST',\n    url: '_index',\n    body: requestDef\n  }, callback);\n}\n\nfunction find(db, requestDef, callback) {\n  db.request({\n    method: 'POST',\n    url: '_find',\n    body: requestDef\n  }, callback);\n}\n\nfunction getIndexes(db, callback) {\n  db.request({\n    method: 'GET',\n    url: '_index'\n  }, callback);\n}\n\nfunction deleteIndex(db, indexDef, callback) {\n\n\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\n  db.request({\n    method: 'DELETE',\n    url: url\n  }, callback);\n}\n\nexports.createIndex = createIndex;\nexports.find = find;\nexports.getIndexes = getIndexes;\nexports.deleteIndex = deleteIndex;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/adapters/http/index.js\n ** module id = 51\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('../../../utils');\nvar log = utils.log;\n\nvar pouchUpsert = require('pouchdb-upsert');\nvar abstractMapper = require('../abstract-mapper');\nvar localUtils = require('../utils');\nvar validateIndex = localUtils.validateIndex;\nvar massageIndexDef = localUtils.massageIndexDef;\nvar massageCreateIndexRequest = require('../../../massageCreateIndexRequest');\n\nfunction upsert(db, docId, diffFun) {\n  return pouchUpsert.upsert.call(db, docId, diffFun);\n}\n\nfunction createIndex(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = utils.clone(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n\n  validateIndex(requestDef.index);\n\n  var md5 = utils.MD5(JSON.stringify(requestDef));\n\n  var viewName = requestDef.name || ('idx-' + md5);\n\n  var ddocName = requestDef.ddoc || ('idx-' + md5);\n  var ddocId = '_design/' + ddocName;\n\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n    doc.language = 'query';\n    doc.views = doc.views || {};\n\n    viewExists = !!doc.views[viewName];\n\n    doc.views[viewName] = {\n      map: {\n        fields: utils.mergeObjects(requestDef.index.fields)\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n\n    return doc;\n  }\n\n  log('creating index', ddocId);\n\n  return upsert(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' +\n      ddocId +\n      '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper.query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\n\nmodule.exports = createIndex;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/adapters/local/create-index/index.js\n ** module id = 52\n ** module chunks = 0\n **/","'use strict';\n\nvar abstractMapper = require('../abstract-mapper');\nvar upsert = require('../../../abstract-mapreduce/upsert');\n\nfunction deleteIndex(db, index) {\n\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n\n  var docId = index.ddoc;\n  var viewName = index.name;\n\n  function deltaFun (doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return {_id: docId, _deleted: true};\n    }\n    // more than one view here, just remove the view\n    delete doc.views[viewName];\n    return doc;\n  }\n\n  return upsert(db, docId, deltaFun).then(function () {\n    return abstractMapper.viewCleanup.apply(db);\n  }).then(function () {\n    return {ok: true};\n  });\n}\n\nmodule.exports = deleteIndex;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/adapters/local/delete-index/index.js\n ** module id = 53\n ** module chunks = 0\n **/","'use strict';\n\n//\n// Do an in-memory filtering of rows that aren't covered by the index.\n// E.g. if the user is asking for foo=1 and bar=2, but the index\n// only covers \"foo\", then this in-memory filter would take care of\n// \"bar\".\n//\n\nvar isArray = require('is-array');\nvar collate = require('pouchdb-collate').collate;\nvar localUtils = require('../utils');\nvar isCombinationalField = localUtils.isCombinationalField;\nvar getKey = localUtils.getKey;\nvar getValue = localUtils.getValue;\nvar parseField = localUtils.parseField;\nvar utils = require('../../../utils');\nvar getFieldFromDoc = utils.getFieldFromDoc;\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return utils.compare(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields (rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter (doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector (matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector (field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField (docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue (docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues (docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize (docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof(docFieldValue) === 'boolean';\n    case 'number':\n      return typeof(docFieldValue) === 'number';\n    case 'string':\n      return typeof(docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\nmodule.exports = filterInMemoryFields;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/adapters/local/find/in-memory-filter.js\n ** module id = 54\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('../../../utils');\nvar clone = utils.clone;\nvar getIndexes = require('../get-indexes');\nvar collate = require('pouchdb-collate').collate;\nvar abstractMapper = require('../abstract-mapper');\nvar planQuery = require('./query-planner');\nvar localUtils = require('../utils');\nvar filterInMemoryFields = require('./in-memory-filter');\nvar massageSelector = localUtils.massageSelector;\nvar massageSort = localUtils.massageSort;\nvar getValue = localUtils.getValue;\nvar validateFindRequest = localUtils.validateFindRequest;\nvar validateSort = localUtils.validateSort;\nvar reverseOptions = localUtils.reverseOptions;\nvar filterInclusiveStart = localUtils.filterInclusiveStart;\nvar Promise = utils.Promise;\n\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\n\nfunction doAllDocs(db, originalOpts) {\n  var opts = clone(originalOpts);\n\n  // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n\n  return db.allDocs(opts);\n}\n\nfunction find(db, requestDef) {\n\n  if (requestDef.selector) {\n    requestDef.selector = massageSelector(requestDef.selector);\n  }\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n\n  validateFindRequest(requestDef);\n\n  return getIndexes(db).then(function (getIndexesRes) {\n\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n\n    var indexToUse = queryPlan.index;\n\n    validateSort(requestDef, indexToUse);\n\n    var opts = utils.extend(true, {\n      include_docs: true,\n      reduce: false\n    }, queryPlan.queryOpts);\n\n    if ('startkey' in opts && 'endkey' in opts &&\n        collate(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n      return {docs: []};\n    }\n\n    var isDescending = requestDef.sort &&\n      typeof requestDef.sort[0] !== 'string' &&\n      getValue(requestDef.sort[0]) === 'desc';\n\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n\n    return Promise.resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper.query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n          if (requestDef.fields) {\n            return utils.pick(doc, requestDef.fields);\n          }\n          return doc;\n        })\n      };\n\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'no matching index found, create an index to optimize query time';\n      }\n\n      return resp;\n    });\n  });\n}\n\nmodule.exports = find;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/adapters/local/find/index.js\n ** module id = 55\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('../../../utils');\nvar log = utils.log;\nvar localUtils = require('../utils');\nvar getKey = localUtils.getKey;\nvar getValue = localUtils.getValue;\nvar getUserFields = localUtils.getUserFields;\n\n// couchdb lowest collation value\nvar COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\nvar COLLATE_HI = {\"\\uffff\": {}};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(getKey);\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    if (field === indexField) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = getKey(matcher);\n\n  return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(getKey);\n\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n    return utils.compare(aIdx, bIdx);\n  });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index, selector, userFields) {\n\n  userFields = sortFieldsByIndex(userFields, index);\n\n  // check if any of the user selectors lose precision\n  var needToFilterInMemory = false;\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n  return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = utils.flatten(\n    // in-memory fields reported as necessary by the query planner\n    coreInMemoryFields,\n    // combine with another pass that checks for any we may have missed\n    getBasicInMemoryFields(index, selector, userFields),\n    // combine with another pass that checks for $ne's\n    getInMemoryFieldsFromNe(selector)\n  );\n\n  return sortFieldsByIndex(utils.uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = utils.oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = utils.oneArrayIsSubArrayOfOther(fields, indexFields);\n\n    return sortMatches && selectorMatches;\n  }\n\n  // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n  return utils.oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher (matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n\n  var hasLogicalOperator = Object.keys(matcher).some(function (matcherKey) {\n    return !(isNonLogicalMatcher(matcherKey));\n  });\n\n  if (!hasLogicalOperator) {\n    return false;\n  }\n\n  var isInvalidNe = Object.keys(matcher).length === 1 &&\n    getKey(matcher) === '$ne';\n\n  return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n  if (!fieldsMatch) {\n    return false;\n  }\n\n  return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n\n  return indexes.reduce(function (res, index) {\n    var indexMatches = checkIndexMatches(index, sortOrder, userFields, selector);\n    if (indexMatches) {\n      res.push(index);\n    }\n    return res;\n  }, []);\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes) {\n\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n  if (matchingIndexes.length === 0) {\n    //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n  if (matchingIndexes.length === 1) {\n    return matchingIndexes[0];\n  }\n\n  var userFieldsMap = utils.arrayToObject(userFields);\n\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(getKey);\n    var score = 0;\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n    return score;\n  }\n\n  return utils.max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {key: userValue};\n    case '$lte':\n      return {endkey: userValue};\n    case '$gte':\n      return {startkey: userValue};\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = getKey(index.def.fields[0]);\n  var matcher = selector[field];\n  var inMemoryFields = [];\n\n  var userOperators = Object.keys(matcher);\n\n  var combinedOpts;\n\n  userOperators.forEach(function (userOperator) {\n\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n      return;\n    }\n\n    var userValue = matcher[userOperator];\n\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n    if (combinedOpts) {\n      combinedOpts = utils.mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getMultiFieldQueryOpts(selector, index) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n\n\n  function finish(i) {\n\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    }\n    // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n    inMemoryFields = indexFields.slice(i);\n  }\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n\n    var matcher = selector[indexField];\n\n    if (!matcher) { // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (i > 0) {\n      if ('$ne' in matcher) { // unusable $ne index\n        finish(i);\n        break;\n      }\n      var usingGtlt = (\n        '$gt' in matcher || '$gte' in matcher ||\n        '$lt' in matcher || '$lte' in matcher);\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = utils.arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = utils.arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n\n    var userOperators = Object.keys(matcher);\n\n    var combinedOpts = null;\n\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n      if (combinedOpts) {\n        combinedOpts = utils.mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getDefaultQueryPlan () {\n  return {\n    queryOpts: {startkey: null},\n    //getInMemoryFields will do the work here later\n    inMemoryFields: []\n  };\n}\n\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  }\n  // else index has multiple fields, so the value was indexed as an array\n  return getMultiFieldQueryOpts(selector, index);\n}\n\nfunction planQuery(request, indexes) {\n\n  log('planning query', request);\n\n  var selector = request.selector;\n  var sort = request.sort;\n\n  var userFieldsRes = getUserFields(selector, sort);\n\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes);\n\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  log('query plan', res);\n  return res;\n}\n\nmodule.exports = planQuery;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/adapters/local/find/query-planner.js\n ** module id = 56\n ** module chunks = 0\n **/","'use strict';\n\nvar utils = require('../../utils');\nvar callbackify = utils.callbackify;\n\nexports.createIndex = callbackify(require('./create-index'));\nexports.find = callbackify(require('./find'));\nexports.getIndexes = callbackify(require('./get-indexes'));\nexports.deleteIndex = callbackify(require('./delete-index'));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/lib/adapters/local/index.js\n ** module id = 57\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/argsarray/index.js\n ** module id = 58\n ** module chunks = 0\n **/","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/debug/browser.js\n ** module id = 59\n ** module chunks = 0\n **/","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/debug/debug.js\n ** module id = 60\n ** module chunks = 0\n **/","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/debug/~/ms/index.js\n ** module id = 61\n ** module chunks = 0\n **/","\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/is-array/index.js\n ** module id = 62\n ** module chunks = 0\n **/","'use strict';\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nexports.padLeft = function (str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n};\n\nexports.padRight = function (str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return str + padding;\n};\n\nexports.stringLexCompare = function (a, b) {\n\n  var aLen = a.length;\n  var bLen = b.length;\n\n  var i;\n  for (i = 0; i < aLen; i++) {\n    if (i === bLen) {\n      // b is shorter substring of a\n      return 1;\n    }\n    var aChar = a.charAt(i);\n    var bChar = b.charAt(i);\n    if (aChar !== bChar) {\n      return aChar < bChar ? -1 : 1;\n    }\n  }\n\n  if (aLen < bLen) {\n    // a is shorter substring of b\n    return -1;\n  }\n\n  return 0;\n};\n\n/*\n * returns the decimal form for the given integer, i.e. writes\n * out all the digits (in base-10) instead of using scientific notation\n */\nexports.intToDecimalForm = function (int) {\n\n  var isNeg = int < 0;\n  var result = '';\n\n  do {\n    var remainder = isNeg ? -Math.ceil(int % 10) : Math.floor(int % 10);\n\n    result = remainder + result;\n    int = isNeg ? Math.ceil(int / 10) : Math.floor(int / 10);\n  } while (int);\n\n\n  if (isNeg && result !== '0') {\n    result = '-' + result;\n  }\n\n  return result;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/pouchdb-collate/lib/utils.js\n ** module id = 63\n ** module chunks = 0\n **/","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n/* istanbul ignore else */\nif (!process.browser) {\n  // in which we actually take advantage of JS scoping\n  var UNHANDLED = ['UNHANDLED'];\n}\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    this.handled = UNHANDLED;\n  }\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype.catch = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (this.handled === UNHANDLED) {\n      this.handled = null;\n    }\n  }\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (self.handled === UNHANDLED) {\n      immediate(function () {\n        if (self.handled === UNHANDLED) {\n          process.emit('unhandledRejection', error, self);\n        }\n      });\n    }\n  }\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/pouchdb-promise/~/lie/lib/index.js\n ** module id = 64\n ** module chunks = 0\n **/","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/pouchdb-promise/~/lie/~/immediate/lib/browser.js\n ** module id = 65\n ** module chunks = 0\n **/","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(require('lie'));\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\nmodule.exports = PouchPromise;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/pouchdb-upsert/~/pouchdb-promise/lib/index.js\n ** module id = 66\n ** module chunks = 0\n **/","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n/* istanbul ignore else */\nif (!process.browser) {\n  // in which we actually take advantage of JS scoping\n  var UNHANDLED = ['UNHANDLED'];\n}\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    this.handled = UNHANDLED;\n  }\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype.catch = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (this.handled === UNHANDLED) {\n      this.handled = null;\n    }\n  }\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (self.handled === UNHANDLED) {\n      immediate(function () {\n        if (self.handled === UNHANDLED) {\n          process.emit('unhandledRejection', error, self);\n        }\n      });\n    }\n  }\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/pouchdb-upsert/~/pouchdb-promise/~/lie/lib/index.js\n ** module id = 67\n ** module chunks = 0\n **/","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-find/~/pouchdb-upsert/~/pouchdb-promise/~/lie/~/immediate/lib/browser.js\n ** module id = 68\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/~/argsarray/index.js\n ** module id = 69\n ** module chunks = 0\n **/","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/~/debug/browser.js\n ** module id = 70\n ** module chunks = 0\n **/","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/~/debug/debug.js\n ** module id = 71\n ** module chunks = 0\n **/","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/~/debug/~/ms/index.js\n ** module id = 72\n ** module chunks = 0\n **/","(function (root, factory) {\r\n  /* istanbul ignore next */\r\n  if (typeof define === 'function' && define.amd) {\r\n    define([], factory)\r\n  } else if (typeof exports === 'object') {\r\n    module.exports = factory()\r\n  } else {\r\n    root.PromisePool = factory()\r\n    // Legacy API\r\n    root.promisePool = root.PromisePool\r\n  }\r\n})(this, function () {\r\n  'use strict'\r\n\r\n  var EventTarget = function () {\r\n    this._listeners = {}\r\n  }\r\n\r\n  EventTarget.prototype.addEventListener = function (type, listener) {\r\n    this._listeners[type] = this._listeners[type] || []\r\n    if (this._listeners[type].indexOf(listener) < 0) {\r\n      this._listeners[type].push(listener)\r\n    }\r\n  }\r\n\r\n  EventTarget.prototype.removeEventListener = function (type, listener) {\r\n    if (this._listeners[type]) {\r\n      var p = this._listeners[type].indexOf(listener)\r\n      if (p >= 0) {\r\n        this._listeners[type].splice(p, 1)\r\n      }\r\n    }\r\n  }\r\n\r\n  EventTarget.prototype.dispatchEvent = function (evt) {\r\n    if (this._listeners[evt.type] && this._listeners[evt.type].length) {\r\n      var listeners = this._listeners[evt.type].slice()\r\n      for (var i = 0, l = listeners.length; i < l; ++i) {\r\n        listeners[i].call(this, evt)\r\n      }\r\n    }\r\n  }\r\n\r\n  var isGenerator = function (func) {\r\n    return (typeof func.constructor === 'function' &&\r\n      func.constructor.name === 'GeneratorFunction')\r\n  }\r\n\r\n  var functionToIterator = function (func) {\r\n    return {\r\n      next: function () {\r\n        var promise = func()\r\n        return promise ? {value: promise} : {done: true}\r\n      }\r\n    }\r\n  }\r\n\r\n  var promiseToIterator = function (promise) {\r\n    var called = false\r\n    return {\r\n      next: function () {\r\n        if (called) {\r\n          return {done: true}\r\n        }\r\n        called = true\r\n        return {value: promise}\r\n      }\r\n    }\r\n  }\r\n\r\n  var toIterator = function (obj, Promise) {\r\n    var type = typeof obj\r\n    if (type === 'object') {\r\n      if (typeof obj.next === 'function') {\r\n        return obj\r\n      }\r\n      /* istanbul ignore else */\r\n      if (typeof obj.then === 'function') {\r\n        return promiseToIterator(obj)\r\n      }\r\n    }\r\n    if (type === 'function') {\r\n      return isGenerator(obj) ? obj() : functionToIterator(obj)\r\n    }\r\n    return promiseToIterator(Promise.resolve(obj))\r\n  }\r\n\r\n  var PromisePoolEvent = function (target, type, data) {\r\n    this.target = target\r\n    this.type = type\r\n    this.data = data\r\n  }\r\n\r\n  var PromisePool = function (source, concurrency, options) {\r\n    EventTarget.call(this)\r\n    if (typeof concurrency !== 'number' ||\r\n        Math.floor(concurrency) !== concurrency ||\r\n        concurrency < 1) {\r\n      throw new Error('Invalid concurrency')\r\n    }\r\n    this._concurrency = concurrency\r\n    this._options = options || {}\r\n    this._options.promise = this._options.promise || Promise\r\n    this._iterator = toIterator(source, this._options.promise)\r\n    this._done = false\r\n    this._size = 0\r\n    this._promise = null\r\n    this._callbacks = null\r\n  }\r\n  PromisePool.prototype = new EventTarget()\r\n  PromisePool.prototype.constructor = PromisePool\r\n\r\n  PromisePool.prototype.concurrency = function (value) {\r\n    if (typeof value !== 'undefined') {\r\n      this._concurrency = value\r\n      if (this.active()) {\r\n        this._proceed()\r\n      }\r\n    }\r\n    return this._concurrency\r\n  }\r\n\r\n  PromisePool.prototype.size = function () {\r\n    return this._size\r\n  }\r\n\r\n  PromisePool.prototype.active = function () {\r\n    return !!this._promise\r\n  }\r\n\r\n  PromisePool.prototype.promise = function () {\r\n    return this._promise\r\n  }\r\n\r\n  PromisePool.prototype.start = function () {\r\n    var that = this\r\n    var Promise = this._options.promise\r\n    this._promise = new Promise(function (resolve, reject) {\r\n      that._callbacks = {\r\n        reject: reject,\r\n        resolve: resolve\r\n      }\r\n      that._proceed()\r\n    })\r\n    return this._promise\r\n  }\r\n\r\n  PromisePool.prototype._fireEvent = function (type, data) {\r\n    this.dispatchEvent(new PromisePoolEvent(this, type, data))\r\n  }\r\n\r\n  PromisePool.prototype._settle = function (error) {\r\n    if (error) {\r\n      this._callbacks.reject(error)\r\n    } else {\r\n      this._callbacks.resolve()\r\n    }\r\n    this._promise = null\r\n    this._callbacks = null\r\n  }\r\n\r\n  PromisePool.prototype._onPooledPromiseFulfilled = function (promise, result) {\r\n    this._size--\r\n    if (this.active()) {\r\n      this._fireEvent('fulfilled', {\r\n        promise: promise,\r\n        result: result\r\n      })\r\n      this._proceed()\r\n    }\r\n  }\r\n\r\n  PromisePool.prototype._onPooledPromiseRejected = function (promise, error) {\r\n    this._size--\r\n    if (this.active()) {\r\n      this._fireEvent('rejected', {\r\n        promise: promise,\r\n        error: error\r\n      })\r\n      this._settle(error || new Error('Unknown error'))\r\n    }\r\n  }\r\n\r\n  PromisePool.prototype._trackPromise = function (promise) {\r\n    var that = this\r\n    promise\r\n      .then(function (result) {\r\n        that._onPooledPromiseFulfilled(promise, result)\r\n      }, function (error) {\r\n        that._onPooledPromiseRejected(promise, error)\r\n      })['catch'](function (err) {\r\n        that._settle(new Error('Promise processing failed: ' + err))\r\n      })\r\n  }\r\n\r\n  PromisePool.prototype._proceed = function () {\r\n    if (!this._done) {\r\n      var result = null\r\n      while (this._size < this._concurrency &&\r\n          !(result = this._iterator.next()).done) {\r\n        this._size++\r\n        this._trackPromise(result.value)\r\n      }\r\n      this._done = (result === null || !!result.done)\r\n    }\r\n    if (this._done && this._size === 0) {\r\n      this._settle()\r\n    }\r\n  }\r\n\r\n  PromisePool.PromisePoolEvent = PromisePoolEvent\r\n  // Legacy API\r\n  PromisePool.PromisePool = PromisePool\r\n\r\n  return PromisePool\r\n})\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/~/es6-promise-pool/es6-promise-pool.js\n ** module id = 73\n ** module chunks = 0\n **/","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/~/inherits/inherits_browser.js\n ** module id = 74\n ** module chunks = 0\n **/","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/~/lie/lib/browser.js\n ** module id = 75\n ** module chunks = 0\n **/","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/~/lie/~/immediate/lib/browser.js\n ** module id = 76\n ** module chunks = 0\n **/","// Generated by CoffeeScript 1.9.2\n(function() {\n  var hasProp = {}.hasOwnProperty,\n    slice = [].slice;\n\n  module.exports = function(source, scope) {\n    var key, keys, value, values;\n    keys = [];\n    values = [];\n    for (key in scope) {\n      if (!hasProp.call(scope, key)) continue;\n      value = scope[key];\n      if (key === 'this') {\n        continue;\n      }\n      keys.push(key);\n      values.push(value);\n    }\n    return Function.apply(null, slice.call(keys).concat([source])).apply(scope[\"this\"], values);\n  };\n\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/~/scope-eval/scope_eval.js\n ** module id = 77\n ** module chunks = 0\n **/","(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function ff(a, b, c, d, x, s, t) {\n        return cmn((b & c) | ((~b) & d), a, b, x, s, t);\n    }\n\n    function gg(a, b, c, d, x, s, t) {\n        return cmn((b & d) | (c & (~d)), a, b, x, s, t);\n    }\n\n    function hh(a, b, c, d, x, s, t) {\n        return cmn(b ^ c ^ d, a, b, x, s, t);\n    }\n\n    function ii(a, b, c, d, x, s, t) {\n        return cmn(c ^ (b | (~d)), a, b, x, s, t);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a = ff(a, b, c, d, k[0], 7, -680876936);\n        d = ff(d, a, b, c, k[1], 12, -389564586);\n        c = ff(c, d, a, b, k[2], 17, 606105819);\n        b = ff(b, c, d, a, k[3], 22, -1044525330);\n        a = ff(a, b, c, d, k[4], 7, -176418897);\n        d = ff(d, a, b, c, k[5], 12, 1200080426);\n        c = ff(c, d, a, b, k[6], 17, -1473231341);\n        b = ff(b, c, d, a, k[7], 22, -45705983);\n        a = ff(a, b, c, d, k[8], 7, 1770035416);\n        d = ff(d, a, b, c, k[9], 12, -1958414417);\n        c = ff(c, d, a, b, k[10], 17, -42063);\n        b = ff(b, c, d, a, k[11], 22, -1990404162);\n        a = ff(a, b, c, d, k[12], 7, 1804603682);\n        d = ff(d, a, b, c, k[13], 12, -40341101);\n        c = ff(c, d, a, b, k[14], 17, -1502002290);\n        b = ff(b, c, d, a, k[15], 22, 1236535329);\n\n        a = gg(a, b, c, d, k[1], 5, -165796510);\n        d = gg(d, a, b, c, k[6], 9, -1069501632);\n        c = gg(c, d, a, b, k[11], 14, 643717713);\n        b = gg(b, c, d, a, k[0], 20, -373897302);\n        a = gg(a, b, c, d, k[5], 5, -701558691);\n        d = gg(d, a, b, c, k[10], 9, 38016083);\n        c = gg(c, d, a, b, k[15], 14, -660478335);\n        b = gg(b, c, d, a, k[4], 20, -405537848);\n        a = gg(a, b, c, d, k[9], 5, 568446438);\n        d = gg(d, a, b, c, k[14], 9, -1019803690);\n        c = gg(c, d, a, b, k[3], 14, -187363961);\n        b = gg(b, c, d, a, k[8], 20, 1163531501);\n        a = gg(a, b, c, d, k[13], 5, -1444681467);\n        d = gg(d, a, b, c, k[2], 9, -51403784);\n        c = gg(c, d, a, b, k[7], 14, 1735328473);\n        b = gg(b, c, d, a, k[12], 20, -1926607734);\n\n        a = hh(a, b, c, d, k[5], 4, -378558);\n        d = hh(d, a, b, c, k[8], 11, -2022574463);\n        c = hh(c, d, a, b, k[11], 16, 1839030562);\n        b = hh(b, c, d, a, k[14], 23, -35309556);\n        a = hh(a, b, c, d, k[1], 4, -1530992060);\n        d = hh(d, a, b, c, k[4], 11, 1272893353);\n        c = hh(c, d, a, b, k[7], 16, -155497632);\n        b = hh(b, c, d, a, k[10], 23, -1094730640);\n        a = hh(a, b, c, d, k[13], 4, 681279174);\n        d = hh(d, a, b, c, k[0], 11, -358537222);\n        c = hh(c, d, a, b, k[3], 16, -722521979);\n        b = hh(b, c, d, a, k[6], 23, 76029189);\n        a = hh(a, b, c, d, k[9], 4, -640364487);\n        d = hh(d, a, b, c, k[12], 11, -421815835);\n        c = hh(c, d, a, b, k[15], 16, 530742520);\n        b = hh(b, c, d, a, k[2], 23, -995338651);\n\n        a = ii(a, b, c, d, k[0], 6, -198630844);\n        d = ii(d, a, b, c, k[7], 10, 1126891415);\n        c = ii(c, d, a, b, k[14], 15, -1416354905);\n        b = ii(b, c, d, a, k[5], 21, -57434055);\n        a = ii(a, b, c, d, k[12], 6, 1700485571);\n        d = ii(d, a, b, c, k[3], 10, -1894986606);\n        c = ii(c, d, a, b, k[10], 15, -1051523);\n        b = ii(b, c, d, a, k[1], 21, -2054922799);\n        a = ii(a, b, c, d, k[8], 6, 1873313359);\n        d = ii(d, a, b, c, k[15], 10, -30611744);\n        c = ii(c, d, a, b, k[6], 15, -1560198380);\n        b = ii(b, c, d, a, k[13], 21, 1309151649);\n        a = ii(a, b, c, d, k[4], 6, -145523070);\n        d = ii(d, a, b, c, k[11], 10, -1120210379);\n        c = ii(c, d, a, b, k[2], 15, 718787259);\n        b = ii(b, c, d, a, k[9], 21, -343485551);\n\n        x[0] = add32(a, x[0]);\n        x[1] = add32(b, x[1]);\n        x[2] = add32(c, x[2]);\n        x[3] = add32(d, x[3]);\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/~/spark-md5/spark-md5.js\n ** module id = 78\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/~/vuvuzela/index.js\n ** module id = 79\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/events/events.js\n ** module id = 82\n ** module chunks = 0\n **/"],"sourceRoot":""}